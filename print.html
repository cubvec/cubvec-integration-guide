<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Cubvec Survey</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="index.html"><strong aria-hidden="true">1.</strong> Intro</a></li><li class="chapter-item expanded "><a href="pt_type_sequence/index.html"><strong aria-hidden="true">2.</strong> PT_TYPE_SEQUENCE</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="pt_type_sequence/parser.html"><strong aria-hidden="true">2.1.</strong> parser</a></li><li class="chapter-item expanded "><a href="pt_type_sequence/query.html"><strong aria-hidden="true">2.2.</strong> query</a></li><li class="chapter-item expanded "><a href="pt_type_sequence/optimizer.html"><strong aria-hidden="true">2.3.</strong> optimizer</a></li></ol></li><li class="chapter-item expanded "><a href="db_type_sequence/index.html"><strong aria-hidden="true">3.</strong> DB_TYPE_SEQUENCE</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="db_type_sequence/query.html"><strong aria-hidden="true">3.1.</strong> query</a></li><li class="chapter-item expanded "><a href="db_type_sequence/object.html"><strong aria-hidden="true">3.2.</strong> object</a></li><li class="chapter-item expanded "><a href="db_type_sequence/storage.html"><strong aria-hidden="true">3.3.</strong> storage</a></li><li class="chapter-item expanded "><a href="db_type_sequence/parser.html"><strong aria-hidden="true">3.4.</strong> parser</a></li><li class="chapter-item expanded "><a href="db_type_sequence/base.html"><strong aria-hidden="true">3.5.</strong> base</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Cubvec Survey</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="cubvector-code-analysis"><a class="header" href="#cubvector-code-analysis">CUBVECTOR Code Analysis</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pt_type_sequence"><a class="header" href="#pt_type_sequence">PT_TYPE_SEQUENCE</a></h1>
<p>총 몇번 사용될까?</p>
<pre><code class="language-bash">73
</code></pre>
<p>어디에 등장할까?</p>
<pre><code class="language-json">14 src/parser/csql_grammar.y
13 src/parser/type_checking.c
13 src/parser/semantic_check.c
8 src/parser/name_resolution.c
6 src/parser/parse_tree_cl.c
5 src/parser/parse_dbi.c
4 src/parser/parse_tree.h
4 src/parser/func_type.cpp
2 src/query/execute_schema.c
1 src/parser/view_transform.c
1 src/parser/method_transform.c
1 src/optimizer/query_rewrite.c
1 src/optimizer/query_graph.c
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="parser-directory"><a class="header" href="#parser-directory">parser directory</a></h1>
<pre><code class="language-cpp">func_type.cpp
104-{
105-  {PT_TYPE_DOUBLE, {PT_GENERIC_TYPE_NUMBER}, {}},
106-};
107-
108-func_all_signatures sig_of_count_star =
109-{
110-  {PT_TYPE_BIGINT, {}, {}},
111-};
112-
113-func_all_signatures sig_of_count =
114-{
115-  {PT_TYPE_BIGINT, {PT_GENERIC_TYPE_ANY}, {}},
116-};
117-
118-func_all_signatures sig_of_sum =
119-{
120-  {0, {PT_GENERIC_TYPE_NUMBER}, {}},
121-  {0, {PT_TYPE_MAYBE}, {}},
122-  {0, {PT_TYPE_SET}, {}},
123-  {0, {PT_TYPE_MULTISET}, {}},
124:  {0, {PT_TYPE_SEQUENCE}, {}},
125-};
126-
127-func_all_signatures sig_ret_double_arg_r_any =
128-{
129-  {PT_TYPE_DOUBLE, {}, {}},
130-  {PT_TYPE_DOUBLE, {}, {PT_GENERIC_TYPE_ANY}},
131-};
132-
133-func_all_signatures sig_of_ntile =
134-{
135-  {PT_TYPE_INTEGER, {PT_GENERIC_TYPE_NUMBER}, {}}, //argument value will be truncated at execution
136-};
137-
138-/*cannot define a clear signature because casting depends on actual value
139-  MEDIAN('123456')     &lt;=&gt; MEDIAN(double) -&gt; double
140-  MEDIAN('2018-03-14') &lt;=&gt; MEDIAN(date)   -&gt; date  */
141-func_all_signatures sig_of_median =
142-{
143-  {PT_TYPE_MAYBE, {PT_GENERIC_TYPE_NUMBER}, {}}, //if ret type is double =&gt; tests with median(int) will fail
144-  {0, {PT_GENERIC_TYPE_DATETIME}, {}},
</code></pre>
<pre><code class="language-cpp">
298-  {PT_TYPE_JSON, {PT_GENERIC_TYPE_JSON_VAL}, {}}
299-};
300-
301-func_all_signatures sig_of_json_objectagg =
302-{
303-  {PT_TYPE_JSON, {PT_GENERIC_TYPE_STRING, PT_GENERIC_TYPE_JSON_VAL}, {}}
304-};
305-
306-func_all_signatures sig_ret_set_arg_r_any =
307-{
308-  {PT_TYPE_SET, {}, {PT_GENERIC_TYPE_ANY}},
309-};
310-
311-func_all_signatures sig_ret_multiset_arg_r_any =
312-{
313-  {PT_TYPE_MULTISET, {}, {PT_GENERIC_TYPE_ANY}},
314-};
315-
316-func_all_signatures sig_ret_sequence_arg_r_any =
317-{
318:  {PT_TYPE_SEQUENCE, {}, {PT_GENERIC_TYPE_ANY}},
319-};
320-
321-func_all_signatures sig_of_generic =
322-{
323-  {0, {PT_GENERIC_TYPE_ANY}, {}},
324-};
325-
326-func_all_signatures sig_ret_string_arg_jdoc =
327-{
328-  {PT_TYPE_VARCHAR, {PT_GENERIC_TYPE_JSON_DOC}, {}},
329-};
330-
331-func_all_signatures sig_ret_type0_arg_str =
332-{
333-  {0, {PT_GENERIC_TYPE_STRING}, {}},
334-};
335-
336-func_all_signatures sig_of_benchmark =
337-{
338-  {PT_TYPE_DOUBLE, {PT_GENERIC_TYPE_DISCRETE_NUMBER, PT_GENERIC_TYPE_ANY}, {}},
</code></pre>
<pre><code class="language-cpp">
1964-   node-&gt;type_enum = PT_TYPE_BIGINT;
1965-   break;
1966-
1967- case PT_AGG_BIT_AND:
1968- case PT_AGG_BIT_OR:
1969- case PT_AGG_BIT_XOR:
1970-   node-&gt;type_enum = PT_TYPE_BIGINT;
1971-   break;
1972-
1973- case F_TABLE_SET:
1974-   node-&gt;type_enum = PT_TYPE_SET;
1975-   pt_add_type_to_set (parser, pt_get_select_list (parser, arg_list), &amp;node-&gt;data_type);
1976-   break;
1977-
1978- case F_TABLE_MULTISET:
1979-   node-&gt;type_enum = PT_TYPE_MULTISET;
1980-   pt_add_type_to_set (parser, pt_get_select_list (parser, arg_list), &amp;node-&gt;data_type);
1981-   break;
1982-
1983- case F_TABLE_SEQUENCE:
1984:   node-&gt;type_enum = PT_TYPE_SEQUENCE;
1985-   pt_add_type_to_set (parser, pt_get_select_list (parser, arg_list), &amp;node-&gt;data_type);
1986-   break;
1987-
1988- case F_SET:
1989-   node-&gt;type_enum = PT_TYPE_SET;
1990-   pt_add_type_to_set (parser, arg_list, &amp;node-&gt;data_type);
1991-   break;
1992-
1993- case F_MULTISET:
1994-   node-&gt;type_enum = PT_TYPE_MULTISET;
1995-   pt_add_type_to_set (parser, arg_list, &amp;node-&gt;data_type);
1996-   break;
1997-
1998- case F_SEQUENCE:
1999:   node-&gt;type_enum = PT_TYPE_SEQUENCE;
2000-   pt_add_type_to_set (parser, arg_list, &amp;node-&gt;data_type);
2001-   break;
2002-
2003- case PT_SUM:
2004-   node-&gt;type_enum = arg_type;
2005-   node-&gt;data_type = parser_copy_tree_list (parser, arg_list-&gt;data_type);
2006-   if (arg_type == PT_TYPE_NUMERIC &amp;&amp; node-&gt;data_type)
2007-     {
2008-       node-&gt;data_type-&gt;info.data_type.precision = DB_MAX_NUMERIC_PRECISION;
2009-     }
2010-   break;
2011-
2012- case PT_AVG:
2013- case PT_STDDEV:
2014- case PT_STDDEV_POP:
2015- case PT_STDDEV_SAMP:
2016- case PT_VARIANCE:
2017- case PT_VAR_POP:
2018- case PT_VAR_SAMP:
2019-   node-&gt;type_enum = arg_type;

</code></pre>
<pre><code class="language-cpp">parse_tree.h
128-        ( ((t) == PT_TYPE_INTEGER)  || \
129-   ((t) == PT_TYPE_BIGINT)   || \
130-   ((t) == PT_TYPE_FLOAT)    || \
131-   ((t) == PT_TYPE_DOUBLE)   || \
132-   ((t) == PT_TYPE_SMALLINT) || \
133-   ((t) == PT_TYPE_MONETARY) || \
134-   ((t) == PT_TYPE_LOGICAL)  || \
135-   ((t) == PT_TYPE_NUMERIC))
136-
137-#define PT_IS_DISCRETE_NUMBER_TYPE(t) \
138-        ( ((t) == PT_TYPE_INTEGER)  || \
139-          ((t) == PT_TYPE_BIGINT)   || \
140-   ((t) == PT_TYPE_SMALLINT))
141-
142-#define PT_IS_COUNTER_TYPE(t) \
143-  PT_IS_DISCRETE_NUMBER_TYPE(t)
144-
145-#define PT_IS_COLLECTION_TYPE(t) \
146-        ( ((t) == PT_TYPE_SET)       || \
147-   ((t) == PT_TYPE_MULTISET)  || \
148:   ((t) == PT_TYPE_SEQUENCE))
149-
150-#define PT_IS_STRING_TYPE(t) \
151-        ( ((t) == PT_TYPE_CHAR)     || \
152-   ((t) == PT_TYPE_VARCHAR)  || \
153-   ((t) == PT_TYPE_NCHAR)    || \
154-   ((t) == PT_TYPE_VARNCHAR) || \
155-   ((t) == PT_TYPE_BIT)      || \
156-   ((t) == PT_TYPE_VARBIT))
157-
158-#define PT_IS_NATIONAL_CHAR_STRING_TYPE(t) \
159-        ( ((t) == PT_TYPE_NCHAR)      || \
160-   ((t) == PT_TYPE_VARNCHAR))
161-
162-#define PT_IS_SIMPLE_CHAR_STRING_TYPE(t) \
163-        ( ((t) == PT_TYPE_CHAR)      || \
164-   ((t) == PT_TYPE_VARCHAR))
165-
166-#define PT_IS_CHAR_STRING_TYPE(t) \
167-        ( ((t) == PT_TYPE_CHAR)      || \
168-   ((t) == PT_TYPE_VARCHAR)   || \
169-   ((t) == PT_TYPE_NCHAR)     || \
170-   ((t) == PT_TYPE_VARNCHAR))
171-
172-#define PT_IS_BIT_STRING_TYPE(t) \
173-        ( ((t) == PT_TYPE_BIT)      || \
174-   ((t) == PT_TYPE_VARBIT))
175-
176-#define PT_IS_COMPLEX_TYPE(t) \
177-        ( ((t) == PT_TYPE_MONETARY)  || \
178-   ((t) == PT_TYPE_NUMERIC)   || \
179-   ((t) == PT_TYPE_CHAR)      || \
180-   ((t) == PT_TYPE_VARCHAR)   || \
181-   ((t) == PT_TYPE_NCHAR)     || \
182-   ((t) == PT_TYPE_VARNCHAR)  || \
183-   ((t) == PT_TYPE_BIT)       || \
184-   ((t) == PT_TYPE_VARBIT)    || \
185-   ((t) == PT_TYPE_OBJECT)    || \
186-   ((t) == PT_TYPE_SET)       || \
187-   ((t) == PT_TYPE_MULTISET)  || \
188:   ((t) == PT_TYPE_SEQUENCE)  || \
189-   ((t) == PT_TYPE_ENUMERATION))
190-
191-#define PT_IS_DATE_TIME_WITH_TZ_TYPE(t) \
192-        ( (t) == PT_TYPE_TIMESTAMPTZ  || \
193-   (t) == PT_TYPE_TIMESTAMPLTZ || \
194-   (t) == PT_TYPE_DATETIMETZ   || \
195-   (t) == PT_TYPE_DATETIMELTZ)
196-
197-#define PT_IS_DATE_TIME_TYPE(t) \
198-        ( ((t) == PT_TYPE_DATE)         || \
199-   ((t) == PT_TYPE_TIME)         || \
200-   ((t) == PT_TYPE_TIMESTAMP)    || \
201-   ((t) == PT_TYPE_DATETIME)     || \
202-   ((t) == PT_TYPE_DATETIMETZ)   || \
203-   ((t) == PT_TYPE_DATETIMELTZ)  || \
204-   ((t) == PT_TYPE_TIMESTAMPTZ)  || \
205-   ((t) == PT_TYPE_TIMESTAMPLTZ))
206-
207-#define PT_HAS_DATE_PART(t) \
208-        ( ((t) == PT_TYPE_DATE)         || \
</code></pre>
<pre><code class="language-cpp">
321-
322-#define PT_IS_NAME_NODE(n) \
323-        ( (n) &amp;&amp; ((n)-&gt;node_type == PT_NAME) )
324-
325-#define PT_IS_OID_NAME(n) \
326-        ( (n) &amp;&amp; \
327-          ((n)-&gt;node_type == PT_NAME &amp;&amp; \
328-             ((n)-&gt;info.name.meta_class == PT_OID_ATTR || \
329-              (n)-&gt;info.name.meta_class == PT_VID_ATTR) ) \
330-        )
331-
332-#define PT_IS_VALUE_NODE(n) \
333-        ( (n) &amp;&amp; ((n)-&gt;node_type == PT_VALUE) )
334-
335-#define PT_IS_INSERT_VALUE_NODE(n) \
336- ( (n) &amp;&amp; ((n)-&gt;node_type == PT_INSERT_VALUE) )
337-
338-#define PT_IS_SET_TYPE(n) \
339-        ( (n) &amp;&amp; ((n)-&gt;type_enum == PT_TYPE_SET || \
340-                  (n)-&gt;type_enum == PT_TYPE_MULTISET || \
341:                  (n)-&gt;type_enum == PT_TYPE_SEQUENCE) \
342-        )
343-
344-#define PT_IS_HOSTVAR(n) \
345-        ( (n) &amp;&amp; ((n)-&gt;node_type == PT_HOST_VAR) )
346-
347-#define PT_IS_INPUT_HOSTVAR(n) \
348-        ( (n) &amp;&amp; ((n)-&gt;node_type == PT_HOST_VAR &amp;&amp; \
349-                  (n)-&gt;info.host_var.var_type == PT_HOST_IN) \
350-        )
351-
352-#define PT_IS_OUTPUT_HOSTVAR(n) \
353-        ( (n) &amp;&amp; ((n)-&gt;node_type == PT_HOST_VAR &amp;&amp; \
354-                  (n)-&gt;info.host_var.var_type == PT_HOST_OUT) \
355-        )
356-
357-#define PT_IS_PARAMETER(n) \
358-        ( (n) &amp;&amp; ((n)-&gt;node_type == PT_NAME &amp;&amp; \
359-                  (n)-&gt;info.name.meta_class == PT_PARAMETER) )
360-
361-#define PT_IS_INPUT_PARAMETER(n) \
</code></pre>
<pre><code class="language-cpp">
1099-  PT_TYPE_NUMERIC,
1100-  PT_TYPE_CHAR,
1101-  PT_TYPE_VARCHAR,
1102-  PT_TYPE_NCHAR,
1103-  PT_TYPE_VARNCHAR,
1104-  PT_TYPE_BIT,
1105-  PT_TYPE_VARBIT,
1106-  PT_TYPE_LOGICAL,
1107-  PT_TYPE_MAYBE,
1108-  PT_TYPE_JSON,
1109-
1110-  /* special values */
1111-  PT_TYPE_NA,   /* in SELECT NA */
1112-  PT_TYPE_NULL,   /* in assignment and defaults */
1113-  PT_TYPE_STAR,   /* select (*), count (*), will be expanded later */
1114-
1115-  /* non primitive types */
1116-  PT_TYPE_OBJECT,
1117-  PT_TYPE_SET,
1118-  PT_TYPE_MULTISET,
1119:  PT_TYPE_SEQUENCE,
1120-  PT_TYPE_MIDXKEY,
1121-  PT_TYPE_COMPOUND,
1122-
1123-  PT_TYPE_EXPR_SET,  /* type of parentheses expr set, avail for parser only */
1124-  PT_TYPE_RESULTSET,
1125-
1126-  PT_TYPE_BIGINT,
1127-
1128-  PT_TYPE_BLOB,
1129-  PT_TYPE_CLOB,
1130-  PT_TYPE_ELO,
1131-
1132-  PT_TYPE_ENUMERATION,
1133-  PT_TYPE_TIMESTAMPLTZ,
1134-  PT_TYPE_TIMESTAMPTZ,
1135-  PT_TYPE_DATETIMETZ,
1136-  PT_TYPE_DATETIMELTZ,
1137-
1138-  PT_TYPE_MAX,
1139-


</code></pre>
<pre><code class="language-cpp">view_transform.c
6996-{
6997-  PT_NODE *select_list;
6998-
6999-  if (!parser || !stmt)
7000-    {
7001-      return;
7002-    }
7003-
7004-  switch (stmt-&gt;node_type)
7005-    {
7006-    case PT_SELECT:
7007-      select_list = stmt-&gt;info.query.q.select.list;
7008-      if (select_list != NULL &amp;&amp; !PT_IS_VALUE_QUERY (stmt))
7009- {
7010-   DB_VALUE vid;
7011-
7012-   select_list-&gt;node_type = PT_FUNCTION;
7013-   /* make info set up properly */
7014-   memset (&amp;(select_list-&gt;info), 0, sizeof (select_list-&gt;info));
7015-   select_list-&gt;data_type-&gt;info.data_type.entity = NULL;
7016:   select_list-&gt;data_type-&gt;info.data_type.virt_type_enum = PT_TYPE_SEQUENCE;
7017-   select_list-&gt;type_enum = PT_TYPE_OBJECT;
7018-
7019-   /* set vclass_name as literal string */
7020-   db_make_string (&amp;vid, db_get_class_name (virt_entity-&gt;info.name.db_object));
7021-   select_list-&gt;info.function.arg_list = pt_dbval_to_value (parser, &amp;vid);
7022-   select_list-&gt;info.function.function_type = F_SEQUENCE;
7023-
7024-   select_list-&gt;data_type-&gt;info.data_type.virt_object = virt_entity-&gt;info.name.db_object;
7025-
7026-   pr_clear_value (&amp;vid);
7027- }
7028-      break;
7029-    case PT_UNION:
7030-    case PT_INTERSECTION:
7031-    case PT_DIFFERENCE:
7032-      mq_set_non_updatable_oid (parser, stmt-&gt;info.query.q.union_.arg1, virt_entity);
7033-      mq_set_non_updatable_oid (parser, stmt-&gt;info.query.q.union_.arg2, virt_entity);
7034-      break;
7035-    default:
7036-      break;


</code></pre>
<pre><code class="language-cpp">semantic_check.c
372-      is_compatible = true;
373-
374-      cinfo-&gt;type_enum = common_type;
375-
376-      cinfo-&gt;scale = MAX (att1_info-&gt;scale, att2_info-&gt;scale);
377-      cinfo-&gt;prec = MAX ((att1_info-&gt;prec - att1_info-&gt;scale), (att2_info-&gt;prec - att2_info-&gt;scale)) + cinfo-&gt;scale;
378-
379-      if (cinfo-&gt;prec &gt; DB_MAX_NUMERIC_PRECISION)
380- {   /* overflow */
381-   cinfo-&gt;scale -= (cinfo-&gt;prec - DB_MAX_NUMERIC_PRECISION);
382-   if (cinfo-&gt;scale &lt; 0)
383-     {
384-       cinfo-&gt;scale = 0;
385-     }
386-   cinfo-&gt;prec = DB_MAX_NUMERIC_PRECISION;
387- }
388-      break;
389-
390-    case PT_TYPE_SET:
391-    case PT_TYPE_MULTISET:
392:    case PT_TYPE_SEQUENCE:
393-      /* NEVER try to fix set types */
394-      is_compatible = true;
395-      break;
396-    case PT_TYPE_NONE:
397-      is_compatible = false;
398-      break;
399-
400-    default:
401-      is_compatible = true;
402-      cinfo-&gt;type_enum = common_type;
403-      break;
404-    }
405-
406-  return is_compatible;
407-}
408-
409-/* pt_values_query_to_compatible_cast () - cast select list with cinfo
410- *   return:
411- *   parser(in):
412- *   node(in):
</code></pre>
<pre><code class="language-cpp">
1025-  switch (arg_type)
1026-    {
1027-    case PT_TYPE_INTEGER:
1028-    case PT_TYPE_BIGINT:
1029-    case PT_TYPE_FLOAT:
1030-    case PT_TYPE_DOUBLE:
1031-    case PT_TYPE_SMALLINT:
1032-    case PT_TYPE_MONETARY:
1033-    case PT_TYPE_NUMERIC:
1034-      switch (cast_type)
1035- {
1036- case PT_TYPE_BIT:
1037- case PT_TYPE_VARBIT:
1038- case PT_TYPE_DATE:
1039-   /* allow numeric to TIME and TIMESTAMP conversions */
1040- case PT_TYPE_DATETIME:
1041- case PT_TYPE_DATETIMETZ:
1042- case PT_TYPE_DATETIMELTZ:
1043- case PT_TYPE_SET:
1044- case PT_TYPE_MULTISET:
1045: case PT_TYPE_SEQUENCE:
1046- case PT_TYPE_BLOB:
1047- case PT_TYPE_CLOB:
1048- case PT_TYPE_OBJECT:
1049-   cast_is_valid = PT_CAST_INVALID;
1050-   break;
1051- default:
1052-   break;
1053- }
1054-      break;
1055-    case PT_TYPE_DATE:
1056-      switch (cast_type)
1057- {
1058- case PT_TYPE_INTEGER:
1059- case PT_TYPE_BIGINT:
1060- case PT_TYPE_FLOAT:
1061- case PT_TYPE_DOUBLE:
1062- case PT_TYPE_SMALLINT:
1063- case PT_TYPE_MONETARY:
1064- case PT_TYPE_NUMERIC:
1065- case PT_TYPE_BIT:
1066- case PT_TYPE_VARBIT:
1067- case PT_TYPE_TIME:
1068- case PT_TYPE_SET:
1069- case PT_TYPE_MULTISET:
1070: case PT_TYPE_SEQUENCE:
1071- case PT_TYPE_BLOB:
1072- case PT_TYPE_CLOB:
1073- case PT_TYPE_OBJECT:
1074-   cast_is_valid = PT_CAST_INVALID;
1075-   break;
1076- default:
1077-   break;
1078- }
1079-      break;
1080-    case PT_TYPE_TIME:
1081-      switch (cast_type)
1082- {
1083- case PT_TYPE_INTEGER:
1084- case PT_TYPE_BIGINT:
1085- case PT_TYPE_FLOAT:
1086- case PT_TYPE_DOUBLE:
1087- case PT_TYPE_SMALLINT:
1088- case PT_TYPE_MONETARY:
1089- case PT_TYPE_NUMERIC:
1090- case PT_TYPE_BIT:
1091- case PT_TYPE_VARBIT:
1092- case PT_TYPE_DATE:
1093- case PT_TYPE_SET:
1094- case PT_TYPE_MULTISET:
1095: case PT_TYPE_SEQUENCE:
1096- case PT_TYPE_BLOB:
1097- case PT_TYPE_CLOB:
1098- case PT_TYPE_OBJECT:
1099-   cast_is_valid = PT_CAST_INVALID;
1100-   break;
1101- case PT_TYPE_TIMESTAMP:
1102- case PT_TYPE_TIMESTAMPLTZ:
1103- case PT_TYPE_TIMESTAMPTZ:
1104- case PT_TYPE_DATETIME:
1105- case PT_TYPE_DATETIMELTZ:
1106- case PT_TYPE_DATETIMETZ:
1107-   cast_is_valid = PT_CAST_UNSUPPORTED;
1108-   break;
1109- default:
1110-   break;
1111- }
1112-      break;
1113-    case PT_TYPE_TIMESTAMP:
1114-    case PT_TYPE_TIMESTAMPTZ:
1115-    case PT_TYPE_TIMESTAMPLTZ:
1116-      switch (cast_type)
1117- {
1118- case PT_TYPE_INTEGER:
1119- case PT_TYPE_BIGINT:
1120- case PT_TYPE_FLOAT:
1121- case PT_TYPE_DOUBLE:
1122- case PT_TYPE_SMALLINT:
1123- case PT_TYPE_MONETARY:
1124- case PT_TYPE_NUMERIC:
1125- case PT_TYPE_BIT:
1126- case PT_TYPE_VARBIT:
1127- case PT_TYPE_SET:
1128- case PT_TYPE_MULTISET:
1129: case PT_TYPE_SEQUENCE:
1130- case PT_TYPE_BLOB:
1131- case PT_TYPE_CLOB:
1132- case PT_TYPE_OBJECT:
1133-   cast_is_valid = PT_CAST_INVALID;
1134-   break;
1135- default:
1136-   break;
1137- }
1138-      break;
1139-    case PT_TYPE_DATETIME:
1140-    case PT_TYPE_DATETIMETZ:
1141-    case PT_TYPE_DATETIMELTZ:
1142-      switch (cast_type)
1143- {
1144- case PT_TYPE_INTEGER:
1145- case PT_TYPE_FLOAT:
1146- case PT_TYPE_DOUBLE:
1147- case PT_TYPE_SMALLINT:
1148- case PT_TYPE_MONETARY:
1149- case PT_TYPE_NUMERIC:
1150- case PT_TYPE_BIT:
1151- case PT_TYPE_VARBIT:
1152- case PT_TYPE_SET:
1153- case PT_TYPE_MULTISET:
1154: case PT_TYPE_SEQUENCE:
1155- case PT_TYPE_BLOB:
1156- case PT_TYPE_CLOB:
1157- case PT_TYPE_OBJECT:
1158-   cast_is_valid = PT_CAST_INVALID;
1159-   break;
1160- default:
1161-   break;
1162- }
1163-      break;
1164-    case PT_TYPE_CHAR:
1165-    case PT_TYPE_VARCHAR:
1166-    case PT_TYPE_NCHAR:
1167-    case PT_TYPE_VARNCHAR:
1168-      if ((PT_IS_NATIONAL_CHAR_STRING_TYPE (arg_type) &amp;&amp; PT_IS_SIMPLE_CHAR_STRING_TYPE (cast_type))
1169-   || (PT_IS_SIMPLE_CHAR_STRING_TYPE (arg_type) &amp;&amp; PT_IS_NATIONAL_CHAR_STRING_TYPE (cast_type)))
1170- {
1171-   cast_is_valid = PT_CAST_INVALID;
1172-   break;
1173- }
1174-
1175-      switch (cast_type)
1176- {
1177- case PT_TYPE_SET:
1178- case PT_TYPE_MULTISET:
1179: case PT_TYPE_SEQUENCE:
1180-   cast_is_valid = PT_CAST_UNSUPPORTED;
1181-   break;
1182- case PT_TYPE_OBJECT:
1183-   cast_is_valid = PT_CAST_INVALID;
1184-   break;
1185- default:
1186-   break;
1187- }
1188-      break;
1189-    case PT_TYPE_BIT:
1190-    case PT_TYPE_VARBIT:
1191-      switch (cast_type)
1192- {
1193- case PT_TYPE_INTEGER:
1194- case PT_TYPE_BIGINT:
1195- case PT_TYPE_FLOAT:
1196- case PT_TYPE_DOUBLE:
1197- case PT_TYPE_SMALLINT:
1198- case PT_TYPE_MONETARY:
1199- case PT_TYPE_NUMERIC:
1200- case PT_TYPE_DATE:
1201- case PT_TYPE_TIME:
1202- case PT_TYPE_TIMESTAMP:
1203- case PT_TYPE_TIMESTAMPTZ:
1204- case PT_TYPE_TIMESTAMPLTZ:
1205- case PT_TYPE_DATETIME:
1206- case PT_TYPE_DATETIMELTZ:
1207- case PT_TYPE_DATETIMETZ:
1208- case PT_TYPE_SET:
1209- case PT_TYPE_MULTISET:
1210: case PT_TYPE_SEQUENCE:
1211- case PT_TYPE_OBJECT:
1212-   cast_is_valid = PT_CAST_INVALID;
1213-   break;
1214- case PT_TYPE_CLOB:
1215-   cast_is_valid = PT_CAST_UNSUPPORTED;
1216-   break;
1217- default:
1218-   break;
1219- }
1220-      break;
1221-    case PT_TYPE_OBJECT:
1222-      /* some functions like DECODE, CASE perform wrap with CAST, allow it */
1223-      if (!PT_EXPR_INFO_IS_FLAGED (node, PT_EXPR_INFO_CAST_SHOULD_FOLD))
1224- {
1225-   cast_is_valid = PT_CAST_UNSUPPORTED;
1226- }
1227-      break;
1228-    case PT_TYPE_SET:
1229-    case PT_TYPE_MULTISET:
1230:    case PT_TYPE_SEQUENCE:
1231-      switch (cast_type)
1232- {
1233- case PT_TYPE_INTEGER:
1234- case PT_TYPE_BIGINT:
1235- case PT_TYPE_FLOAT:
1236- case PT_TYPE_DOUBLE:
1237- case PT_TYPE_SMALLINT:
1238- case PT_TYPE_MONETARY:
1239- case PT_TYPE_NUMERIC:
1240- case PT_TYPE_BIT:
1241- case PT_TYPE_VARBIT:
1242- case PT_TYPE_DATE:
1243- case PT_TYPE_TIME:
1244- case PT_TYPE_TIMESTAMP:
1245- case PT_TYPE_TIMESTAMPTZ:
1246- case PT_TYPE_TIMESTAMPLTZ:
1247- case PT_TYPE_DATETIME:
1248- case PT_TYPE_DATETIMETZ:
1249- case PT_TYPE_DATETIMELTZ:
1250- case PT_TYPE_BLOB:
</code></pre>
<pre><code class="language-cpp">
1490-      i_attr-&gt;type_enum = pt_db_to_type_enum (db_attribute_type (attributes));
1491-      switch (i_attr-&gt;type_enum)
1492- {
1493- case PT_TYPE_OBJECT:
1494-   cls = db_domain_class (db_attribute_domain (attributes));
1495-   if (cls)
1496-     {
1497-       name = pt_name (parser, db_get_class_name (cls));
1498-       name-&gt;info.name.meta_class = PT_CLASS;
1499-       name-&gt;info.name.db_object = cls;
1500-       name-&gt;info.name.spec_id = (UINTPTR) name;
1501-       i_attr-&gt;data_type = typ = parser_new_node (parser, PT_DATA_TYPE);
1502-       if (typ)
1503-  {
1504-    typ-&gt;info.data_type.entity = name;
1505-  }
1506-     }
1507-   break;
1508-
1509- case PT_TYPE_SET:
1510: case PT_TYPE_SEQUENCE:
1511- case PT_TYPE_MULTISET:
1512-   types = NULL;
1513-   dom = db_domain_set (db_attribute_domain (attributes));
1514-   while (dom)
1515-     {
1516-       typ = pt_domain_to_data_type (parser, dom);
1517-       if (typ)
1518-  {
1519-    typ-&gt;next = types;
1520-  }
1521-       types = typ;
1522-       dom = db_domain_next (dom);
1523-     }
1524-   i_attr-&gt;data_type = types;
1525-   break;
1526-
1527- default:
1528-   dom = attributes-&gt;domain;
1529-   typ = pt_domain_to_data_type (parser, dom);
1530-   i_attr-&gt;data_type = typ;
</code></pre>
<pre><code class="language-cpp">
2033-
2034-  if (!d_col || !s_col || !PT_IS_COLLECTION_TYPE (d_col-&gt;type_enum))
2035-    {
2036-      return 0;
2037-    }
2038-
2039-  /* NULL is assignable to any class type */
2040-  if (s_col-&gt;type_enum == PT_TYPE_NA || s_col-&gt;type_enum == PT_TYPE_NULL)
2041-    {
2042-      return 1;
2043-    }
2044-
2045-  /* make sure we are dealing only with collection types */
2046-  if (!PT_IS_COLLECTION_TYPE (s_col-&gt;type_enum))
2047-    {
2048-      return 0;
2049-    }
2050-
2051-  /* can't assign a multiset or a sequence to a set, or a multiset to a sequence */
2052-  if (((d_col-&gt;type_enum == PT_TYPE_SET)
2053:       &amp;&amp; ((s_col-&gt;type_enum == PT_TYPE_MULTISET) || (s_col-&gt;type_enum == PT_TYPE_SEQUENCE)))
2054:      || ((d_col-&gt;type_enum == PT_TYPE_SEQUENCE) &amp;&amp; (s_col-&gt;type_enum == PT_TYPE_MULTISET)))
2055-    {
2056-      assignable = 0;
2057-    }
2058-  else if (!d_col-&gt;data_type)
2059-    {
2060-      /* the wildcard set (set of anything) can be assigned a set of any type. */
2061-      assignable = 1;
2062-    }
2063-  else if (!s_col-&gt;data_type)
2064-    {
2065-      /* in this case, we have a wild card set being assigned to a non-wildcard set. */
2066-      assignable = 0;
2067-    }
2068-  else
2069-    {
2070-      /* Check to see that every type in the source collection is in the destination collection.  That is, the source
2071-       * types must be a subset of the destination types.  There is no coercion allowed. */
2072-      PT_NODE *st, *dt;
2073-      int found;
2074-
</code></pre>
<pre><code class="language-cpp">
9410-    case PT_TYPE_SMALLINT:
9411-    case PT_TYPE_INTEGER:
9412-    case PT_TYPE_BIGINT:
9413-    case PT_TYPE_NUMERIC:
9414-    case PT_TYPE_FLOAT:
9415-    case PT_TYPE_DOUBLE:
9416-    case PT_TYPE_CHAR:
9417-    case PT_TYPE_VARCHAR:
9418-    case PT_TYPE_DATE:
9419-    case PT_TYPE_TIME:
9420-    case PT_TYPE_DATETIME:
9421-    case PT_TYPE_TIMESTAMP:
9422-    case PT_TYPE_RESULTSET:
9423-      return true;
9424-
9425-    case PT_TYPE_OBJECT:
9426-      return pt_is_defined_class (parser, data_type);
9427-
9428-    case PT_TYPE_SET:
9429-    case PT_TYPE_MULTISET:
9430:    case PT_TYPE_SEQUENCE:
9431-      {
9432- PT_NODE *dt;
9433- for (dt = data_type; dt; dt = dt-&gt;next)
9434-   {
9435-     if (!pt_is_defined_class (parser, dt))
9436-       {
9437-  return false;
9438-       }
9439-   }
9440-      }
9441-      return true;
9442-
9443-    default:
9444-      return false;
9445-    }
9446-}
9447-
9448-static const char *
9449-pt_get_type_name (PT_TYPE_ENUM type_enum, PT_NODE * data_type)
9450-{


</code></pre>
<pre><code class="language-cpp">type_checking.c
6425- *   return:
6426- *   type_enum(in):
6427- */
6428-static bool
6429-pt_is_symmetric_type (const PT_TYPE_ENUM type_enum)
6430-{
6431-  switch (type_enum)
6432-    {
6433-    case PT_TYPE_INTEGER:
6434-    case PT_TYPE_BIGINT:
6435-    case PT_TYPE_FLOAT:
6436-    case PT_TYPE_DOUBLE:
6437-    case PT_TYPE_NUMERIC:
6438-    case PT_TYPE_SMALLINT:
6439-    case PT_TYPE_MONETARY:
6440-
6441-    case PT_TYPE_LOGICAL:
6442-
6443-    case PT_TYPE_SET:
6444-    case PT_TYPE_MULTISET:
6445:    case PT_TYPE_SEQUENCE:
6446-    case PT_TYPE_OBJECT:
6447-
6448-    case PT_TYPE_VARCHAR:
6449-    case PT_TYPE_CHAR:
6450-    case PT_TYPE_VARNCHAR:
6451-    case PT_TYPE_NCHAR:
6452-    case PT_TYPE_VARBIT:
6453-    case PT_TYPE_BIT:
6454-      return true;
6455-
6456-    default:
6457-      return false;
6458-    }
6459-}
6460-
6461-/*
6462- * pt_is_symmetric_op () -
6463- *   return:
6464- *   op(in):
6465- */
</code></pre>
<pre><code class="language-cpp">
7227-   if (col)
7228-     {
7229-       col-&gt;type_enum = PT_TYPE_NULL;
7230-       subq-&gt;list = parser_append_node (subq-&gt;list, col);
7231-     }
7232-   else
7233-     {
7234-       PT_ERRORm (parser, node, MSGCAT_SET_PARSER_SEMANTIC, MSGCAT_SEMANTIC_OUT_OF_MEMORY);
7235-       return NULL;
7236-     }
7237- }
7238-
7239-      /* rewrite FROM list */
7240-      set = parser_new_node (parser, PT_VALUE);
7241-      spec = parser_new_node (parser, PT_SPEC);
7242-      if (set &amp;&amp; spec)
7243- {
7244-   parser_free_tree (parser, subq-&gt;from);
7245-   subq-&gt;from = NULL;
7246-
7247:   set-&gt;type_enum = PT_TYPE_SEQUENCE;
7248-
7249-   spec-&gt;info.spec.id = (UINTPTR) spec;
7250-   spec-&gt;info.spec.derived_table = set;
7251-   spec-&gt;info.spec.derived_table_type = PT_IS_SET_EXPR;
7252-
7253-   /* set line number to dummy class, dummy attr */
7254-   spec-&gt;info.spec.range_var = pt_name (parser, "av6749");
7255-   spec-&gt;info.spec.as_attr_list = pt_name (parser, "av_1");
7256-
7257-   if (spec-&gt;info.spec.as_attr_list)
7258-     {
7259-       PT_NAME_INFO_SET_FLAG (spec-&gt;info.spec.as_attr_list, PT_NAME_GENERATED_DERIVED_SPEC);
7260-     }
7261-   subq-&gt;from = spec;
7262- }
7263-      else
7264- {
7265-   PT_ERRORm (parser, node, MSGCAT_SET_PARSER_SEMANTIC, MSGCAT_SEMANTIC_OUT_OF_MEMORY);
7266-   return NULL;
7267- }
</code></pre>
<pre><code class="language-cpp">
11159-     default:
11160-       common_type = PT_TYPE_NONE;
11161-       break;
11162-     }
11163-   break;
11164-
11165- case PT_TYPE_OBJECT:
11166-   switch (arg2_type)
11167-     {
11168-     case PT_TYPE_OBJECT:
11169-       common_type = PT_TYPE_OBJECT;
11170-       break;
11171-     default:
11172-       common_type = PT_TYPE_NONE;
11173-       break;
11174-     }
11175-   break;
11176-
11177- case PT_TYPE_SET:
11178- case PT_TYPE_MULTISET:
11179: case PT_TYPE_SEQUENCE:
11180-   switch (arg2_type)
11181-     {
11182-     case PT_TYPE_SET:
11183-     case PT_TYPE_MULTISET:
11184:     case PT_TYPE_SEQUENCE:
11185-       common_type = PT_TYPE_MULTISET;
11186-       break;
11187-     default:
11188-       common_type = PT_TYPE_NONE;
11189-       break;
11190-     }
11191-   break;
11192-
11193- case PT_TYPE_LOGICAL:
11194-   switch (arg2_type)
11195-     {
11196-     case PT_TYPE_LOGICAL:
11197-       common_type = PT_TYPE_LOGICAL;
11198-       break;
11199-     case PT_TYPE_DOUBLE:
11200-       common_type = PT_TYPE_DOUBLE;
11201-       break;
11202-     case PT_TYPE_NUMERIC:
11203-       common_type = PT_TYPE_NUMERIC;
11204-       break;
</code></pre>
<pre><code class="language-cpp">
11290-
11291-  if (pt_is_op_hv_late_bind (op) &amp;&amp; (t1 == PT_TYPE_MAYBE || t2 == PT_TYPE_MAYBE))
11292-    {
11293-      result_type = PT_TYPE_MAYBE;
11294-    }
11295-  else
11296-    {
11297-      result_type = pt_common_type (t1, t2);
11298-    }
11299-
11300-  switch (op)
11301-    {
11302-    case PT_DIVIDE:
11303-      if (oracle_compat_number &amp;&amp; PT_IS_DISCRETE_NUMBER_TYPE (t1) &amp;&amp; PT_IS_DISCRETE_NUMBER_TYPE (t2))
11304- {
11305-   result_type = PT_TYPE_NUMERIC;
11306- }
11307-      break;
11308-    case PT_MINUS:
11309-    case PT_TIMES:
11310:      if (result_type == PT_TYPE_SEQUENCE)
11311- {
11312-   result_type = PT_TYPE_MULTISET;
11313- }
11314-      else if ((PT_IS_STRING_TYPE (t1) &amp;&amp; PT_IS_NUMERIC_TYPE (t2))
11315-        || (PT_IS_NUMERIC_TYPE (t1) &amp;&amp; PT_IS_STRING_TYPE (t2)))
11316- {
11317-   /* + and - have their own way of handling this situation */
11318-   return PT_TYPE_NONE;
11319- }
11320-      break;
11321-    case PT_SUPERSET:
11322-    case PT_SUPERSETEQ:
11323-    case PT_SUBSET:
11324-    case PT_SUBSETEQ:
11325:      if (result_type == PT_TYPE_SEQUENCE)
11326- {
11327-   result_type = PT_TYPE_NONE;
11328- }
11329-      break;
11330-    case PT_IFNULL:
11331-      if (result_type == PT_TYPE_MAYBE)
11332- {
11333-   result_type = PT_TYPE_VARCHAR;
11334- }
11335-      break;
11336-    case PT_COALESCE:
11337-      if (t1 == PT_TYPE_MAYBE)
11338- {
11339-   if (t2 == PT_TYPE_MAYBE || t2 == PT_TYPE_NULL)
11340-     {
11341-       result_type = PT_TYPE_MAYBE;
11342-     }
11343-   else
11344-     {
11345-       result_type = t2;
</code></pre>
<pre><code class="language-cpp">
13861-       rTyp = PT_TYPE_DOUBLE;
13862-     }
13863-   typ = pt_type_enum_to_db (rTyp);
13864-   domain = tp_domain_resolve_default (typ);
13865- }
13866-
13867-      if (typ1 == DB_TYPE_NULL || typ2 == DB_TYPE_NULL)
13868- {
13869-   bool check_empty_string;
13870-
13871-   check_empty_string = ((prm_get_bool_value (PRM_ID_ORACLE_STYLE_EMPTY_STRING)) ? true : false);
13872-   if (!check_empty_string || op != PT_PLUS || !PT_IS_STRING_TYPE (rTyp))
13873-     {
13874-       db_make_null (result); /* NULL arith_op any = NULL */
13875-       break;
13876-     }
13877- }
13878-
13879-      /* screen out cases we don't evaluate */
13880-      if (!PT_IS_NUMERIC_TYPE (rTyp) &amp;&amp; !PT_IS_STRING_TYPE (rTyp) &amp;&amp; rTyp != PT_TYPE_SET &amp;&amp; rTyp != PT_TYPE_MULTISET
13881:   &amp;&amp; rTyp != PT_TYPE_SEQUENCE &amp;&amp; !PT_IS_DATE_TIME_TYPE (rTyp))
13882- {
13883-   return 0;
13884- }
13885-
13886-      /* don't coerce dates and times */
13887-      if (!TP_IS_DATE_OR_TIME_TYPE (typ)
13888-   &amp;&amp; !((typ == DB_TYPE_INTEGER || typ == DB_TYPE_BIGINT) &amp;&amp; (TP_IS_DATE_OR_TIME_TYPE (typ1) &amp;&amp; typ1 == typ2)))
13889- {
13890-   /* coerce operands to data type of result */
13891-   if (typ1 != typ)
13892-     {
13893-       db_make_null (&amp;tmp_val);
13894-       /* force explicit cast ; scenario : INSERT INTO t VALUE(''1''+?) , USING 10, column is INTEGER */
13895-       if (tp_value_cast (arg1, &amp;tmp_val, domain, false) != DOMAIN_COMPATIBLE)
13896-  {
13897-    PT_ERRORmf2 (parser, o1, MSGCAT_SET_PARSER_SEMANTIC, MSGCAT_SEMANTIC_CANT_COERCE_TO,
13898-          parser_print_tree (parser, o1), pt_show_type_enum (rTyp));
13899-
13900-    return 0;
13901-  }
</code></pre>
<pre><code class="language-cpp">
18948-     e.g.) (col1,1) in (..) and col1=1 -&gt; qo_reduce_equality_terms() -&gt; function type (1,1) -&gt; value type (1,1) */
18949-  if (pt_is_set_type (func) &amp;&amp; func-&gt;info.function.function_type == F_SEQUENCE)
18950-    {
18951-      PT_NODE *func_arg = func-&gt;info.function.arg_list;
18952-      bool is_const_multi_col = true;
18953-
18954-      for ( /* none */ ; func_arg; func_arg = func_arg-&gt;next)
18955- {
18956-   if (func_arg &amp;&amp; func_arg-&gt;node_type != PT_VALUE)
18957-     {
18958-       is_const_multi_col = false;
18959-       break;
18960-     }
18961- }
18962-      if (is_const_multi_col)
18963- {
18964-   func-&gt;node_type = PT_VALUE;
18965-   func_arg = func-&gt;info.function.arg_list;
18966-   memset (&amp;(func-&gt;info), 0, sizeof (func-&gt;info));
18967-   func-&gt;info.value.data_value.set = func_arg;
18968:   func-&gt;type_enum = PT_TYPE_SEQUENCE;
18969- }
18970-    }
18971-
18972-  if (func-&gt;flag.do_not_fold)
18973-    {
18974-      return func;
18975-    }
18976-
18977-  if (func-&gt;info.function.function_type == PT_COUNT)
18978-    {
18979-      parser_node *arg_list = func-&gt;info.function.arg_list;
18980-      /* do special constant folding; COUNT(1), COUNT(?), COUNT(:x), ... -&gt; COUNT(*) */
18981-      if (pt_is_const (arg_list) &amp;&amp; !PT_IS_NULL_NODE (arg_list))
18982- {
18983-   PT_MISC_TYPE all_or_distinct;
18984-   all_or_distinct = func-&gt;info.function.all_or_distinct;
18985-   if (func-&gt;info.function.function_type == PT_COUNT &amp;&amp; all_or_distinct != PT_DISTINCT)
18986-     {
18987-       func-&gt;info.function.function_type = PT_COUNT_STAR;
18988-       parser_free_tree (parser, arg_list);
</code></pre>
<pre><code class="language-cpp">
19599-  temp-&gt;info.value.db_value_is_in_workspace = 0;
19600-  parser_free_node (parser, temp);
19601-       }
19602-   }
19603-      }
19604-      break;
19605-
19606-    case PT_FUNCTION:
19607-      if (src == dest)
19608- {
19609-   switch (src-&gt;info.function.function_type)
19610-     {
19611-     case F_MULTISET:
19612-     case F_SEQUENCE:
19613-       switch (desired_type)
19614-  {
19615-  case PT_TYPE_SET:
19616-    dest-&gt;info.function.function_type = F_SET;
19617-    dest-&gt;type_enum = PT_TYPE_SET;
19618-    break;
19619:  case PT_TYPE_SEQUENCE:
19620-    dest-&gt;info.function.function_type = F_SEQUENCE;
19621:    dest-&gt;type_enum = PT_TYPE_SEQUENCE;
19622-    break;
19623-  case PT_TYPE_MULTISET:
19624-    dest-&gt;info.function.function_type = F_MULTISET;
19625-    dest-&gt;type_enum = PT_TYPE_MULTISET;
19626-    break;
19627-  default:
19628-    break;
19629-  }
19630-       break;
19631-
19632-     case F_TABLE_MULTISET:
19633-     case F_TABLE_SEQUENCE:
19634-       switch (desired_type)
19635-  {
19636-  case PT_TYPE_SET:
19637-    dest-&gt;info.function.function_type = F_TABLE_SET;
19638-    dest-&gt;type_enum = PT_TYPE_SET;
19639-    break;
19640:  case PT_TYPE_SEQUENCE:
19641-    dest-&gt;info.function.function_type = F_TABLE_SEQUENCE;
19642:    dest-&gt;type_enum = PT_TYPE_SEQUENCE;
19643-    break;
19644-  case PT_TYPE_MULTISET:
19645-    dest-&gt;info.function.function_type = F_TABLE_MULTISET;
19646-    dest-&gt;type_enum = PT_TYPE_MULTISET;
19647-    break;
19648-  default:
19649-    break;
19650-  }
19651-       break;
19652-
19653-     default:
19654-       break;
19655-     }
19656- }
19657-      break;
19658-
19659-    default:
19660-      err = ((pt_common_type (desired_type, src-&gt;type_enum) == PT_TYPE_NONE) ? ER_IT_INCOMPATIBLE_DATATYPE : NO_ERROR);


</code></pre>
<pre><code class="language-cpp">19661-      break;
19662-    }
</code></pre>
<pre><code class="language-cpp">
19787-pt_compare_bounds_to_value (PARSER_CONTEXT * parser, PT_NODE * expr, PT_OP_TYPE op, PT_TYPE_ENUM lhs_type,
19788-       DB_VALUE * rhs_val, PT_TYPE_ENUM rhs_type)
19789-{
19790-  bool lhs_less = false;
19791-  bool lhs_greater = false;
19792-  bool always_false = false;
19793-  bool always_false_due_to_null = false;
19794-  bool always_true = false;
19795-  PT_NODE *result = expr;
19796-  double dtmp;
19797-
19798-  /* we can't determine anything if the types are the same */
19799-  if (lhs_type == rhs_type)
19800-    {
19801-      return result;
19802-    }
19803-
19804-  /* check if op is always false due to null */
19805-  if (op != PT_IS_NULL &amp;&amp; op != PT_IS_NOT_NULL)
19806-    {
19807:      if (DB_IS_NULL (rhs_val) &amp;&amp; rhs_type != PT_TYPE_SET &amp;&amp; rhs_type != PT_TYPE_SEQUENCE
19808-   &amp;&amp; rhs_type != PT_TYPE_MULTISET)
19809- {
19810-   always_false_due_to_null = true;
19811-   goto end;
19812- }
19813-    }
19814-
19815-  /* we only allow PT_EQ, PT_GT, PT_GE, PT_LT, PT_LE. */
19816-  if (op != PT_EQ &amp;&amp; op != PT_GT &amp;&amp; op != PT_GE &amp;&amp; op != PT_LT &amp;&amp; op != PT_LE)
19817-    {
19818-      return result;
19819-    }
19820-
19821-  /* we need to extend the following to compare dates and times, but probably not until we make the ranges of PT_* and
19822-   * DB_* the same */
19823-  switch (lhs_type)
19824-    {
19825-    case PT_TYPE_SMALLINT:
19826-      switch (rhs_type)
19827- {


</code></pre>
<pre><code class="language-cpp">parse_tree_cl.c
4121-    case PT_TYPE_MONETARY:
4122-      return "monetary";
4123-    case PT_TYPE_JSON:
4124-      return "json";
4125-    case PT_TYPE_MAYBE:
4126-      return "uncertain";
4127-
4128-    case PT_TYPE_NA:
4129-      return "na";
4130-    case PT_TYPE_NULL:
4131-      return "null";
4132-    case PT_TYPE_STAR:
4133-      return "*";
4134-
4135-    case PT_TYPE_OBJECT:
4136-      return "object";
4137-    case PT_TYPE_SET:
4138-      return "set";
4139-    case PT_TYPE_MULTISET:
4140-      return "multiset";
4141:    case PT_TYPE_SEQUENCE:
4142-      return "sequence";
4143-    case PT_TYPE_RESULTSET:
4144-      return "cursor";
4145-    case PT_TYPE_COMPOUND:
4146-      return "unknown";
4147-
4148-    case PT_TYPE_BLOB:
4149-      return "blob";
4150-    case PT_TYPE_CLOB:
4151-      return "clob";
4152-    case PT_TYPE_ELO:
4153-      return "*elo*";
4154-
4155-    case PT_TYPE_ENUMERATION:
4156-      return "enum";
4157-
4158-    case PT_TYPE_MAX:
4159-    default:
4160-      return "unknown";
4161-    }
</code></pre>
<pre><code class="language-cpp">
4579-  }
4580-
4581-       node-&gt;info.query.q.select.list = parser_copy_tree_list (parser, spec-&gt;info.spec.as_attr_list);
4582-       node-&gt;info.query.q.select.from = spec;
4583-     }
4584-   else
4585-     {
4586-       /* remove unnecessary ORDER BY clause */
4587-       if (node-&gt;info.query.order_by &amp;&amp; !node-&gt;info.query.q.select.connect_by)
4588-  {
4589-    parser_free_tree (parser, node-&gt;info.query.order_by);
4590-    node-&gt;info.query.order_by = NULL;
4591-  }
4592-     }
4593-
4594-   /* create parentheses expr set value */
4595-   val = parser_new_node (parser, PT_VALUE);
4596-   if (val)
4597-     {
4598-       val-&gt;info.value.data_value.set = node-&gt;info.query.q.select.list;
4599:       val-&gt;type_enum = PT_TYPE_SEQUENCE;
4600-     }
4601-   node-&gt;info.query.q.select.list = val;
4602- }
4603-      else
4604- {
4605-   if (pt_length_of_select_list (list, EXCLUDE_HIDDEN_COLUMNS) == 1 &amp;&amp; pt_is_set_type (list))
4606-     {   /* one column */
4607-       col = list;
4608-       next = list-&gt;next; /* save hidden column */
4609-       col-&gt;next = NULL;
4610-
4611-       if (list-&gt;node_type == PT_VALUE)
4612-  {
4613-    list = col-&gt;info.value.data_value.set;
4614-    col-&gt;info.value.data_value.set = NULL;
4615-    parser_free_tree (parser, col);
4616-  }
4617-       else if (list-&gt;node_type == PT_FUNCTION)
4618-  {
4619-    list = col-&gt;info.function.arg_list;
</code></pre>
<pre><code class="language-cpp">
8606-   {
8607-     sprintf (buf, "(%d)", precision);
8608-     q = pt_append_nulstring (parser, q, buf);
8609-   }
8610-      }
8611-      break;
8612-    case PT_TYPE_DOUBLE:
8613-      q = pt_append_nulstring (parser, q, pt_show_type_enum (p-&gt;type_enum));
8614-      break;
8615-    case PT_TYPE_ENUMERATION:
8616-      q = pt_append_nulstring (parser, q, pt_show_type_enum (p-&gt;type_enum));
8617-      q = pt_append_nulstring (parser, q, "(");
8618-      r1 = pt_print_bytes_l (parser, p-&gt;info.data_type.enumeration);
8619-      q = pt_append_varchar (parser, q, r1);
8620-      q = pt_append_nulstring (parser, q, ")");
8621-      show_collation = true;
8622-      break;
8623-
8624-    case PT_TYPE_SET:
8625-    case PT_TYPE_MULTISET:
8626:    case PT_TYPE_SEQUENCE:
8627-      q = pt_append_nulstring (parser, q, pt_show_type_enum (p-&gt;type_enum));
8628-
8629-      /* not to print data_type node for SET data types with empty domain */
8630-      if (p-&gt;data_type &amp;&amp; p-&gt;data_type-&gt;info.data_type.precision != TP_FLOATING_PRECISION_VALUE)
8631- {
8632-   r1 = pt_print_bytes_l (parser, p-&gt;data_type);
8633-   q = pt_append_nulstring (parser, q, "(");
8634-   q = pt_append_varchar (parser, q, r1);
8635-   q = pt_append_nulstring (parser, q, ")");
8636- }
8637-      break;
8638-
8639-    case PT_TYPE_TABLE_COLUMN:
8640-      r1 = pt_print_bytes (parser, p-&gt;info.data_type.table_column);
8641-      q = pt_append_varchar (parser, q, r1);
8642-      q = pt_append_nulstring (parser, q, "%type");
8643-
8644-      break;
8645-
8646-    default:
</code></pre>
<pre><code class="language-cpp">
15980-  return b;
15981-}
15982-#endif
15983-
15984-/* VALUE */
15985-/*
15986- * pt_apply_value () -
15987- *   return:
15988- *   parser(in):
15989- *   p(in):
15990- *   g(in):
15991- *   arg(in):
15992- */
15993-static PT_NODE *
15994-pt_apply_value (PARSER_CONTEXT * parser, PT_NODE * p, void *arg)
15995-{
15996-  switch (p-&gt;type_enum)
15997-    {
15998-    case PT_TYPE_SET:
15999-    case PT_TYPE_MULTISET:
16000:    case PT_TYPE_SEQUENCE:
16001-      PT_APPLY_WALK (parser, p-&gt;info.value.data_value.set, arg);
16002-    default:
16003-      break;
16004-    }
16005-  return p;
16006-}
16007-
16008-/*
16009- * pt_init_value () -
16010- *   return:
16011- *   p(in):
16012- */
16013-static PT_NODE *
16014-pt_init_value (PT_NODE * p)
16015-{
16016-  p-&gt;info.value.host_var_index = -1;
16017-  return p;
16018-}
16019-
16020-/*
</code></pre>
<pre><code class="language-cpp">
16210-   prt_coll_id = -1;
16211- }
16212-
16213-      prt_cs = (p-&gt;data_type != NULL) ? (INTL_CODESET) (p-&gt;data_type-&gt;info.data_type.units) : LANG_SYS_CODESET;
16214-
16215-      /* do not print charset introducer for NCHAR and VARNCHAR */
16216-      if ((p-&gt;info.value.print_charset == false
16217-    &amp;&amp; !(parser-&gt;custom_print &amp; (PT_CHARSET_COLLATE_FULL | PT_CHARSET_COLLATE_USER_ONLY)))
16218-   || (p-&gt;type_enum != PT_TYPE_CHAR &amp;&amp; p-&gt;type_enum != PT_TYPE_VARCHAR)
16219-   || (prt_cs == LANG_SYS_CODESET &amp;&amp; (parser-&gt;custom_print &amp; PT_SUPPRESS_CHARSET_PRINT))
16220-   || (parser-&gt;custom_print &amp; PT_CHARSET_COLLATE_USER_ONLY &amp;&amp; p-&gt;info.value.has_cs_introducer == false))
16221- {
16222-   prt_cs = INTL_CODESET_NONE;
16223- }
16224-    }
16225-
16226-  switch (p-&gt;type_enum)
16227-    {
16228-    case PT_TYPE_SET:
16229-    case PT_TYPE_MULTISET:
16230:    case PT_TYPE_SEQUENCE:
16231-      if (p-&gt;spec_ident || ((parser-&gt;custom_print &amp; PT_PRINT_SUPPRESS_FOR_DBLINK) &amp;&amp; p-&gt;flag.print_in_value_for_dblink))
16232- {
16233-   /* this is tagged as an "in" clause right hand side Print it as a parenthesized list */
16234-   /* print_in_value_for_dblink is a flag as same meaning for dblink */
16235-   r1 = pt_print_bytes_l (parser, p-&gt;info.value.data_value.set);
16236-   q = pt_append_nulstring (parser, q, "(");
16237-   q = pt_append_varchar (parser, q, r1);
16238-   q = pt_append_nulstring (parser, q, ")");
16239- }
16240-      else
16241- {
16242:   if (p-&gt;type_enum != PT_TYPE_SEQUENCE &amp;&amp; !(parser-&gt;custom_print &amp; PT_PRINT_SUPPRESS_FOR_DBLINK))
16243-     {
16244-       q = pt_append_nulstring (parser, q, pt_show_type_enum (p-&gt;type_enum));
16245-     }
16246-   q = pt_append_nulstring (parser, q, "{");
16247-
16248-   if (p-&gt;info.value.data_value.set)
16249-     {
16250-       r1 = pt_print_bytes_l (parser, p-&gt;info.value.data_value.set);
16251-       q = pt_append_varchar (parser, q, r1);
16252-     }
16253-   q = pt_append_nulstring (parser, q, "}");
16254- }
16255-      break;
16256-
16257-    case PT_TYPE_LOGICAL:
16258-    case PT_TYPE_FLOAT:
16259-    case PT_TYPE_DOUBLE:
16260-    case PT_TYPE_NUMERIC:
16261-    case PT_TYPE_INTEGER:
16262-    case PT_TYPE_BIGINT:


</code></pre>
<pre><code class="language-cpp">parse_dbi.c
1382- *   parser(in):
1383- *   s(in): domain string
1384- *   node(out):
1385- */
1386-void
1387-pt_string_to_data_type (PARSER_CONTEXT * parser, const char *s, PT_NODE * node)
1388-{
1389-  DB_DOMAIN *dom;
1390-
1391-  dom = pt_string_to_db_domain (s, NULL);
1392-  if (dom == NULL)
1393-    {
1394-      return;
1395-    }
1396-
1397-  node-&gt;type_enum = pt_db_to_type_enum (TP_DOMAIN_TYPE (dom));
1398-  switch (node-&gt;type_enum)
1399-    {
1400-    case PT_TYPE_OBJECT:
1401-    case PT_TYPE_SET:
1402:    case PT_TYPE_SEQUENCE:
1403-    case PT_TYPE_MULTISET:
1404-    case PT_TYPE_NUMERIC:
1405-    case PT_TYPE_BIT:
1406-    case PT_TYPE_VARBIT:
1407-    case PT_TYPE_CHAR:
1408-    case PT_TYPE_VARCHAR:
1409-    case PT_TYPE_NCHAR:
1410-    case PT_TYPE_VARNCHAR:
1411-      node-&gt;data_type = pt_domain_to_data_type (parser, dom);
1412-      break;
1413-    default:
1414-      break;
1415-    }
1416-}
1417-#endif /* ENABLE_UNUSED_FUNCTION */
1418-
1419-/*
1420- * pt_type_enum_to_db_domain_name() - returns string form of t's datatype
1421- *   return:  character string denoting datatype dt
1422- *   t(in): a PT_TYPE_ENUM
</code></pre>
<pre><code class="language-cpp">
1488-      name = "monetary";
1489-      break;
1490-
1491-    case PT_TYPE_VARCHAR:
1492-      name = "char varying";
1493-      break;
1494-    case PT_TYPE_CHAR:
1495-      name = "char";
1496-      break;
1497-
1498-    case PT_TYPE_OBJECT:
1499-      name = "object";
1500-      break;
1501-
1502-    case PT_TYPE_SET:
1503-      name = "set";
1504-      break;
1505-    case PT_TYPE_MULTISET:
1506-      name = "multiset";
1507-      break;
1508:    case PT_TYPE_SEQUENCE:
1509-      name = "sequence";
1510-      break;
1511-
1512-    case PT_TYPE_NCHAR:
1513-      name = "nchar";
1514-      break;
1515-    case PT_TYPE_VARNCHAR:
1516-      name = "nchar varying";
1517-      break;
1518-    case PT_TYPE_BIT:
1519-      name = "bit";
1520-      break;
1521-    case PT_TYPE_VARBIT:
1522-      name = "bit varying";
1523-      break;
1524-
1525-    case PT_TYPE_BLOB:
1526-      name = "blob";
1527-      break;
1528-    case PT_TYPE_CLOB:
</code></pre>
<pre><code class="language-cpp">
2375-    case PT_TYPE_VARCHAR:
2376-      db_type = DB_TYPE_VARCHAR;
2377-      break;
2378-
2379-    case PT_TYPE_JSON:
2380-      db_type = DB_TYPE_JSON;
2381-      break;
2382-
2383-    case PT_TYPE_OBJECT:
2384-      db_type = DB_TYPE_OBJECT;
2385-      break;
2386-
2387-    case PT_TYPE_SET:
2388-      db_type = DB_TYPE_SET;
2389-      break;
2390-
2391-    case PT_TYPE_MULTISET:
2392-      db_type = DB_TYPE_MULTISET;
2393-      break;
2394-
2395:    case PT_TYPE_SEQUENCE:
2396-      db_type = DB_TYPE_SEQUENCE;
2397-      break;
2398-
2399-    case PT_TYPE_MIDXKEY:
2400-      db_type = DB_TYPE_MIDXKEY;
2401-      break;
2402-
2403-    case PT_TYPE_NUMERIC:
2404-      db_type = DB_TYPE_NUMERIC;
2405-      break;
2406-    case PT_TYPE_NCHAR:
2407-      db_type = DB_TYPE_NCHAR;
2408-      break;
2409-    case PT_TYPE_VARNCHAR:
2410-      db_type = DB_TYPE_VARNCHAR;
2411-      break;
2412-    case PT_TYPE_BIT:
2413-      db_type = DB_TYPE_BIT;
2414-      break;
2415-    case PT_TYPE_VARBIT:
</code></pre>
<pre><code class="language-cpp">
2649-      break;
2650-    case DB_TYPE_DATETIMELTZ:
2651-      pt_type = PT_TYPE_DATETIMELTZ;
2652-      break;
2653-
2654-    case DB_TYPE_MONETARY:
2655-      pt_type = PT_TYPE_MONETARY;
2656-      break;
2657-
2658-    case DB_TYPE_OBJECT:
2659-      pt_type = PT_TYPE_OBJECT;
2660-      break;
2661-
2662-    case DB_TYPE_SET:
2663-      pt_type = PT_TYPE_SET;
2664-      break;
2665-    case DB_TYPE_MULTISET:
2666-      pt_type = PT_TYPE_MULTISET;
2667-      break;
2668-    case DB_TYPE_SEQUENCE:
2669:      pt_type = PT_TYPE_SEQUENCE;
2670-      break;
2671-
2672-    case DB_TYPE_CHAR:
2673-      pt_type = PT_TYPE_CHAR;
2674-      break;
2675-    case DB_TYPE_STRING:
2676-      pt_type = PT_TYPE_VARCHAR;
2677-      break;
2678-    case DB_TYPE_NCHAR:
2679-      pt_type = PT_TYPE_NCHAR;
2680-      break;
2681-    case DB_TYPE_VARNCHAR:
2682-      pt_type = PT_TYPE_VARNCHAR;
2683-      break;
2684-    case DB_TYPE_BIT:
2685-      pt_type = PT_TYPE_BIT;
2686-      break;
2687-    case DB_TYPE_VARBIT:
2688-      pt_type = PT_TYPE_VARBIT;
2689-      break;
</code></pre>
<pre><code class="language-cpp">
3250-    case PT_TYPE_MULTISET:
3251-      multiset = db_set_create_multi (NULL, NULL);
3252-      if (multiset == NULL)
3253- {
3254-   PT_ERROR (parser, value,
3255-      msgcat_message (MSGCAT_CATALOG_CUBRID, MSGCAT_SET_PARSER_SEMANTIC, MSGCAT_SEMANTIC_OUT_OF_MEMORY));
3256-   return (DB_VALUE *) NULL;
3257- }
3258-
3259-      db_make_multiset (db_value, multiset);
3260-
3261-      if (pt_set_value_to_db (parser, &amp;value-&gt;info.value.data_value.set, db_value, &amp;value-&gt;data_type) == NULL)
3262- {
3263-   pr_clear_value (db_value);
3264-   return (DB_VALUE *) NULL;
3265- }
3266-
3267-      value-&gt;info.value.db_value_is_in_workspace = true;
3268-      break;
3269-
3270:    case PT_TYPE_SEQUENCE:
3271-      seq = db_seq_create (NULL, NULL, 0);
3272-      if (seq == NULL)
3273- {
3274-   PT_ERROR (parser, value,
3275-      msgcat_message (MSGCAT_CATALOG_CUBRID, MSGCAT_SET_PARSER_SEMANTIC, MSGCAT_SEMANTIC_OUT_OF_MEMORY));
3276-   return (DB_VALUE *) NULL;
3277- }
3278-
3279-      db_make_sequence (db_value, seq);
3280-
3281-      if (pt_seq_value_to_db (parser, value-&gt;info.value.data_value.set, db_value, &amp;value-&gt;data_type) == NULL)
3282- {
3283-   pr_clear_value (db_value);
3284-   return (DB_VALUE *) NULL;
3285- }
3286-
3287-      value-&gt;info.value.db_value_is_in_workspace = true;
3288-      break;
3289-
3290-    case PT_TYPE_INTEGER:


</code></pre>
<pre><code class="language-cpp">csql_grammar.y
2026-  {{ DBG_TRACE_GRAMMAR(stmt_, | DATA_TYPE___ data_type);
2027-
2028-   PT_NODE *dt, *set_dt;
2029-   PT_TYPE_ENUM typ;
2030-
2031-   typ = (PT_TYPE_ENUM) TO_NUMBER (CONTAINER_AT_0 ($2));
2032-   dt = CONTAINER_AT_1 ($2);
2033-
2034-   if (!dt)
2035-     {
2036-       dt = parser_new_node (this_parser, PT_DATA_TYPE);
2037-       if (dt)
2038-         {
2039-    dt-&gt;type_enum = typ;
2040-    dt-&gt;data_type = NULL;
2041-         }
2042-     }
2043-   else
2044-     {
2045-       if ((typ == PT_TYPE_SET) ||
2046:    (typ == PT_TYPE_MULTISET) || (typ == PT_TYPE_SEQUENCE))
2047-         {
2048-    set_dt = parser_new_node (this_parser, PT_DATA_TYPE);
2049-    if (set_dt)
2050-      {
2051-        set_dt-&gt;type_enum = typ;
2052-        set_dt-&gt;data_type = dt;
2053-        dt = set_dt;
2054-      }
2055-         }
2056-     }
2057-
2058-   if (PT_HAS_COLLATION (typ))
2059-     {
2060-       dt-&gt;info.data_type.units = LANG_SYS_CODESET;
2061-       dt-&gt;info.data_type.collation_id = LANG_SYS_COLLATION;
2062-     }
2063-
2064-   $$ = dt;
2065-   PARSER_SAVE_ERR_CONTEXT ($$, @$.buffer_pos)
2066-
</code></pre>
<pre><code class="language-cpp">
14668-
14669-   PT_NODE *node = $1;
14670-   if (node != NULL)
14671-     {
14672-       node-&gt;flag.is_alias_enabled_expr = 1;
14673-     }
14674-   $$ = node;
14675-   PARSER_SAVE_ERR_CONTEXT ($$, @$.buffer_pos)
14676-
14677-  DBG_PRINT}}
14678- ;
14679-
14680-alias_enabled_expression_
14681- : normal_expression opt_as_identifier %dprec 2
14682-  {{ DBG_TRACE_GRAMMAR(alias_enabled_expression_, : normal_expression opt_as_identifier);
14683-
14684-   PT_NODE *subq, *id;
14685-   PT_NODE *node = $1;
14686-   if (node-&gt;node_type == PT_VALUE &amp;&amp; node-&gt;type_enum == PT_TYPE_EXPR_SET)
14687-     {
14688:       node-&gt;type_enum = PT_TYPE_SEQUENCE; /* for print out */
14689-       PT_ERRORf (this_parser, node,
14690-           "check syntax at %s, illegal parentheses set expression.",
14691-           pt_short_print (this_parser, node));
14692-     }
14693-   else if (PT_IS_QUERY_NODE_TYPE (node-&gt;node_type))
14694-     {
14695-       /* mark as single tuple query */
14696-       node-&gt;info.query.flag.single_tuple = 1;
14697-
14698-       if ((subq = pt_get_subquery_list (node)) &amp;&amp; subq-&gt;next)
14699-         {
14700-    /* illegal multi-column subquery */
14701-    PT_ERRORm (this_parser, node, MSGCAT_SET_PARSER_SEMANTIC,
14702-        MSGCAT_SEMANTIC_NOT_SINGLE_COL);
14703-         }
14704-     }
14705-
14706-
14707-   id = $2;
14708-   if (id &amp;&amp; id-&gt;node_type == PT_NAME)
</code></pre>
<pre><code class="language-cpp">
17587-
17588-  DBG_PRINT}}
17589- | CAST
17590-  { push_msg(MSGCAT_SYNTAX_INVALID_CAST); }
17591-   '(' expression_ AS of_cast_data_type ')'
17592-  { pop_msg(); }
17593-  {{ DBG_TRACE_GRAMMAR(reserved_func, | CAST '(' expression_ AS of_cast_data_type ')' );
17594-
17595-   PT_NODE *expr = parser_make_expression (this_parser, PT_CAST, $4, NULL, NULL);
17596-   PT_TYPE_ENUM typ = TO_NUMBER (CONTAINER_AT_0 ($6));
17597-   PT_NODE *dt = CONTAINER_AT_1 ($6);
17598-   PT_NODE *set_dt;
17599-
17600-   if (!dt)
17601-     {
17602-       dt = parser_new_node (this_parser, PT_DATA_TYPE);
17603-       dt-&gt;type_enum = TO_NUMBER (CONTAINER_AT_0 ($6));
17604-       dt-&gt;data_type = NULL;
17605-     }
17606-   else if (typ == PT_TYPE_SET || typ == PT_TYPE_MULTISET
17607:     || typ == PT_TYPE_SEQUENCE)
17608-     {
17609-       set_dt = parser_new_node (this_parser, PT_DATA_TYPE);
17610-       set_dt-&gt;type_enum = typ;
17611-       set_dt-&gt;data_type = dt;
17612-       dt = set_dt;
17613-     }
17614-   if (dt-&gt;type_enum == PT_TYPE_ENUMERATION)
17615-     {
17616-       (void) pt_check_enum_data_type(this_parser, dt);
17617-     }
17618-
17619-   expr-&gt;info.expr.cast_type = dt;
17620-   $$ = expr;
17621-   PARSER_SAVE_ERR_CONTEXT ($$, @$.buffer_pos)
17622-
17623-  DBG_PRINT}}
17624- | CLASS '(' identifier ')'
17625-  {{ DBG_TRACE_GRAMMAR(reserved_func, | CLASS '(' identifier ')' );
17626-
17627-   $3-&gt;info.name.meta_class = PT_OID_ATTR;
</code></pre>
<pre><code class="language-cpp">
19661-   bool found_paren_set_expr = false;
19662-   int lhs_cnt, rhs_cnt = 0;
19663-   bool found_match = false;
19664-
19665-   opd2 = $3;
19666-   e = parser_make_expression (this_parser, $2, $1, NULL, NULL);
19667-
19668-   if (e &amp;&amp; !pt_has_error (this_parser))
19669-     {
19670-
19671-       e-&gt;info.expr.arg2 = opd2;
19672-       opd1 = e-&gt;info.expr.arg1;
19673-       op = e-&gt;info.expr.op;
19674-
19675-       /* convert parentheses set expr value into sequence */
19676-       if (opd1)
19677-         {
19678-    if (opd1-&gt;node_type == PT_VALUE &amp;&amp;
19679-        opd1-&gt;type_enum == PT_TYPE_EXPR_SET)
19680-      {
19681:        opd1-&gt;type_enum = PT_TYPE_SEQUENCE;
19682-        found_paren_set_expr = true;
19683-      }
19684-    else if (PT_IS_QUERY_NODE_TYPE (opd1-&gt;node_type))
19685-      {
19686-        if ((subq = pt_get_subquery_list (opd1)) &amp;&amp; subq-&gt;next == NULL)
19687-          {
19688-     /* single-column subquery */
19689-          }
19690-        else
19691-          {
19692-     if (subq)
19693-       {
19694-         /* If not PT_TYPE_STAR */
19695-         pt_select_list_to_one_col (this_parser, opd1, true);
19696-       }
19697-     found_paren_set_expr = true;
19698-          }
19699-      }
19700-         }
19701-       if (opd2)
19702-         {
19703-    if (opd2-&gt;node_type == PT_VALUE &amp;&amp;
19704-        opd2-&gt;type_enum == PT_TYPE_EXPR_SET)
19705-      {
19706:        opd2-&gt;type_enum = PT_TYPE_SEQUENCE;
19707-        found_paren_set_expr = true;
19708-      }
19709-    else if (PT_IS_QUERY_NODE_TYPE (opd2-&gt;node_type))
19710-      {
19711-        if ((subq = pt_get_subquery_list (opd2)) &amp;&amp; subq-&gt;next == NULL)
19712-          {
19713-     /* single-column subquery */
19714-          }
19715-        else
19716-          {
19717-     if (subq)
19718-       {
19719-         /* If not PT_TYPE_STAR */
19720-         pt_select_list_to_one_col (this_parser, opd2, true);
19721-       }
19722-     found_paren_set_expr = true;
19723-          }
19724-      }
19725-         }
19726-                              if (found_paren_set_expr == true)
</code></pre>
<pre><code class="language-cpp">
19863-
19864-   PT_NODE *node = parser_make_expression (this_parser, $2, $1, NULL, NULL);
19865-   PT_NODE *t = CONTAINER_AT_1 ($3);
19866-   bool is_paren = (bool)TO_NUMBER (CONTAINER_AT_0 ($3));
19867-   int lhs_cnt, rhs_cnt = 0;
19868-   PT_NODE *v, *lhs, *rhs, *subq;
19869-   bool found_match = false;
19870-   bool lhs_found_paren_set_expr = false;
19871-   bool rhs_found_paren_set_expr = false;
19872-
19873-   PARSER_SAVE_ERR_CONTEXT (node, @$.buffer_pos)
19874-   if (node)
19875-     {
19876-       lhs = node-&gt;info.expr.arg1;
19877-       /* convert lhs parentheses set expr value into
19878-        * sequence value */
19879-       if (lhs)
19880-         {
19881-    if (lhs-&gt;node_type == PT_VALUE &amp;&amp; lhs-&gt;type_enum == PT_TYPE_EXPR_SET)
19882-      {
19883:        lhs-&gt;type_enum = PT_TYPE_SEQUENCE;
19884-        lhs_found_paren_set_expr = true;
19885-      }
19886-    else if (PT_IS_QUERY_NODE_TYPE (lhs-&gt;node_type))
19887-      {
19888-        if ((subq = pt_get_subquery_list (lhs)) &amp;&amp; subq-&gt;next == NULL)
19889-          {
19890-     /* single column subquery */
19891-          }
19892-        else
19893-          {
19894-     if (subq)
19895-                                          {
19896-                                            /* If not PT_TYPE_STAR */
19897-                                            pt_select_list_to_one_col (this_parser, lhs, true);
19898-                                          }
19899-                                        lhs_found_paren_set_expr = true;
19900-          }
19901-      }
19902-         }
19903-
</code></pre>
<pre><code class="language-cpp">
19929-       if (is_paren == true)
19930-         {
19931-    rhs = rhs-&gt;info.value.data_value.set;
19932-         }
19933-       else if (rhs-&gt;node_type == PT_VALUE
19934-         &amp;&amp; !(PT_IS_COLLECTION_TYPE (rhs-&gt;type_enum)
19935-       || rhs-&gt;type_enum == PT_TYPE_EXPR_SET))
19936-         {
19937-    PT_ERRORmf2 (this_parser, rhs, MSGCAT_SET_PARSER_SYNTAX,
19938-          MSGCAT_SYNTAX_ERROR_MSG1,
19939-          pt_show_binopcode ($2),
19940-          "SELECT or '('");
19941-         }
19942-
19943-       /* for each rhs elements, convert parentheses
19944-        * set expr value into sequence value */
19945-       for (t = rhs; t; t = t-&gt;next)
19946-         {
19947-    if (t-&gt;node_type == PT_VALUE &amp;&amp; t-&gt;type_enum == PT_TYPE_EXPR_SET)
19948-      {
19949:        t-&gt;type_enum = PT_TYPE_SEQUENCE;
19950-        rhs_found_paren_set_expr = true;
19951-      }
19952-    else if (PT_IS_QUERY_NODE_TYPE (t-&gt;node_type))
19953-      {
19954-        if ((subq = pt_get_subquery_list (t)) &amp;&amp; subq-&gt;next == NULL)
19955-          {
19956-     /* single column subquery */
19957-          }
19958-        else
19959-          {
19960-                                        if (subq)
19961-                                          {
19962-                                            /* If not PT_TYPE_STAR */
19963-                                            pt_select_list_to_one_col (this_parser, t, true);
19964-                                          }
19965-     rhs_found_paren_set_expr = true;
19966-          }
19967-      }
19968-         }
19969-       if (rhs_found_paren_set_expr &amp;&amp; lhs_found_paren_set_expr)
</code></pre>
<pre><code class="language-cpp">
21026-
21027-   $$ = $1;
21028-
21029-  DBG_PRINT}}
21030- ;
21031-
21032-data_type_list
21033- : data_type_list ',' data_type
21034-  {{ DBG_TRACE_GRAMMAR(data_type_list, : data_type_list ',' data_type);
21035-
21036-   PT_NODE *dt;
21037-   PT_TYPE_ENUM e;
21038-
21039-   e = TO_NUMBER (CONTAINER_AT_0 ($3));
21040-   dt = CONTAINER_AT_1 ($3);
21041-
21042-   if (dt)
21043-     {
21044-       if (e == PT_TYPE_SET ||
21045-    e == PT_TYPE_MULTISET ||
21046:    e == PT_TYPE_SEQUENCE)
21047-         {
21048-    csql_yyerror("nested data type definition");
21049-         }
21050-     }
21051-
21052-   if (!dt)
21053-     {
21054-       dt = parser_new_node (this_parser, PT_DATA_TYPE);
21055-       if (dt)
21056-         {
21057-    dt-&gt;type_enum = e;
21058-    dt-&gt;data_type = NULL;
21059-         }
21060-     }
21061-
21062-   $$ = parser_make_link ($1, dt);
21063-   PARSER_SAVE_ERR_CONTEXT ($$, @$.buffer_pos)
21064-
21065-  DBG_PRINT}}
21066- | data_type
21067-  {{ DBG_TRACE_GRAMMAR(data_type_list, | data_type);
21068-
21069-   PT_NODE *dt;
21070-   PT_TYPE_ENUM e;
21071-
21072-   e = TO_NUMBER (CONTAINER_AT_0 ($1));
21073-   dt = CONTAINER_AT_1 ($1);
21074-
21075-   if (dt)
21076-     {
21077-       if (e == PT_TYPE_SET ||
21078-    e == PT_TYPE_MULTISET ||
21079:    e == PT_TYPE_SEQUENCE)
21080-         {
21081-    csql_yyerror("nested data type definition");
21082-         }
21083-     }
21084-
21085-   if (!dt)
21086-     {
21087-       dt = parser_new_node (this_parser, PT_DATA_TYPE);
21088-       if (dt)
21089-         {
21090-    dt-&gt;type_enum = e;
21091-    dt-&gt;data_type = NULL;
21092-         }
21093-     }
21094-
21095-   $$ = dt;
21096-   PARSER_SAVE_ERR_CONTEXT ($$, @$.buffer_pos)
21097-
21098-  DBG_PRINT}}
21099- ;
</code></pre>
<pre><code class="language-cpp">
22352-
22353-  DBG_PRINT}}
22354- ;
22355-
22356-set_type
22357- : SET_OF
22358-  {{ DBG_TRACE_GRAMMAR(set_type, : SET_OF );
22359-
22360-   $$ = PT_TYPE_SET;
22361-
22362-  DBG_PRINT}}
22363- | MULTISET_OF
22364-  {{ DBG_TRACE_GRAMMAR(set_type, | MULTISET_OF );
22365-
22366-   $$ = PT_TYPE_MULTISET;
22367-
22368-  DBG_PRINT}}
22369- | SEQUENCE_OF
22370-  {{ DBG_TRACE_GRAMMAR(set_type, | SEQUENCE_OF );
22371-
22372:   $$ = PT_TYPE_SEQUENCE;
22373-
22374-  DBG_PRINT}}
22375- | of_container opt_of
22376-  {{ DBG_TRACE_GRAMMAR(set_type, | of_container opt_of );
22377-
22378-   $$ = $1;
22379-
22380-  DBG_PRINT}}
22381- ;
22382-
22383-opt_of
22384- : /* empty */
22385- | OF
22386- ;
22387-
22388-signed_literal_
22389- : literal_
22390-  {{ DBG_TRACE_GRAMMAR(signed_literal_,  : literal_ );
22391-
22392-   $$ = $1;
</code></pre>
<pre><code class="language-cpp">
22689-  {{ DBG_TRACE_GRAMMAR(constant_set, | opt_of_container '{' '}' );
22690-
22691-   PT_NODE *node = parser_new_node (this_parser, PT_VALUE);
22692-
22693-   if (node)
22694-     {
22695-       node-&gt;info.value.data_value.set = 0;
22696-       node-&gt;type_enum = $1;
22697-     }
22698-
22699-   $$ = node;
22700-   PARSER_SAVE_ERR_CONTEXT ($$, @$.buffer_pos)
22701-
22702-  DBG_PRINT}}
22703- ;
22704-
22705-opt_of_container
22706- : /* empty */
22707-  {{ DBG_TRACE_GRAMMAR(opt_of_container, : );
22708-
22709:   $$ = PT_TYPE_SEQUENCE;
22710-
22711-  DBG_PRINT}}
22712- | of_container
22713-  {{ DBG_TRACE_GRAMMAR(opt_of_container, | of_container );
22714-
22715-   $$ = $1;
22716-
22717-  DBG_PRINT}}
22718- ;
22719-
22720-of_container
22721- : SET
22722-  {{ DBG_TRACE_GRAMMAR(of_container, : SET );
22723-
22724-   $$ = PT_TYPE_SET;
22725-
22726-  DBG_PRINT}}
22727- | MULTISET
22728-  {{ DBG_TRACE_GRAMMAR(of_container, | MULTISET );
22729-
22730-   $$ = PT_TYPE_MULTISET;
22731-
22732-  DBG_PRINT}}
22733- | SEQUENCE
22734-  {{ DBG_TRACE_GRAMMAR(of_container, | SEQUENCE );
22735-
22736:   $$ = PT_TYPE_SEQUENCE;
22737-
22738-  DBG_PRINT}}
22739- | LIST
22740-  {{ DBG_TRACE_GRAMMAR(of_container, | LIST );
22741-
22742:   $$ = PT_TYPE_SEQUENCE;
22743-
22744-  DBG_PRINT}}
22745- ;
22746-
22747-identifier_list
22748- : identifier_list ',' identifier
22749-  {{ DBG_TRACE_GRAMMAR(identifier_list, : identifier_list ',' identifier );
22750-
22751-   $$ = parser_make_link ($1, $3);
22752-   PARSER_SAVE_ERR_CONTEXT ($$, @$.buffer_pos)
22753-
22754-  DBG_PRINT}}
22755- | identifier
22756-  {{ DBG_TRACE_GRAMMAR(identifier_list, | identifier );
22757-
22758-   $$ = $1;
22759-   PARSER_SAVE_ERR_CONTEXT ($$, @$.buffer_pos)
22760-
22761-  DBG_PRINT}}
22762- ;
</code></pre>
<pre><code class="language-cpp">
28067-{
28068-  PT_NODE *val, *tmp;
28069-
28070-  if (exp &amp;&amp; exp-&gt;next == NULL)
28071-    {
28072-      if (exp-&gt;node_type == PT_EXPR)
28073- {
28074-   exp-&gt;info.expr.paren_type = 1;
28075- }
28076-      exp-&gt;flag.is_paren = 1;
28077-    }
28078-  else
28079-    {
28080-      val = parser_new_node (this_parser, PT_VALUE);
28081-      if (val)
28082- {
28083-   for (tmp = exp; tmp; tmp = tmp-&gt;next)
28084-     {
28085-       if (tmp-&gt;node_type == PT_VALUE &amp;&amp; tmp-&gt;type_enum == PT_TYPE_EXPR_SET)
28086-  {
28087:    tmp-&gt;type_enum = PT_TYPE_SEQUENCE;
28088-  }
28089-     }
28090-
28091-   val-&gt;info.value.data_value.set = exp;
28092-   val-&gt;type_enum = PT_TYPE_EXPR_SET;
28093- }
28094-      exp = val;
28095-      parser_groupby_exception = PT_EXPR;
28096-    }
28097-  return exp;
28098-}
28099-
28100-
28101-static PT_NODE *
28102-pt_check_non_logical_expr (PARSER_CONTEXT * parser, PT_NODE * node)
28103-{
28104-   if(node)
28105-     {
28106-        if (node-&gt;type_enum != PT_TYPE_LOGICAL)
28107-          {


</code></pre>
<pre><code class="language-cpp">name_resolution.c
1574-   */
1575-       }
1576-   }
1577- else
1578-   {
1579-     PT_NODE *arg_list = node-&gt;info.value.data_value.set;
1580-     /* roll back error messages for set values. this is a set function reference, which we just realized, since
1581-      * the syntax for constant sets and set functions is the same. Convert the node to a set function. */
1582-     node-&gt;node_type = PT_FUNCTION;
1583-     /* make info set up properly */
1584-     memset (&amp;(node-&gt;info), 0, sizeof (node-&gt;info));
1585-     node-&gt;info.function.arg_list = arg_list;
1586-     if (node-&gt;type_enum == PT_TYPE_SET)
1587-       {
1588-  node-&gt;info.function.function_type = F_SET;
1589-       }
1590-     else if (node-&gt;type_enum == PT_TYPE_MULTISET)
1591-       {
1592-  node-&gt;info.function.function_type = F_MULTISET;
1593-       }
1594:     else if (node-&gt;type_enum == PT_TYPE_SEQUENCE)
1595-       {
1596-  node-&gt;info.function.function_type = F_SEQUENCE;
1597-       }
1598-     else
1599-       {
1600-  node-&gt;info.function.function_type = (FUNC_CODE) 0;
1601-       }
1602-
1603-     /* now we need to type the innards of the set ... */
1604-     /* first we tag this not typed so the type will be recomputed from scratch. */
1605-     node-&gt;type_enum = PT_TYPE_NONE;
1606-     node = pt_semantic_type (parser, node, bind_arg-&gt;sc_info);
1607-   }
1608-
1609-      }
1610-      break;
1611-
1612-    case PT_EXPR:
1613-      (void) pt_instnum_compatibility (node);
1614-      pt_mark_function_index_expression (parser, node, bind_arg);
</code></pre>
<pre><code class="language-cpp">
2081-    parser_free_tree (parser, node);
2082-    node = NULL;
2083-    goto select_end;
2084-  }
2085-       /* using_index is just a name, mark as index name */
2086-       using_index-&gt;info.name.meta_class = PT_INDEX_NAME;
2087-       using_index-&gt;etc = (void *) PT_IDX_HINT_FORCE;
2088-
2089-       /* mark spec to scan for index key info */
2090-       node-&gt;info.query.q.select.from-&gt;info.spec.flag =
2091-  (PT_SPEC_FLAG) (node-&gt;info.query.q.select.from-&gt;info.spec.flag | PT_SPEC_FLAG_BTREE_NODE_INFO_SCAN);
2092-     }
2093- }
2094-
2095-      /* resolve '*' for rewritten multicolumn subquery during parsing STEP 1: remove sequence from select_list STEP 2:
2096-       * resolve '*', if exists STEP 3: restore sequence */
2097-
2098-      /* STEP 1 */
2099-      seq = NULL;
2100-      if (node-&gt;info.query.q.select.list-&gt;node_type == PT_VALUE
2101:   &amp;&amp; node-&gt;info.query.q.select.list-&gt;type_enum == PT_TYPE_SEQUENCE
2102-   &amp;&amp; pt_length_of_select_list (node-&gt;info.query.q.select.list, EXCLUDE_HIDDEN_COLUMNS) == 1)
2103- {
2104-   seq = node-&gt;info.query.q.select.list;
2105-   node-&gt;info.query.q.select.list = seq-&gt;info.value.data_value.set;
2106-   seq-&gt;info.value.data_value.set = NULL; /* cut-off link */
2107- }
2108-
2109-      /* STEP 2 */
2110-      if (node-&gt;info.query.q.select.list)
2111- {   /* resolve "*" */
2112-   if (node-&gt;info.query.q.select.list-&gt;node_type == PT_VALUE
2113-       &amp;&amp; node-&gt;info.query.q.select.list-&gt;type_enum == PT_TYPE_STAR)
2114-     {
2115-       PT_NODE *next = node-&gt;info.query.q.select.list-&gt;next;
2116-
2117-       /* To consider 'select *, xxx ...', release "*" node only. */
2118-       node-&gt;info.query.q.select.list-&gt;next = NULL;
2119-       parser_free_node (parser, node-&gt;info.query.q.select.list);
2120-
2121-       node-&gt;info.query.q.select.list = pt_resolve_star (parser, node-&gt;info.query.q.select.from, NULL);
</code></pre>
<pre><code class="language-cpp">
4155-      if (dt1-&gt;info.data_type.entity == NULL &amp;&amp; dt2-&gt;info.data_type.entity == NULL)
4156- {
4157-   return 1;
4158- }
4159-
4160-      /* Can't mix annonymous and non-annonymous (guards null pointers) */
4161-      if (dt1-&gt;info.data_type.entity == NULL || dt2-&gt;info.data_type.entity == NULL)
4162- {
4163-   return 0;
4164- }
4165-
4166-      /* class objects must be the same */
4167-      if (dt1-&gt;info.data_type.entity-&gt;info.name.db_object != dt2-&gt;info.data_type.entity-&gt;info.name.db_object)
4168- {
4169-   return 0;
4170- }
4171-      break;
4172-
4173-    case PT_TYPE_SET:
4174-    case PT_TYPE_MULTISET:
4175:    case PT_TYPE_SEQUENCE:
4176-      s = dt1;
4177-      t = dt2;
4178-
4179-      /* if sizes are different, sets can't match */
4180-      if (pt_length_of_list (s) != pt_length_of_list (t))
4181- {
4182-   return 0;
4183- }
4184-
4185-      /* element types must match */
4186-      while (s)
4187- {
4188-   v = t;
4189-   while (v)
4190-     {
4191-       if (pt_check_same_datatype (parser, s, v))
4192-  {
4193-    break; /* got match */
4194-  }
4195-       v = v-&gt;next;
</code></pre>
<pre><code class="language-cpp">
4496-      while (domain)
4497- {
4498-   db = db_domain_class (domain);
4499-   if (db)
4500-     {
4501-       /* prim_type = PT_TYPE_OBJECT, attach db_object, attach name */
4502-       entity =
4503-  pt_add_class_to_entity_list (parser, db, result-&gt;info.data_type.entity, result, (UINTPTR) result,
4504-          PT_CLASS);
4505-       if (entity == NULL)
4506-  {
4507-    return NULL;
4508-  }
4509-       result-&gt;info.data_type.entity = entity;
4510-     }
4511-   domain = (DB_DOMAIN *) db_domain_next (domain);
4512- }
4513-      break;
4514-
4515-    case PT_TYPE_SET:
4516:    case PT_TYPE_SEQUENCE:
4517-    case PT_TYPE_MULTISET:
4518-    case PT_TYPE_MIDXKEY:
4519-      /* set of what? */
4520-      dom = (DB_DOMAIN *) db_domain_set (domain);
4521-      /* make list of types in set */
4522-      while (dom)
4523- {
4524-   s = pt_domain_to_data_type (parser, dom); /* recursion here */
4525-
4526-   if (s)
4527-     {
4528-       if (result)
4529-  {
4530-    /*
4531-     * We want to make sure that the flat name list
4532-     * hanging off of the first PT_DATA_TYPE node is the
4533-     * union of all flat name lists from all nodes in
4534-     * this list; this makes certain things much easier
4535-     * later on.
4536-     * PRESERVE THE ORDER OF THESE LISTS!
</code></pre>
<pre><code class="language-cpp">
4912-
4913-PT_TYPE_ENUM pt_type[CCI_U_TYPE_LAST + 1] = {
4914-  PT_TYPE_NULL,
4915-  PT_TYPE_CHAR,
4916-  PT_TYPE_VARCHAR,
4917-  PT_TYPE_NCHAR,
4918-  PT_TYPE_VARNCHAR,
4919-  PT_TYPE_BIT,
4920-  PT_TYPE_VARBIT,
4921-  PT_TYPE_NUMERIC,
4922-  PT_TYPE_INTEGER,
4923-  PT_TYPE_SMALLINT,
4924-  PT_TYPE_MONETARY,
4925-  PT_TYPE_FLOAT,
4926-  PT_TYPE_DOUBLE,
4927-  PT_TYPE_DATE,
4928-  PT_TYPE_TIME,
4929-  PT_TYPE_TIMESTAMP,
4930-  PT_TYPE_SET,
4931-  PT_TYPE_MULTISET,
4932:  PT_TYPE_SEQUENCE,
4933-  PT_TYPE_OBJECT,
4934-  PT_TYPE_RESULTSET,
4935-  PT_TYPE_BIGINT,
4936-  PT_TYPE_DATETIME,
4937-  PT_TYPE_BLOB,
4938-  PT_TYPE_CLOB,
4939-  PT_TYPE_ENUMERATION,
4940-  PT_TYPE_SMALLINT,
4941-  PT_TYPE_INTEGER, PT_TYPE_BIGINT, PT_TYPE_TIMESTAMPTZ, PT_TYPE_TIMESTAMPLTZ, PT_TYPE_DATETIMETZ, PT_TYPE_DATETIMELTZ,
4942-  /* Disabled type */
4943-  PT_TYPE_NA,   /* CCI_U_TYPE_TIMETZ, internal only */
4944-  /* end of disabled types */
4945-  PT_TYPE_JSON
4946-};
4947-
4948-static T_CCI_U_TYPE
4949-pt_dblink_get_basic_utype (T_CCI_U_EXT_TYPE u_ext_type)
4950-{
4951-  if (CCI_IS_SET_TYPE (u_ext_type))
4952-    {
</code></pre>
<pre><code class="language-cpp">
4989-    {
4990-    case PT_TYPE_JSON:
4991-      break;
4992-
4993-    case PT_TYPE_VARCHAR:
4994-    case PT_TYPE_CHAR:
4995-    case PT_TYPE_VARNCHAR:
4996-    case PT_TYPE_NCHAR:
4997-    case PT_TYPE_BIT:
4998-    case PT_TYPE_VARBIT:
4999-    case PT_TYPE_NUMERIC:
5000-    case PT_TYPE_MONETARY:
5001-      break;
5002-
5003-    case PT_TYPE_BLOB:
5004-    case PT_TYPE_CLOB:
5005-    case PT_TYPE_OBJECT:
5006-    case PT_TYPE_ENUMERATION:
5007-    case PT_TYPE_SET:
5008-    case PT_TYPE_MULTISET:
5009:    case PT_TYPE_SEQUENCE:
5010-      PT_ERRORmf (parser, attr_def_node, MSGCAT_SET_PARSER_SEMANTIC,
5011-    MSGCAT_SEMANTIC_DBLINK_NOT_SUPPORTED_TYPE, pt_show_type_enum (attr_def_node-&gt;type_enum));
5012-      return false;
5013-
5014-    default:
5015-      need_precision = false;
5016-      break;
5017-    }
5018-
5019-  if (need_precision)
5020-    {
5021-      attr_def_node-&gt;data_type = dt = parser_new_node (parser, PT_DATA_TYPE);
5022-      if (dt == NULL)
5023- {
5024-   PT_ERROR (parser, attr_def_node, er_msg ());
5025-   return false;
5026- }
5027-
5028-      dt-&gt;type_enum = attr_def_node-&gt;type_enum;
5029-
</code></pre>
<pre><code class="language-cpp">
5519- *   att(in): a db_attribute
5520- *   attr(in/out): a PT_NAME node corresponding to att
5521- *   db(in):
5522- */
5523-static void
5524-pt_get_attr_data_type (PARSER_CONTEXT * parser, DB_ATTRIBUTE * att, PT_NODE * attr)
5525-{
5526-  DB_DOMAIN *dom;
5527-  if (!attr || !att)
5528-    {
5529-      return;
5530-    }
5531-
5532-  dom = db_attribute_domain (att);
5533-  attr-&gt;etc = dom;  /* used for getting additional db-specific domain information in the Versant driver */
5534-  attr-&gt;type_enum = pt_db_to_type_enum (TP_DOMAIN_TYPE (dom));
5535-  switch (attr-&gt;type_enum)
5536-    {
5537-    case PT_TYPE_OBJECT:
5538-    case PT_TYPE_SET:
5539:    case PT_TYPE_SEQUENCE:
5540-    case PT_TYPE_MULTISET:
5541-    case PT_TYPE_NUMERIC:
5542-    case PT_TYPE_BIT:
5543-    case PT_TYPE_VARBIT:
5544-    case PT_TYPE_CHAR:
5545-    case PT_TYPE_VARCHAR:
5546-    case PT_TYPE_NCHAR:
5547-    case PT_TYPE_VARNCHAR:
5548-    case PT_TYPE_ENUMERATION:
5549-    case PT_TYPE_JSON:
5550-      attr-&gt;data_type = pt_domain_to_data_type (parser, dom);
5551-      break;
5552-    default:
5553-      break;
5554-    }
5555-
5556-  attr-&gt;info.name.meta_class = PT_NORMAL;
5557-
5558-  /* set its shared attribute flag */
5559-  if (db_attribute_is_shared (att))
</code></pre>
<pre><code class="language-cpp">
10089-    {
10090-      node-&gt;info.method_call.method_type = PT_IS_INST_MTHD;
10091-    }
10092-
10093-  /* look up the domain of the method's return type */
10094-  if ((dom = db_method_arg_domain (method, 0)) == NULL)
10095-    {
10096-      /* only give error if it is a method expression */
10097-      if (node-&gt;info.method_call.call_or_expr != PT_IS_CALL_STMT)
10098- {
10099-   PT_ERRORmf (parser, node, MSGCAT_SET_PARSER_SEMANTIC, MSGCAT_SEMANTIC_METH_NOT_TYPED, method_name);
10100- }
10101-      return false;
10102-    }
10103-
10104-  node-&gt;type_enum = pt_db_to_type_enum (TP_DOMAIN_TYPE (dom));
10105-  switch (node-&gt;type_enum)
10106-    {
10107-    case PT_TYPE_OBJECT:
10108-    case PT_TYPE_SET:
10109:    case PT_TYPE_SEQUENCE:
10110-    case PT_TYPE_MULTISET:
10111-    case PT_TYPE_NUMERIC:
10112-    case PT_TYPE_BIT:
10113-    case PT_TYPE_VARBIT:
10114-    case PT_TYPE_CHAR:
10115-    case PT_TYPE_VARCHAR:
10116-    case PT_TYPE_NCHAR:
10117-    case PT_TYPE_VARNCHAR:
10118-      node-&gt;data_type = pt_domain_to_data_type (parser, dom);
10119-      break;
10120-    default:
10121-      break;
10122-    }
10123-
10124-  /* finally resolve method id */
10125-  node-&gt;info.method_call.method_id = (UINTPTR) node;
10126-  return true;
10127-}    /* pt_resolve_method_type */
10128-
10129-


</code></pre>
<pre><code class="language-cpp">method_transform.c
622-
623-  /* newly create additional dummy_set_tbl as derived1 for instance method and stored precdure. check for path-expr. */
624-  if (spec-&gt;info.spec.meta_class == PT_CLASS &amp;&amp; spec-&gt;info.spec.path_entities == NULL &amp;&amp; !has_hierarchical_expr)
625-    {    /* can't handle path-expr */
626-      DB_VALUE val;
627-      PT_NODE *arg, *set;
628-
629-      /* not derived-table spec and not meta class spec */
630-      db_make_int (&amp;val, true);
631-      arg = pt_dbval_to_value (parser, &amp;val);
632-
633-      set = parser_new_node (parser, PT_FUNCTION);
634-      if (set == NULL)
635- {
636-   PT_INTERNAL_ERROR (parser, "allocate new node");
637-   return NULL;
638- }
639-
640-      set-&gt;info.function.function_type = F_SEQUENCE;
641-      set-&gt;info.function.arg_list = arg;
642:      set-&gt;type_enum = PT_TYPE_SEQUENCE;
643-
644-      dummy_set_tbl = parser_new_node (parser, PT_SPEC);
645-      if (dummy_set_tbl == NULL)
646- {
647-   PT_INTERNAL_ERROR (parser, "allocate new node");
648-   return NULL;
649- }
650-
651-      dummy_set_tbl-&gt;info.spec.id = (UINTPTR) dummy_set_tbl; /* set id */
652-      dummy_set_tbl-&gt;info.spec.derived_table = set;
653-      dummy_set_tbl-&gt;info.spec.derived_table_type = PT_IS_SET_EXPR;
654-      dummy_set_tbl-&gt;info.spec.range_var = meth_make_unique_range_var (parser, dummy_set_tbl);
655-      dummy_set_tbl-&gt;info.spec.as_attr_list =
656- meth_gen_as_attr_list (parser, dummy_set_tbl-&gt;info.spec.range_var, dummy_set_tbl-&gt;info.spec.id, arg);
657-    }
658-  else
659-    {
660-      /* check for outside references for correlation level determination */
661-      info1.id = spec-&gt;info.spec.id;
662-      info1.found = 0;

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="query"><a class="header" href="#query">query</a></h1>
<pre><code class="language-cpp">execute_schema.c
7085-		case PT_TYPE_VARCHAR:
7086-		  if (p != DB_DEFAULT_PRECISION
7087-		      &amp;&amp; (p &lt; 0 || (p == 0 &amp;&amp; check_zero_precision) || p &gt; DB_MAX_VARCHAR_PRECISION))
7088-		    {
7089-		      PT_ERRORmf3 (parser, attribute, MSGCAT_SET_PARSER_SEMANTIC, MSGCAT_SEMANTIC_INV_PREC, p, 0,
7090-				   DB_MAX_VARCHAR_PRECISION);
7091-		    }
7092-		  break;
7093-
7094-		case PT_TYPE_VARNCHAR:
7095-		  if (p != DB_DEFAULT_PRECISION
7096-		      &amp;&amp; (p &lt; 0 || (p == 0 &amp;&amp; check_zero_precision) || p &gt; DB_MAX_VARNCHAR_PRECISION))
7097-		    {
7098-		      PT_ERRORmf3 (parser, attribute, MSGCAT_SET_PARSER_SEMANTIC, MSGCAT_SEMANTIC_INV_PREC, p, 0,
7099-				   DB_MAX_VARNCHAR_PRECISION);
7100-		    }
7101-		  break;
7102-
7103-		case PT_TYPE_SET:
7104-		case PT_TYPE_MULTISET:
7105:		case PT_TYPE_SEQUENCE:
7106-		  {
7107-		    PT_NODE *elem;
7108-		    for (elem = dtyp; elem != NULL; elem = elem-&gt;next)
7109-		      {
7110-			if (PT_IS_LOB_TYPE (elem-&gt;type_enum))
7111-			  {
7112-			    PT_ERRORmf2 (parser, attribute, MSGCAT_SET_PARSER_SEMANTIC,
7113-					 MSGCAT_SEMANTIC_INVALID_SET_ELEMENT, pt_show_type_enum (attribute-&gt;type_enum),
7114-					 pt_show_type_enum (elem-&gt;type_enum));
7115-			    break;
7116-			  }
7117-		      }
7118-		  }
7119-		  break;
7120-
7121-		case PT_TYPE_ENUMERATION:
7122-		  (void) pt_check_enum_data_type (parser, dtyp);
7123-		  break;
7124-
7125-		default:
</code></pre>
<pre><code class="language-cpp">
13372-    case PT_TYPE_TIME:
13373-      return empty_time;
13374-
13375-    case PT_TYPE_DATETIME:
13376-      return empty_datetime;
13377-    case PT_TYPE_DATETIMELTZ:
13378-      return empty_dt_ltz;
13379-    case PT_TYPE_DATETIMETZ:
13380-      return empty_dt_tz;
13381-
13382-    case PT_TYPE_CHAR:
13383-    case PT_TYPE_VARCHAR:
13384-      return empty_str;
13385-
13386-    case PT_TYPE_VARNCHAR:
13387-    case PT_TYPE_NCHAR:
13388-      return empty_n_str;
13389-
13390-    case PT_TYPE_SET:
13391-    case PT_TYPE_MULTISET:
13392:    case PT_TYPE_SEQUENCE:
13393-      return empty_set;
13394-
13395-    case PT_TYPE_BIT:
13396-    case PT_TYPE_VARBIT:
13397-      return empty_bit;
13398-    case PT_TYPE_LOGICAL:
13399-    case PT_TYPE_NONE:
13400-    case PT_TYPE_MAYBE:
13401-    case PT_TYPE_NA:
13402-    case PT_TYPE_NULL:
13403-    case PT_TYPE_STAR:
13404-    case PT_TYPE_OBJECT:
13405-    case PT_TYPE_MIDXKEY:
13406-    case PT_TYPE_COMPOUND:
13407-    case PT_TYPE_RESULTSET:
13408-    case PT_TYPE_BLOB:
13409-    case PT_TYPE_CLOB:
13410-    case PT_TYPE_ELO:
13411-      return NULL;
13412-    case PT_TYPE_JSON:

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="optimizer"><a class="header" href="#optimizer">optimizer</a></h1>
<pre><code class="language-cpp">query_graph.c
1164-      attr-&gt;info.name.resolved = entity-&gt;info.spec.flat_entity_list-&gt;info.name.original;
1165-      attr-&gt;info.name.original = "";
1166-      attr-&gt;info.name.spec_id = entity-&gt;info.spec.id;
1167-      attr-&gt;info.name.meta_class = PT_OID_ATTR;
1168-
1169-      /* create oid segment for the entity */
1170-      seg = qo_insert_segment (node, NULL, attr, env, NULL);
1171-      QO_SEG_SET_VALUED (seg) = false; /* oid segments aren't set valued */
1172-      QO_SEG_CLASS_ATTR (seg) = false; /* oid segments aren't class attrs */
1173-      QO_SEG_SHARED_ATTR (seg) = false; /* oid segments aren't shared attrs */
1174-    }
1175-
1176-  /*
1177-   * Create a segment for each symbol in the entities symbol table.
1178-   */
1179-  for (name = attr_list; name != NULL; name = name-&gt;next)
1180-    {
1181-      seg = qo_insert_segment (node, NULL, name, env, NULL);
1182-
1183-      if ((name-&gt;type_enum == PT_TYPE_SET) || (name-&gt;type_enum == PT_TYPE_MULTISET)
1184:   || (name-&gt;type_enum == PT_TYPE_SEQUENCE))
1185- {
1186-   QO_SEG_SET_VALUED (seg) = true;
1187- }
1188-      else
1189- {
1190-   QO_SEG_SET_VALUED (seg) = false;
1191- }
1192-
1193-      if (name-&gt;info.name.meta_class == PT_META_ATTR)
1194- {
1195-   QO_SEG_CLASS_ATTR (seg) = true;
1196- }
1197-      else
1198- {
1199-   QO_SEG_CLASS_ATTR (seg) = false;
1200- }
1201-
1202-      /* this needs to check a flag Bill is going to add--CHECK!!!!! */
1203-      QO_SEG_SHARED_ATTR (seg) = false;
1204-    }
</code></pre>
<pre><code class="language-cpp">query_rewrite.c
875- {
876-   arg = parser_copy_tree (parser, node-&gt;info.expr.arg2-&gt;info.function.arg_list);
877-   targ = node-&gt;info.expr.arg1;
878- }
879-      else if (PT_IS_OID_NAME (node-&gt;info.expr.arg2) &amp;&amp; PT_IS_FUNCTION (node-&gt;info.expr.arg1)
880-        &amp;&amp; PT_IS_CONST_INPUT_HOSTVAR (node-&gt;info.expr.arg1-&gt;info.function.arg_list))
881- {
882-   arg = parser_copy_tree (parser, node-&gt;info.expr.arg1-&gt;info.function.arg_list);
883-   targ = node-&gt;info.expr.arg2;
884- }
885-      break;
886-    default:
887-      break;
888-    }
889-
890-  /* create mset constructor subtree */
891-  if (arg &amp;&amp; (set = parser_new_node (parser, PT_FUNCTION)) != NULL)
892-    {
893-      set-&gt;info.function.function_type = F_SEQUENCE;
894-      set-&gt;info.function.arg_list = arg;
895:      set-&gt;type_enum = PT_TYPE_SEQUENCE;
896-
897-      set-&gt;data_type = parser_copy_tree_list (parser, arg-&gt;data_type);
898-    }
899-
900-  return set;
901-}
902-
903-/*
904- * qo_make_new_derived_tblspec () -
905- *   return:
906- *   parser(in): parser context
907- *   node(in): a PT_SPEC node
908- *   pred(in): node's OID_ATTR predicate
909- *   seqno(in/out): sequence number for generating unique derived table names
910- *
911- * Note:
912- *   It requires that node is the PT_SPEC node (c x) and
913- *   pred is the OID_ATTR predicate (x {=|IN} expr) from
914- *        select ... from c x, ... where ... and x {=|IN} expr
915- *   and modifies parser heap, node

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="db_type_sequence"><a class="header" href="#db_type_sequence">DB_TYPE_SEQUENCE</a></h1>
<pre><code>228
</code></pre>
<p>어디에 등장할까?</p>
<pre><code class="language-json">21 src/object/transform.c
17 src/object/class_object.c
14 src/object/set_object.c
12 src/object/object_domain.c
12 src/compat/db_set.c
12 src/base/object_representation_sr.c
10 src/storage/catalog_class.c
10 src/query/query_opfunc.c
10 src/compat/db_macro.c
8 src/parser/parse_dbi.c
8 src/object/object_primitive.c
5 src/object/object_accessor.c
5 src/compat/dbtype_function.i
5 src/broker/cas_execute.c
4 src/query/cursor.c
4 src/object/virtual_object.c
4 src/object/object_representation.c
4 src/method/query_method.cpp
4 src/method/method_struct_value.cpp
4 src/executables/unload_object.c
3 src/parser/xasl_generation.c
3 src/object/transform_cl.c
3 src/compat/cnv.c
2 src/transaction/log_manager.c
2 src/storage/system_catalog.c
2 src/storage/statistics_sr.c
2 src/sp/jsp_cl.c
2 src/query/query_executor.c
2 src/parser/type_checking.c
2 src/object/object_template.c
2 src/method/method_query_handler.cpp
2 src/executables/unload_schema.c
2 src/executables/unload_object_file.c
2 src/compat/db_value_printer.cpp
2 src/compat/dbtype_def.h
2 src/base/memory_hash.c
2 src/api/db_value_table.c
1 src/storage/heap_file.c
1 src/storage/compactdb_sr.c
1 src/query/query_dump.c
1 src/parser/parse_tree_cl.c
1 src/object/schema_template.c
1 src/object/object_printer.cpp
1 src/object/object_domain.h
1 src/object/authenticate_grant.cpp
1 src/method/method_query_util.cpp
1 src/method/method_oid_handler.cpp
1 src/method/method_invoke_group.cpp
1 src/loaddb/load_sa_loader.cpp
1 src/loaddb/load_db_value_converter.cpp
1 src/executables/esql_translate.c
1 src/executables/csql_result_format.c
1 src/executables/compactdb.c
1 src/compat/db_vdb.c
1 src/cm_common/cm_dep_tasks.c

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="srcquery-directory"><a class="header" href="#srcquery-directory"><code>src/query</code> directory</a></h1>
<pre><code class="language-cpp">cursor.c
195-    {
196-      return ER_FAILED;
197-    }
198-
199-  set = db_get_set (value_p);
200-  size = db_set_size (set);
201-
202-  if (cursor_has_set_vobjs (set) == false)
203-    {
204-      return set_convert_oids_to_objects (set);
205-    }
206-
207-  switch (type)
208-    {
209-    case DB_TYPE_SET:
210-      new_set = db_set_create_basic (NULL, NULL);
211-      break;
212-    case DB_TYPE_MULTISET:
213-      new_set = db_set_create_multi (NULL, NULL);
214-      break;
215:    case DB_TYPE_SEQUENCE:
216-      new_set = db_seq_create (NULL, NULL, size);
217-      break;
218-    default:
219-      return ER_FAILED;
220-    }
221-
222-  /* fixup element vobjs into vmops and add them to new */
223-  for (i = 0; i &lt; size; i++)
224-    {
225-      if (db_set_get (set, i, &amp;element) != NO_ERROR)
226- {
227-   db_set_free (new_set);
228-   return ER_FAILED;
229- }
230-
231-      if (cursor_fixup_vobjs (&amp;element) != NO_ERROR)
232- {
233-   db_set_free (new_set);
234-   return ER_FAILED;
235- }
236-
237:      if (type == DB_TYPE_SEQUENCE)
238- {
239-   rc = db_seq_put (new_set, i, &amp;element);
240- }
241-      else
242- {
243-   rc = db_set_add (new_set, &amp;element);
244- }
245-
246-      if (rc != NO_ERROR)
247- {
248-   db_set_free (new_set);
249-   return ER_FAILED;
250- }
251-    }
252-
253-  pr_clear_value (value_p);
254-
255-  switch (type)
256-    {
257-    case DB_TYPE_SET:
258-      db_make_set (value_p, new_set);
259-      break;
260-    case DB_TYPE_MULTISET:
261-      db_make_multiset (value_p, new_set);
262-      break;
263:    case DB_TYPE_SEQUENCE:
264-      db_make_sequence (value_p, new_set);
265-      break;
266-    default:
267-      db_set_free (new_set);
268-      return ER_FAILED;
269-    }
270-
271-  return NO_ERROR;
272-}
273-
274-/*
275- * cursor_fixup_vobjs () -
276- *   return: NO_ERROR on all ok, ER status( or ER_FAILED) otherwise
277- *   value(in/out): a db_value
278- * Note: if value is an OID then turn it into an OBJECT type value
279- *       if value is a VOBJ then turn it into a vmop
280- *       if value is a set/seq then do same fixups on its elements
281- */
282-static int
283-cursor_fixup_vobjs (DB_VALUE * value_p)
</code></pre>
<pre><code class="language-cpp">
292-      db_make_object (value_p, obj);
293-      break;
294-
295-    case DB_TYPE_VOBJ:
296-      if (DB_IS_NULL (value_p))
297- {
298-   db_value_clear (value_p);
299-   db_value_domain_init (value_p, DB_TYPE_OBJECT, DB_DEFAULT_PRECISION, DB_DEFAULT_SCALE);
300-   rc = NO_ERROR;
301- }
302-      else
303- {
304-   rc = vid_vobj_to_object (value_p, &amp;obj);
305-   pr_clear_value (value_p);
306-   db_make_object (value_p, obj);
307- }
308-      break;
309-
310-    case DB_TYPE_SET:
311-    case DB_TYPE_MULTISET:
312:    case DB_TYPE_SEQUENCE:
313-      /* fixup any set/seq of vobjs into a set/seq of vmops */
314-      rc = cursor_fixup_set_vobjs (value_p);
315-      value_p-&gt;need_clear = true;
316-      break;
317-
318-    default:
319-      rc = NO_ERROR;
320-      break;
321-    }
322-
323-  return rc;
324-}
325-
326-/*
327- * cursor_copy_vobj_to_dbvalue - The given tuple set value which is in disk
328- *   representation form is copied to the db_value structure
329- *   return: NO_ERROR on all ok, ER status( or ER_FAILED) otherwise
330- *   buf(in)            : Pointer to set disk representation
331- *   db_value(out)      : Set to the set value
332- */
</code></pre>
<pre><code class="language-cpp">query_opfunc.c
2080-  int i, card, card1;
2081-#if !defined(NDEBUG)
2082-  DB_TYPE type1, type2;
2083-#endif
2084-
2085-#if !defined(NDEBUG)
2086-  type1 = DB_VALUE_DOMAIN_TYPE (seq_val_p);
2087-  type2 = DB_VALUE_DOMAIN_TYPE (dbval_p);
2088-
2089-  assert (TP_IS_SET_TYPE (type1));
2090-  assert (TP_IS_SET_TYPE (type2));
2091-#endif
2092-
2093-  if (domain_p == NULL)
2094-    {
2095-      return ER_FAILED;
2096-    }
2097-
2098-  db_make_null (&amp;dbval_tmp);
2099-
2100:  if (TP_DOMAIN_TYPE (domain_p) == DB_TYPE_SEQUENCE)
2101-    {
2102-      if (tp_value_coerce (seq_val_p, result_p, domain_p) != DOMAIN_COMPATIBLE)
2103- {
2104-   return ER_FAILED;
2105- }
2106-
2107-      seq_tmp = db_get_set (dbval_p);
2108-      card = db_seq_size (seq_tmp);
2109-      seq_tmp1 = db_get_set (result_p);
2110-      card1 = db_seq_size (seq_tmp1);
2111-
2112-      for (i = 0; i &lt; card; i++)
2113- {
2114-   if (db_seq_get (seq_tmp, i, &amp;dbval_tmp) != NO_ERROR)
2115-     {
2116-       return ER_FAILED;
2117-     }
2118-
2119-   if (db_seq_put (seq_tmp1, card1 + i, &amp;dbval_tmp) != NO_ERROR)
2120-     {
</code></pre>
<pre><code class="language-cpp">
2539-
2540-    case DB_TYPE_NUMERIC:
2541-      error = qdata_add_numeric_to_dbval (dbval1_p, dbval2_p, result_p);
2542-      break;
2543-
2544-    case DB_TYPE_MONETARY:
2545-      error = qdata_add_monetary_to_dbval (dbval1_p, dbval2_p, result_p);
2546-      break;
2547-
2548-    case DB_TYPE_CHAR:
2549-    case DB_TYPE_VARCHAR:
2550-    case DB_TYPE_NCHAR:
2551-    case DB_TYPE_VARNCHAR:
2552-    case DB_TYPE_BIT:
2553-    case DB_TYPE_VARBIT:
2554-      error = qdata_add_chars_to_dbval (dbval1_p, dbval2_p, result_p);
2555-      break;
2556-
2557-    case DB_TYPE_SET:
2558-    case DB_TYPE_MULTISET:
2559:    case DB_TYPE_SEQUENCE:
2560-      if (!TP_IS_SET_TYPE (type2))
2561- {
2562-   er_set (ER_ERROR_SEVERITY, ARG_FILE_LINE, ER_QPROC_INVALID_DATATYPE, 0);
2563-   return ER_QPROC_INVALID_DATATYPE;
2564- }
2565-      if (domain_p == NULL)
2566- {
2567-   if (type1 == type2)
2568-     {
2569-       /* partial resolve : set only basic domain; full domain will be resolved in 'fetch', based on the
2570-        * result's value */
2571-       domain_p = tp_domain_resolve_default (type1);
2572-     }
2573-   else
2574-     {
2575-       domain_p = tp_domain_resolve_default (DB_TYPE_MULTISET);
2576-     }
2577- }
2578-      error = qdata_add_sequence_to_dbval (dbval1_p, dbval2_p, result_p, domain_p);
2579-      break;
</code></pre>
<pre><code class="language-cpp">
4618-      break;
4619-
4620-    case DB_TYPE_FLOAT:
4621-      error = qdata_subtract_float_to_dbval (dbval1_p, dbval2_p, result_p);
4622-      break;
4623-
4624-    case DB_TYPE_DOUBLE:
4625-      error = qdata_subtract_double_to_dbval (dbval1_p, dbval2_p, result_p);
4626-      break;
4627-
4628-    case DB_TYPE_NUMERIC:
4629-      error = qdata_subtract_numeric_to_dbval (dbval1_p, dbval2_p, result_p);
4630-      break;
4631-
4632-    case DB_TYPE_MONETARY:
4633-      error = qdata_subtract_monetary_to_dbval (dbval1_p, dbval2_p, result_p);
4634-      break;
4635-
4636-    case DB_TYPE_SET:
4637-    case DB_TYPE_MULTISET:
4638:    case DB_TYPE_SEQUENCE:
4639-      if (!TP_IS_SET_TYPE (type2))
4640- {
4641-   er_set (ER_ERROR_SEVERITY, ARG_FILE_LINE, ER_QPROC_INVALID_DATATYPE, 0);
4642-   return ER_QPROC_INVALID_DATATYPE;
4643- }
4644-      if (domain_p == NULL)
4645- {
4646-   if (type1 == type2 &amp;&amp; type1 == DB_TYPE_SET)
4647-     {
4648-       /* partial resolve : set only basic domain; full domain will be resolved in 'fetch', based on the
4649-        * result's value */
4650-       domain_p = tp_domain_resolve_default (type1);
4651-     }
4652-   else
4653-     {
4654-       domain_p = tp_domain_resolve_default (DB_TYPE_MULTISET);
4655-     }
4656- }
4657-      error = qdata_subtract_sequence_to_dbval (dbval1_p, dbval2_p, result_p, domain_p);
4658-      break;
</code></pre>
<pre><code class="language-cpp">
5237-      break;
5238-
5239-    case DB_TYPE_FLOAT:
5240-      error = qdata_multiply_float_to_dbval (dbval1_p, dbval2_p, result_p);
5241-      break;
5242-
5243-    case DB_TYPE_DOUBLE:
5244-      error = qdata_multiply_double_to_dbval (dbval1_p, dbval2_p, result_p);
5245-      break;
5246-
5247-    case DB_TYPE_NUMERIC:
5248-      error = qdata_multiply_numeric_to_dbval (dbval1_p, dbval2_p, result_p);
5249-      break;
5250-
5251-    case DB_TYPE_MONETARY:
5252-      error = qdata_multiply_monetary_to_dbval (dbval1_p, dbval2_p, result_p);
5253-      break;
5254-
5255-    case DB_TYPE_SET:
5256-    case DB_TYPE_MULTISET:
5257:    case DB_TYPE_SEQUENCE:
5258-      if (!TP_IS_SET_TYPE (type2))
5259- {
5260-   er_set (ER_ERROR_SEVERITY, ARG_FILE_LINE, ER_QPROC_INVALID_DATATYPE, 0);
5261-   return ER_QPROC_INVALID_DATATYPE;
5262- }
5263-      if (domain_p == NULL)
5264- {
5265-   if (type1 == type2 &amp;&amp; type1 == DB_TYPE_SET)
5266-     {
5267-       /* partial resolve : set only basic domain; full domain will be resolved in 'fetch', based on the
5268-        * result's value */
5269-       domain_p = tp_domain_resolve_default (type1);
5270-     }
5271-   else
5272-     {
5273-       domain_p = tp_domain_resolve_default (DB_TYPE_MULTISET);
5274-     }
5275- }
5276-      error = qdata_multiply_sequence_to_dbval (dbval1_p, dbval2_p, result_p, domain_p);
5277-      break;
</code></pre>
<pre><code class="language-cpp">
5859-      break;
5860-
5861-    case DB_TYPE_FLOAT:
5862-      error = qdata_divide_float_to_dbval (dbval1_p, dbval2_p, result_p);
5863-      break;
5864-
5865-    case DB_TYPE_DOUBLE:
5866-      error = qdata_divide_double_to_dbval (dbval1_p, dbval2_p, result_p);
5867-      break;
5868-
5869-    case DB_TYPE_NUMERIC:
5870-      error = qdata_divide_numeric_to_dbval (dbval1_p, dbval2_p, result_p);
5871-      break;
5872-
5873-    case DB_TYPE_MONETARY:
5874-      error = qdata_divide_monetary_to_dbval (dbval1_p, dbval2_p, result_p);
5875-      break;
5876-
5877-    case DB_TYPE_SET:
5878-    case DB_TYPE_MULTISET:
5879:    case DB_TYPE_SEQUENCE:
5880-    case DB_TYPE_TIME:
5881-    case DB_TYPE_TIMESTAMP:
5882-    case DB_TYPE_TIMESTAMPLTZ:
5883-    case DB_TYPE_TIMESTAMPTZ:
5884-    case DB_TYPE_DATETIME:
5885-    case DB_TYPE_DATETIMELTZ:
5886-    case DB_TYPE_DATETIMETZ:
5887-    case DB_TYPE_DATE:
5888-    case DB_TYPE_STRING:
5889-    default:
5890-      if (prm_get_bool_value (PRM_ID_RETURN_NULL_ON_FUNCTION_ERRORS) == false)
5891- {
5892-   er_set (ER_ERROR_SEVERITY, ARG_FILE_LINE, ER_QPROC_INVALID_DATATYPE, 0);
5893-   return ER_QPROC_INVALID_DATATYPE;
5894- }
5895-    }
5896-
5897-  if (error != NO_ERROR)
5898-    {
5899-      return error;
</code></pre>
<pre><code class="language-cpp">
6150-
6151-    case DB_TYPE_MONETARY:
6152-      error = qdata_add_monetary_to_dbval (dbval1_p, dbval2_p, result_p);
6153-      break;
6154-
6155-    case DB_TYPE_NULL:
6156-    case DB_TYPE_CHAR:
6157-    case DB_TYPE_VARCHAR:
6158-    case DB_TYPE_NCHAR:
6159-    case DB_TYPE_VARNCHAR:
6160-    case DB_TYPE_BIT:
6161-    case DB_TYPE_VARBIT:
6162-      if (dbval1_p != NULL &amp;&amp; dbval2_p != NULL)
6163- {
6164-   error = qdata_add_chars_to_dbval (dbval1_p, dbval2_p, result_p);
6165- }
6166-      break;
6167-
6168-    case DB_TYPE_SET:
6169-    case DB_TYPE_MULTISET:
6170:    case DB_TYPE_SEQUENCE:
6171-      if (!TP_IS_SET_TYPE (type2))
6172- {
6173-   er_set (ER_ERROR_SEVERITY, ARG_FILE_LINE, ER_QPROC_INVALID_DATATYPE, 0);
6174-   return ER_QPROC_INVALID_DATATYPE;
6175- }
6176-      error = qdata_add_sequence_to_dbval (dbval1_p, dbval2_p, result_p, domain_p);
6177-      break;
6178-
6179-    case DB_TYPE_TIME:
6180-      error = qdata_add_time_to_dbval (dbval1_p, dbval2_p, result_p);
6181-      break;
6182-
6183-    case DB_TYPE_TIMESTAMP:
6184-    case DB_TYPE_TIMESTAMPLTZ:
6185-      error = qdata_add_utime_to_dbval (dbval1_p, dbval2_p, result_p, domain_p);
6186-      if (error == NO_ERROR &amp;&amp; type1 == DB_TYPE_TIMESTAMPLTZ)
6187- {
6188-   db_make_timestampltz (result_p, *db_get_timestamp (result_p));
6189- }
6190-      break;
</code></pre>
<pre><code class="language-cpp">
6570-  DB_COLLECTION *collection_p = NULL;
6571-  SETOBJ *setobj_p = NULL;
6572-  int n, size;
6573-  REGU_VARIABLE_LIST regu_var_p = NULL, operand = NULL;
6574-  int error_code = NO_ERROR;
6575-  TP_DOMAIN *domain_p = NULL;
6576-
6577-  result_p = regu_func_p-&gt;value.funcp-&gt;value;
6578-  operand = regu_func_p-&gt;value.funcp-&gt;operand;
6579-  domain_p = regu_func_p-&gt;domain;
6580-  db_make_null (&amp;dbval);
6581-
6582-  if (stype == DB_TYPE_SET)
6583-    {
6584-      collection_p = db_set_create_basic (NULL, NULL);
6585-    }
6586-  else if (stype == DB_TYPE_MULTISET)
6587-    {
6588-      collection_p = db_set_create_multi (NULL, NULL);
6589-    }
6590:  else if (stype == DB_TYPE_SEQUENCE || stype == DB_TYPE_VOBJ)
6591-    {
6592-      size = 0;
6593-      for (regu_var_p = operand; regu_var_p; regu_var_p = regu_var_p-&gt;next)
6594- {
6595-   size++;
6596- }
6597-
6598-      collection_p = db_seq_create (NULL, NULL, size);
6599-    }
6600-  else
6601-    {
6602-      return ER_FAILED;
6603-    }
6604-
6605-  error_code = set_get_setobj (collection_p, &amp;setobj_p, 1);
6606-  if (error_code != NO_ERROR || !setobj_p)
6607-    {
6608-      goto error;
6609-    }
6610-
</code></pre>
<pre><code class="language-cpp">
6770-qdata_evaluate_function (THREAD_ENTRY * thread_p, regu_variable_node * function_p, val_descr * val_desc_p,
6771-    OID * obj_oid_p, QFILE_TUPLE tuple)
6772-{
6773-  FUNCTION_TYPE *funcp;
6774-
6775-  /* should sync with fetch_peek_dbval () */
6776-
6777-  funcp = function_p-&gt;value.funcp;
6778-  /* clear any value from a previous iteration */
6779-  pr_clear_value (funcp-&gt;value);
6780-
6781-  switch (funcp-&gt;ftype)
6782-    {
6783-    case F_SET:
6784-      return qdata_convert_dbvals_to_set (thread_p, DB_TYPE_SET, function_p, val_desc_p, obj_oid_p, tuple);
6785-
6786-    case F_MULTISET:
6787-      return qdata_convert_dbvals_to_set (thread_p, DB_TYPE_MULTISET, function_p, val_desc_p, obj_oid_p, tuple);
6788-
6789-    case F_SEQUENCE:
6790:      return qdata_convert_dbvals_to_set (thread_p, DB_TYPE_SEQUENCE, function_p, val_desc_p, obj_oid_p, tuple);
6791-
6792-    case F_VID:
6793-      return qdata_convert_dbvals_to_set (thread_p, DB_TYPE_VOBJ, function_p, val_desc_p, obj_oid_p, tuple);
6794-
6795-    case F_TABLE_SET:
6796-      return qdata_convert_table_to_set (thread_p, DB_TYPE_SET, function_p, val_desc_p);
6797-
6798-    case F_TABLE_MULTISET:
6799-      return qdata_convert_table_to_set (thread_p, DB_TYPE_MULTISET, function_p, val_desc_p);
6800-
6801-    case F_TABLE_SEQUENCE:
6802:      return qdata_convert_table_to_set (thread_p, DB_TYPE_SEQUENCE, function_p, val_desc_p);
6803-
6804-    case F_GENERIC:
6805-      return qdata_evaluate_generic_function (thread_p, funcp, val_desc_p, obj_oid_p, tuple);
6806-
6807-    case F_CLASS_OF:
6808-      return qdata_get_class_of_function (thread_p, funcp, val_desc_p, obj_oid_p, tuple);
6809-
6810-    case F_INSERT_SUBSTRING:
6811-      return qdata_insert_substring_function (thread_p, funcp, val_desc_p, obj_oid_p, tuple);
6812-
6813-    case F_ELT:
6814-      return qdata_elt (thread_p, funcp, val_desc_p, obj_oid_p, tuple);
6815-
6816-    case F_BENCHMARK:
6817-      return qdata_benchmark (thread_p, funcp, val_desc_p, obj_oid_p, tuple);
6818-
6819-    case F_JSON_ARRAY:
6820-      return qdata_convert_operands_to_value_and_call (thread_p, funcp, val_desc_p, obj_oid_p, tuple,
6821-             db_evaluate_json_array);
6822-
</code></pre>
<pre><code class="language-cpp">
6958-  /* execute linked query */
6959-  EXECUTE_REGU_VARIABLE_XASL (thread_p, &amp;(operand-&gt;value), val_desc_p);
6960-
6961-  if (CHECK_REGU_VARIABLE_XASL_STATUS (&amp;(operand-&gt;value)) != XASL_SUCCESS)
6962-    {
6963-      return ER_FAILED;
6964-    }
6965-
6966-  domain_p = function_p-&gt;domain;
6967-  list_id_p = operand-&gt;value.value.srlist_id-&gt;list_id;
6968-  db_make_null (&amp;dbval);
6969-
6970-  if (stype == DB_TYPE_SET)
6971-    {
6972-      collection_p = db_set_create_basic (NULL, NULL);
6973-    }
6974-  else if (stype == DB_TYPE_MULTISET)
6975-    {
6976-      collection_p = db_set_create_multi (NULL, NULL);
6977-    }
6978:  else if (stype == DB_TYPE_SEQUENCE || stype == DB_TYPE_VOBJ)
6979-    {
6980-      collection_p = db_seq_create (NULL, NULL, (list_id_p-&gt;tuple_cnt * list_id_p-&gt;type_list.type_cnt));
6981-    }
6982-  else
6983-    {
6984-      return ER_FAILED;
6985-    }
6986-
6987-  error = set_get_setobj (collection_p, &amp;setobj_p, 1);
6988-  if (error != NO_ERROR || !setobj_p)
6989-    {
6990-      set_free (collection_p);
6991-      return ER_FAILED;
6992-    }
6993-
6994-  /*
6995-   * Don't need to worry about the vobj case here; this function can't
6996-   * be called in a context where it's expected to produce a vobj.  See
6997-   * xd_dbvals_to_set for the contrasting case.
6998-   */

</code></pre>
<pre><code class="language-cpp">query_dump.c
1185-  switch (type)
1186-    {
1187-    case DB_TYPE_NULL:
1188-      return "NULL";
1189-    case DB_TYPE_INTEGER:
1190-      return "INTEGER";
1191-    case DB_TYPE_BIGINT:
1192-      return "BIGINT";
1193-    case DB_TYPE_FLOAT:
1194-      return "FLOAT";
1195-    case DB_TYPE_DOUBLE:
1196-      return "DOUBLE";
1197-    case DB_TYPE_VARCHAR:
1198-      return "VARCHAR";
1199-    case DB_TYPE_OBJECT:
1200-      return "OBJECT";
1201-    case DB_TYPE_SET:
1202-      return "SET";
1203-    case DB_TYPE_MULTISET:
1204-      return "MULTISET";
1205:    case DB_TYPE_SEQUENCE:
1206-      return "SEQUENCE";
1207-    case DB_TYPE_BLOB:
1208-      return "BLOB";
1209-    case DB_TYPE_CLOB:
1210-      return "CLOB";
1211-    case DB_TYPE_TIME:
1212-      return "TIME";
1213-    case DB_TYPE_TIMESTAMP:
1214-      return "TIMESTAMP";
1215-    case DB_TYPE_TIMESTAMPTZ:
1216-      return "TIMESTAMPTZ";
1217-    case DB_TYPE_TIMESTAMPLTZ:
1218-      return "TIMESTAMPLTZ";
1219-    case DB_TYPE_DATETIME:
1220-      return "DATETIME";
1221-    case DB_TYPE_DATETIMETZ:
1222-      return "DATETIMETZ";
1223-    case DB_TYPE_DATETIMELTZ:
1224-      return "DATETIMELTZ";
1225-    case DB_TYPE_DATE:

</code></pre>
<pre><code class="language-cpp">query_executor.c
24984-    case DB_TYPE_MONETARY:
24985-      return "MONETARY";
24986-
24987-
24988-    case DB_TYPE_VARCHAR:
24989-      return "VARCHAR";
24990-
24991-    case DB_TYPE_CHAR:
24992-      return "CHAR";
24993-
24994-    case DB_TYPE_OID:
24995-    case DB_TYPE_OBJECT:
24996-      return "OBJECT";
24997-
24998-    case DB_TYPE_SET:
24999-      return "SET";
25000-
25001-    case DB_TYPE_MULTISET:
25002-      return "MULTISET";
25003-
25004:    case DB_TYPE_SEQUENCE:
25005-      return "SEQUENCE";
25006-
25007-    case DB_TYPE_NCHAR:
25008-      return "NCHAR";
25009-
25010-    case DB_TYPE_VARNCHAR:
25011-      return "NCHAR VARYING";
25012-
25013-    case DB_TYPE_BIT:
25014-      return "BIT";
25015-
25016-    case DB_TYPE_VARBIT:
25017-      return "BIT VARYING";
25018-
25019-    case DB_TYPE_BLOB:
25020-      return "BLOB";
25021-
25022-    case DB_TYPE_CLOB:
25023-      return "CLOB";
25024-
</code></pre>
<pre><code class="language-cpp">
25067-    case DB_TYPE_VARBIT:
25068-      precision = domain-&gt;precision;
25069-      break;
25070-
25071-    case DB_TYPE_SET:
25072-      setdomain = domain-&gt;setdomain;
25073-      if (setdomain == NULL)
25074- {
25075-   return NO_ERROR;
25076- }
25077-      set_of_string = "SET OF ";
25078-      break;
25079-    case DB_TYPE_MULTISET:
25080-      setdomain = domain-&gt;setdomain;
25081-      if (setdomain == NULL)
25082- {
25083-   return NO_ERROR;
25084- }
25085-      set_of_string = "MULTISET OF ";
25086-      break;
25087:    case DB_TYPE_SEQUENCE:
25088-      setdomain = domain-&gt;setdomain;
25089-      if (setdomain == NULL)
25090- {
25091-   return NO_ERROR;
25092- }
25093-      set_of_string = "SEQUENCE OF ";
25094-      break;
25095-
25096-    case DB_TYPE_ENUMERATION:
25097-      enum_elements = domain-&gt;enumeration.elements;
25098-      enum_elements_count = domain-&gt;enumeration.count;
25099-      break;
25100-    case DB_TYPE_JSON:
25101-      validator = domain-&gt;json_validator;
25102-      break;
25103-    default:
25104-      break;
25105-    }
25106-
25107-  name = qexec_schema_get_type_name_from_id (id);

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="object-directory"><a class="header" href="#object-directory">Object Directory</a></h1>
<pre><code class="language-cpp">schema_template.c
539-
540-/* DOMAIN DECODING */
541-/*
542- * resolve_class_domain()
543- * get_domain_internal()
544- * get_domain() - Maps a domain string into a domain structure.
545- */
546-
547-static int
548-resolve_class_domain (SM_TEMPLATE * tmp, DB_DOMAIN * domain)
549-{
550-  int error = NO_ERROR;
551-  DB_DOMAIN *tmp_domain;
552-
553-  if (domain)
554-    {
555-      switch (TP_DOMAIN_TYPE (domain))
556- {
557- case DB_TYPE_SET:
558- case DB_TYPE_MULTISET:
559: case DB_TYPE_SEQUENCE:
560-   tmp_domain = domain-&gt;setdomain;
561-   while (tmp_domain)
562-     {
563-       error = resolve_class_domain (tmp, tmp_domain);
564-       if (error != NO_ERROR)
565-  {
566-    return error;
567-  }
568-       tmp_domain = tmp_domain-&gt;next;
569-     }
570-   break;
571-
572- case DB_TYPE_OBJECT:
573-   if (domain-&gt;self_ref)
574-     {
575-       domain-&gt;type = tp_Type_null;
576-       /* kludge, store the template as the "class" for this special domain */
577-       domain-&gt;class_mop = (MOP) tmp;
578-     }
579-   break;
</code></pre>
<pre><code class="language-cpp">transform_cl.c
1666-
1667-  /* store NULL for empty set */
1668-  if (list == NULL)
1669-    return ER_FAILED;
1670-
1671-  for (count = 0, l = list; l != NULL; l = l-&gt;next)
1672-    {
1673-      if (WS_IS_DELETED (l-&gt;op))
1674- {
1675-   continue;
1676- }
1677-      count++;
1678-    }
1679-
1680-  if (count == 0)
1681-    {
1682-      return NO_ERROR;
1683-    }
1684-
1685-  /* w/ domain, no bound bits, no offsets, no tags, no substructure header */
1686:  or_put_set_header (buf, DB_TYPE_SEQUENCE, count, 1, 0, 0, 0, 0);
1687-
1688-  /* use the generic "object" domain */
1689-  or_put_int (buf, OR_INT_SIZE); /* size of the domain */
1690-  or_put_domain (buf, &amp;tp_Object_domain, 0, 0); /* actual domain */
1691-
1692-  /* should be using something other than or_pack_mop here ! */
1693-  for (l = list; l != NULL; l = l-&gt;next)
1694-    {
1695-      if (WS_IS_DELETED (l-&gt;op))
1696- {
1697-   continue;
1698- }
1699-      or_pack_mop (buf, l-&gt;op);
1700-    }
1701-
1702-  return NO_ERROR;
1703-}
1704-
1705-/*
1706- * get_object_set - Extracts a sequence of objects in a disk representation



1807- */
1808-static void
1809-put_substructure_set (OR_BUF * buf, DB_LIST * list, LWRITER writer, OID * class_, int repid)
1810-{
1811-  DB_LIST *l;
1812-  char *start;
1813-  int count;
1814-  char *offset_ptr;
1815-
1816-  /* store NULL for empty list */
1817-  if (list == NULL)
1818-    {
1819-      return;
1820-    }
1821-
1822-  count = 0;
1823-  for (l = list; l != NULL; l = l-&gt;next, count++);
1824-
1825-  /* with domain, no bound bits, with offsets, no tags, common sub header */
1826-  start = buf-&gt;ptr;
1827:  or_put_set_header (buf, DB_TYPE_SEQUENCE, count, 1, 0, 1, 0, 1);
1828-
1829-  if (!count)
1830-    {
1831-      /* we must at least store the domain even though there will be no elements */
1832-      or_put_int (buf, OR_SUB_DOMAIN_SIZE);
1833-      or_put_sub_domain (buf);
1834-    }
1835-  else
1836-    {
1837-      /* begin an offset table */
1838-      offset_ptr = buf-&gt;ptr;
1839-      or_advance (buf, OR_VAR_TABLE_SIZE (count));
1840-
1841-      /* write the domain */
1842-      or_put_int (buf, OR_SUB_DOMAIN_SIZE);
1843-      or_put_sub_domain (buf);
1844-
1845-      /* write the common substructure header */
1846-      or_put_oid (buf, class_);
1847-      or_put_int (buf, repid);



3079-      if (triggers != NULL)
3080- {
3081-   att-&gt;triggers = tr_make_schema_cache (TR_CACHE_ATTRIBUTE, triggers);
3082- }
3083-      /* variable attribute 5: property list */
3084-      /* formerly disk_to_att_extension(buf, att, vars[5].length); */
3085-      att-&gt;properties = get_property_list (buf, vars[ORC_ATT_PROPERTIES_INDEX].length);
3086-
3087-      classobj_initialize_default_expr (&amp;att-&gt;default_value.default_expr);
3088-      att-&gt;on_update_default_expr = DB_DEFAULT_NONE;
3089-      if (att-&gt;properties)
3090- {
3091-   if (classobj_get_prop (att-&gt;properties, "update_default", &amp;value) &gt; 0)
3092-     {
3093-       att-&gt;on_update_default_expr = (DB_DEFAULT_EXPR_TYPE) db_get_int (&amp;value);
3094-     }
3095-
3096-   if (classobj_get_prop (att-&gt;properties, "default_expr", &amp;value) &gt; 0)
3097-     {
3098-       /* We have two cases: simple and complex expressions. */
3099:       if (DB_VALUE_TYPE (&amp;value) == DB_TYPE_SEQUENCE)
3100-  {
3101-    DB_SEQ *def_expr_seq;
3102-    DB_VALUE def_expr_op, def_expr_type, def_expr_format;
3103-    const char *def_expr_format_str;
3104-
3105-    assert (set_size (db_get_set (&amp;value)) == 3);
3106-
3107-    def_expr_seq = db_get_set (&amp;value);
3108-
3109-    /* get default expression operator (op of expr) */
3110-    if (set_get_element_nocopy (def_expr_seq, 0, &amp;def_expr_op) != NO_ERROR)
3111-      {
3112-        assert (false);
3113-      }
3114-    assert (DB_VALUE_TYPE (&amp;def_expr_op) == DB_TYPE_INTEGER
3115-     &amp;&amp; db_get_int (&amp;def_expr_op) == (int) T_TO_CHAR);
3116-    att-&gt;default_value.default_expr.default_expr_op = db_get_int (&amp;def_expr_op);
3117-
3118-    /* get default expression type (arg1 of expr) */
3119-    if (set_get_element_nocopy (def_expr_seq, 1, &amp;def_expr_type) != NO_ERROR)

</code></pre>
<pre><code class="language-cpp">object_domain.c
102-  TP_IMPLICIT_COERCION,
103-  TP_FORCE_COERCION
104-} TP_COERCION_MODE;
105-
106-/*
107- * These are arranged to get relative types for symmetrical
108- * coercion selection. The absolute position is not critical.
109- * If two types are mutually coercible, the more general
110- * should appear later. Eg. Float should appear after integer.
111- */
112-
113-static const DB_TYPE db_type_rank[] = { DB_TYPE_NULL,
114-  DB_TYPE_SHORT,
115-  DB_TYPE_INTEGER,
116-  DB_TYPE_BIGINT,
117-  DB_TYPE_NUMERIC,
118-  DB_TYPE_FLOAT,
119-  DB_TYPE_DOUBLE,
120-  DB_TYPE_MONETARY,
121-  DB_TYPE_SET,
122:  DB_TYPE_SEQUENCE,
123-  DB_TYPE_MULTISET,
124-  DB_TYPE_TIME,
125-  DB_TYPE_DATE,
126-  DB_TYPE_TIMESTAMP,
127-  DB_TYPE_TIMESTAMPLTZ,
128-  DB_TYPE_TIMESTAMPTZ,
129-  DB_TYPE_DATETIME,
130-  DB_TYPE_DATETIMELTZ,
131-  DB_TYPE_DATETIMETZ,
132-  DB_TYPE_OID,
133-  DB_TYPE_VOBJ,
134-  DB_TYPE_OBJECT,
135-  DB_TYPE_CHAR,
136-  DB_TYPE_VARCHAR,
137-  DB_TYPE_NCHAR,
138-  DB_TYPE_VARNCHAR,
139-  DB_TYPE_BIT,
140-  DB_TYPE_VARBIT,
141-  DB_TYPE_ELO,
142-  DB_TYPE_BLOB,



1596-   if (dom1-&gt;class_mop == NULL)
1597-     {
1598-       match = OID_EQ (&amp;dom1-&gt;class_oid, WS_OID (dom2-&gt;class_mop));
1599-     }
1600-   else
1601-     {
1602-       match = OID_EQ (WS_OID (dom1-&gt;class_mop), &amp;dom2-&gt;class_oid);
1603-     }
1604- }
1605-#endif /* defined (SERVER_MODE) */
1606-
1607-      if (match == 0 &amp;&amp; exact == TP_SET_MATCH &amp;&amp; dom1-&gt;class_mop == NULL &amp;&amp; OID_ISNULL (&amp;dom1-&gt;class_oid))
1608- {
1609-   match = 1;
1610- }
1611-      break;
1612-
1613-    case DB_TYPE_VARIABLE:
1614-    case DB_TYPE_SET:
1615-    case DB_TYPE_MULTISET:
1616:    case DB_TYPE_SEQUENCE:
1617-#if 1
1618-      /* &gt;&gt;&gt;&gt;&gt; NEED MORE CONSIDERATION &lt;&lt;&lt;&lt;&lt; do not check order must be rollback with tp_domain_add() */
1619-      if (dom1-&gt;setdomain == dom2-&gt;setdomain)
1620- {
1621-   match = 1;
1622- }
1623-      else
1624- {
1625-   int dsize;
1626-
1627-   /* don't bother comparing the lists unless the sizes are the same */
1628-   dsize = tp_domain_size (dom1-&gt;setdomain);
1629-   if (dsize == tp_domain_size (dom2-&gt;setdomain))
1630-     {
1631-       /* handle the simple single domain case quickly */
1632-       if (dsize == 1)
1633-  {
1634-    match = tp_domain_match (dom1-&gt;setdomain, dom2-&gt;setdomain, exact);
1635-  }
1636-       else



2030-       if (domain-&gt;is_desc == transient-&gt;is_desc)
2031-  {
2032-    match = 1;
2033-  }
2034-     }
2035-
2036-   if (match)
2037-     {
2038-       break;
2039-     }
2040-
2041-   *ins_pos = domain;
2042-   domain = domain-&gt;next_list;
2043- }
2044-#endif /* !defined (SERVER_MODE) */
2045-      break;
2046-
2047-    case DB_TYPE_VARIABLE:
2048-    case DB_TYPE_SET:
2049-    case DB_TYPE_MULTISET:
2050:    case DB_TYPE_SEQUENCE:
2051-      {
2052- int dsize2;
2053-
2054- dsize2 = tp_domain_size (transient-&gt;setdomain);
2055- while (domain)
2056-   {
2057-#if 1
2058-     /* &gt;&gt;&gt;&gt;&gt; NEED MORE CONSIDERATION &lt;&lt;&lt;&lt;&lt; do not check order must be rollback with tp_domain_add() */
2059-     if (domain-&gt;setdomain == transient-&gt;setdomain)
2060-       {
2061-  match = 1;
2062-       }
2063-     else
2064-       {
2065-  int dsize1;
2066-
2067-  /*
2068-   * don't bother comparing the lists unless the sizes are the
2069-   * same
2070-   */



2826-
2827-      if (dom-&gt;is_desc == is_desc)
2828- {
2829-   /* don't bother comparing the lists unless the sizes are the same */
2830-   dsize = tp_setdomain_size (dom);
2831-   if (dsize == src_dsize)
2832-     {
2833-       /* handle the simple single domain case quickly */
2834-       if (dsize == 1)
2835-  {
2836-    if (tp_domain_match (dom-&gt;setdomain, setdomain, TP_EXACT_MATCH))
2837-      {
2838-        break;
2839-      }
2840-  }
2841-       else
2842-  {
2843-    TP_DOMAIN *d1, *d2;
2844-    int match, i;
2845-
2846:    if (type == DB_TYPE_SEQUENCE || type == DB_TYPE_MIDXKEY)
2847-      {
2848-        if (dsize == src_dsize)
2849-   {
2850-     match = 1;
2851-     d1 = dom-&gt;setdomain;
2852-     d2 = setdomain;
2853-
2854-     for (i = 0; i &lt; dsize; i++)
2855-       {
2856-         match = tp_domain_match (d1, d2, TP_EXACT_MATCH);
2857-         if (match == 0)
2858-    {
2859-      break;
2860-    }
2861-         d1 = d1-&gt;next;
2862-         d2 = d2-&gt;next;
2863-       }
2864-     if (match == 1)
2865-       {
2866-         break;



3443-    return NULL;
3444-  }
3445-     }
3446-   else
3447-     {
3448-       domain-&gt;json_validator = NULL;
3449-     }
3450-
3451-   if (dbuf == NULL)
3452-     {
3453-       domain = tp_domain_cache (domain);
3454-     }
3455-   break;
3456-
3457-   /*
3458-    * things handled in logic outside the switch, shuts up compiler
3459-    * warnings
3460-    */
3461- case DB_TYPE_SET:
3462- case DB_TYPE_MULTISET:
3463: case DB_TYPE_SEQUENCE:
3464- case DB_TYPE_MIDXKEY:
3465-   break;
3466- case DB_TYPE_TABLE:
3467-   break;
3468- case DB_TYPE_ELO:
3469-   assert (false);
3470-   break;
3471- }
3472-    }
3473-
3474-  return domain;
3475-}
3476-
3477-#if defined(ENABLE_UNUSED_FUNCTION)
3478-/*
3479- * tp_create_domain_resolve_value - adjust domain of a DB_VALUE with respect to
3480- * the primitive value of the value
3481- *    return: domain
3482- *    val(in): DB_VALUE
3483- *    domain(in): domain



3585-     case DB_TYPE_CLOB:
3586-     case DB_TYPE_TIME:
3587-     case DB_TYPE_TIMESTAMP:
3588-     case DB_TYPE_TIMESTAMPTZ:
3589-     case DB_TYPE_TIMESTAMPLTZ:
3590-     case DB_TYPE_DATE:
3591-     case DB_TYPE_DATETIME:
3592-     case DB_TYPE_DATETIMETZ:
3593-     case DB_TYPE_DATETIMELTZ:
3594-     case DB_TYPE_MONETARY:
3595-     case DB_TYPE_SUB:
3596-     case DB_TYPE_POINTER:
3597-     case DB_TYPE_ERROR:
3598-     case DB_TYPE_SHORT:
3599-     case DB_TYPE_VOBJ:
3600-     case DB_TYPE_OID:
3601-     case DB_TYPE_NULL:
3602-     case DB_TYPE_VARIABLE:
3603-     case DB_TYPE_SET:
3604-     case DB_TYPE_MULTISET:
3605:     case DB_TYPE_SEQUENCE:
3606-     case DB_TYPE_DB_VALUE:
3607-     case DB_TYPE_VARCHAR:
3608-     case DB_TYPE_VARNCHAR:
3609-     case DB_TYPE_VARBIT:
3610-       found = d;
3611-       break;
3612-
3613-     case DB_TYPE_NUMERIC:
3614-       if ((d-&gt;precision == domain-&gt;precision) &amp;&amp; (d-&gt;scale == domain-&gt;scale))
3615-  {
3616-    found = d;
3617-  }
3618-       break;
3619-
3620-     case DB_TYPE_CHAR:
3621-     case DB_TYPE_NCHAR:
3622-     case DB_TYPE_BIT:
3623-       /*
3624-        * PR)  1.deficient character related with CHAR &amp; VARCHAR in set.
3625-        * ==&gt; distinguishing VARCHAR from CHAR.



3729-     case DB_TYPE_CLOB:
3730-     case DB_TYPE_TIME:
3731-     case DB_TYPE_TIMESTAMP:
3732-     case DB_TYPE_TIMESTAMPLTZ:
3733-     case DB_TYPE_TIMESTAMPTZ:
3734-     case DB_TYPE_DATE:
3735-     case DB_TYPE_DATETIME:

</code></pre>
<pre><code class="language-cpp">3736-     case DB_TYPE_DATETIMELTZ:
3737-     case DB_TYPE_DATETIMETZ:
3738-     case DB_TYPE_MONETARY:
3739-     case DB_TYPE_SUB:
3740-     case DB_TYPE_POINTER:
3741-     case DB_TYPE_ERROR:
3742-     case DB_TYPE_SHORT:
3743-     case DB_TYPE_VOBJ:
3744-     case DB_TYPE_OID:
3745-     case DB_TYPE_NULL:
3746-     case DB_TYPE_VARIABLE:
3747-     case DB_TYPE_SET:
3748-     case DB_TYPE_MULTISET:
3749:     case DB_TYPE_SEQUENCE:
3750-     case DB_TYPE_DB_VALUE:
3751-     case DB_TYPE_VARCHAR:
3752-     case DB_TYPE_VARNCHAR:
3753-     case DB_TYPE_VARBIT:
3754-       found = d;
3755-       break;
3756-
3757-     case DB_TYPE_NUMERIC:
3758-       if (d-&gt;precision == domain-&gt;precision &amp;&amp; d-&gt;scale == domain-&gt;scale)
3759-  {
3760-    found = d;
3761-  }
3762-       break;
3763-
3764-     case DB_TYPE_CHAR:
3765-     case DB_TYPE_NCHAR:
3766-     case DB_TYPE_BIT:
3767-       /* 1.deficient character related with CHAR &amp; VARCHAR in set. ==&gt; distinguishing VARCHAR from CHAR. 2.
3768-        * core dumped &amp; deficient character related with CONST CHAR &amp; CHAR in set. ==&gt; In case of
3769-        * CHAR,NCHAR,BIT, cosidering precision. */



9022-    * This should still be an error, and the above
9023-    * code should have constructed a virtual mop.
9024-    * I'm not sure the rest of the code is consistent
9025-    * in this regard.
9026-    */
9027-        }
9028-      else
9029-        {
9030-   status = DOMAIN_INCOMPATIBLE;
9031-        }
9032-    }
9033-       }
9034-     db_make_object (target, v_obj);
9035-   }
9036-      }
9037-      break;
9038-#endif /* !SERVER_MODE */
9039-
9040-    case DB_TYPE_SET:
9041-    case DB_TYPE_MULTISET:
9042:    case DB_TYPE_SEQUENCE:
9043-      if (!TP_IS_SET_TYPE (original_type))
9044- {
9045-   status = DOMAIN_INCOMPATIBLE;
9046- }
9047-      else
9048- {
9049-   SETREF *setref;
9050-
9051-   setref = db_get_set (src);
9052-   if (setref)
9053-     {
9054-       TP_DOMAIN *set_domain;
9055-
9056-       set_domain = setobj_domain (setref-&gt;set);
9057-       if (src == dest &amp;&amp; tp_domain_compatible (set_domain, desired_domain))
9058-  {
9059-    /*
9060-     * We know that this is a "coerce-in-place" operation, and
9061-     * we know that no coercion is necessary, so do nothing: we
9062-     * can use the exact same set without any conversion.



10458-      if (DB_IS_NULL (value2))
10459- {
10460-   result = (total_order ? DB_EQ : DB_UNK);
10461- }
10462-      else
10463- {
10464-   result = (total_order ? DB_LT : DB_UNK);
10465- }
10466-    }
10467-  else if (DB_IS_NULL (value2))
10468-    {
10469-      result = (total_order ? DB_GT : DB_UNK);
10470-    }
10471-  else
10472-    {
10473-      v1 = (DB_VALUE *) value1;
10474-      v2 = (DB_VALUE *) value2;
10475-
10476-      vtype1 = DB_VALUE_DOMAIN_TYPE (v1);
10477-      vtype2 = DB_VALUE_DOMAIN_TYPE (v2);
10478:      if (vtype1 != DB_TYPE_SET &amp;&amp; vtype1 != DB_TYPE_MULTISET &amp;&amp; vtype1 != DB_TYPE_SEQUENCE)
10479- {
10480-   return DB_NE;
10481- }
10482-
10483:      if (vtype2 != DB_TYPE_SET &amp;&amp; vtype2 != DB_TYPE_MULTISET &amp;&amp; vtype2 != DB_TYPE_SEQUENCE)
10484- {
10485-   return DB_NE;
10486- }
10487-
10488-      if (vtype1 != vtype2)
10489- {
10490-   if (!do_coercion)
10491-     {
10492-       /* types are not comparable */
10493-       return DB_NE;
10494-     }
10495-   else
10496-     {
10497-       db_make_null (&amp;temp);
10498-       coercion = 1;
10499-       if (tp_more_general_type (vtype1, vtype2) &gt; 0)
10500-  {
10501-    /* vtype1 is more general, coerce value 2 */
10502-    status = tp_value_coerce (v2, &amp;temp, tp_domain_resolve_default (vtype1));
10503-    if (status != DOMAIN_COMPATIBLE)



11301-       fprintf (fp, ")");
11302-     }
11303-   break;
11304-
11305- case DB_TYPE_VARIABLE:
11306-   fprintf (fp, "union(");
11307-   fprint_domain (fp, d-&gt;setdomain);
11308-   fprintf (fp, ")");
11309-   break;
11310-
11311- case DB_TYPE_SET:
11312-   fprintf (fp, "set(");
11313-   fprint_domain (fp, d-&gt;setdomain);
11314-   fprintf (fp, ")");
11315-   break;
11316- case DB_TYPE_MULTISET:
11317-   fprintf (fp, "multiset(");
11318-   fprint_domain (fp, d-&gt;setdomain);
11319-   fprintf (fp, ")");
11320-   break;
11321: case DB_TYPE_SEQUENCE:
11322-   fprintf (fp, "sequence(");
11323-   fprint_domain (fp, d-&gt;setdomain);
11324-   fprintf (fp, ")");
11325-   break;
11326-
11327- case DB_TYPE_BIT:
11328- case DB_TYPE_VARBIT:
11329-   fprintf (fp, "%s(%d)", d-&gt;type-&gt;name, d-&gt;precision);
11330-   break;
11331-
11332- case DB_TYPE_CHAR:
11333- case DB_TYPE_VARCHAR:
11334-   fprintf (fp, "%s(%d) collate %s", d-&gt;type-&gt;name, d-&gt;precision, lang_get_collation_name (d-&gt;collation_id));
11335-   break;
11336-
11337- case DB_TYPE_NCHAR:
11338- case DB_TYPE_VARNCHAR:
11339-   fprintf (fp, "%s(%d) NATIONAL collate %s", d-&gt;type-&gt;name, d-&gt;precision,
11340-     lang_get_collation_name (d-&gt;collation_id));
11341-   break;



11433-}
11434-
11435-
11436-/*
11437- * tp_domain_references_objects - check if domain is an object domain or a
11438- * collection domain that might include objects.
11439- *    return: int (true or false)
11440- *    dom(in): the domain to be inspected
11441- */
11442-bool
11443-tp_domain_references_objects (const TP_DOMAIN * dom)
11444-{
11445-  switch (TP_DOMAIN_TYPE (dom))
11446-    {
11447-    case DB_TYPE_OBJECT:
11448-    case DB_TYPE_OID:
11449-    case DB_TYPE_VOBJ:
11450-      return true;
11451-    case DB_TYPE_SET:
11452-    case DB_TYPE_MULTISET:
11453:    case DB_TYPE_SEQUENCE:
11454-      dom = dom-&gt;setdomain;
11455-      if (dom)
11456- {
11457-   /*
11458-    * If domains are specified, we can assume that the upper levels
11459-    * have enforced the rule that no value in the collection has a
11460-    * domain that isn't included in this list.  If this list has no
11461-    * object domain, then no collection with this domain can include
11462-    * an object reference.
11463-    */
11464-   for (; dom; dom = dom-&gt;next)
11465-     {
11466-       if (tp_domain_references_objects (dom))
11467-  {
11468-    return true;
11469-  }
11470-     }
11471-
11472-   return false;
11473- }

</code></pre>
<pre><code class="language-cpp">object_template.c
460-    {
461-      is_valid = 1;
462-    }
463-  else
464-    {
465-      /* wasn't on the first level cache, check the list */
466-      is_valid = ml_find (valid-&gt;validated_classes, class_);
467-      /* if its on the list, auto select this for the next time around */
468-      if (is_valid)
469-        {
470-   valid-&gt;last_class = class_;
471-        }
472-    }
473-       }
474-   }
475-      }
476-      break;
477-
478-    case DB_TYPE_SET:
479-    case DB_TYPE_MULTISET:
480:    case DB_TYPE_SEQUENCE:
481-      {
482- DB_SET *set;
483- DB_DOMAIN *domain;
484-
485- set = db_get_set (value);
486- domain = set_get_domain (set);
487- if (domain == valid-&gt;last_setdomain)
488-   {
489-     is_valid = 1;
490-   }
491-      }
492-      break;
493-
494-    case DB_TYPE_CHAR:
495-    case DB_TYPE_NCHAR:
496-    case DB_TYPE_VARCHAR:
497-    case DB_TYPE_VARNCHAR:
498-      if (type == valid-&gt;last_type &amp;&amp; DB_GET_STRING_PRECISION (value) == valid-&gt;last_precision)
499- {
500-   is_valid = 1;



562- if (obj != NULL)
563-   {
564-     class_ = db_get_class (obj);
565-     if (class_ != NULL)
566-       {
567-  valid-&gt;last_class = class_;
568-  /*
569-   * !! note that we have to be building an external object list
570-   * here so these serve as GC roots.  This is kludgey, we should
571-   * be encapsulating structure rules inside cl_ where the
572-   * SM_VALIDATION is allocated.
573-   */
574-  (void) ml_ext_add (&amp;valid-&gt;validated_classes, class_, NULL);
575-       }
576-   }
577-      }
578-      break;
579-
580-    case DB_TYPE_SET:
581-    case DB_TYPE_MULTISET:
582:    case DB_TYPE_SEQUENCE:
583-      {
584- DB_SET *set;
585-
586- set = db_get_set (value);
587- valid-&gt;last_setdomain = set_get_domain (set);
588-      }
589-      break;
590-
591-    case DB_TYPE_CHAR:
592-    case DB_TYPE_NCHAR:
593-    case DB_TYPE_VARCHAR:
594-    case DB_TYPE_VARNCHAR:
595-    case DB_TYPE_BIT:
596-    case DB_TYPE_VARBIT:
597-      valid-&gt;last_type = type;
598-      valid-&gt;last_precision = db_value_precision (value);
599-      valid-&gt;last_scale = 0;
600-      break;
601-
602-    case DB_TYPE_NUMERIC:

</code></pre>
<pre><code class="language-cpp">class_object.c
1389-      assert (er_errid () != NO_ERROR);
1390-      return er_errid ();
1391-    }
1392-
1393-  pk_property = db_get_set (&amp;prop_val);
1394-  err = set_get_element (pk_property, 1, &amp;pk_val);
1395-  if (err != NO_ERROR)
1396-    {
1397-      goto end;
1398-    }
1399-
1400-  pk_seq = db_get_set (&amp;pk_val);
1401-  size = set_size (pk_seq);
1402-
1403-  err = set_get_element (pk_seq, size - 3, &amp;fk_container_val);
1404-  if (err != NO_ERROR)
1405-    {
1406-      goto end;
1407-    }
1408-
1409:  if (DB_VALUE_TYPE (&amp;fk_container_val) == DB_TYPE_SEQUENCE)
1410-    {
1411-      fk_container = db_get_set (&amp;fk_container_val);
1412-      fk_container_pos = set_size (fk_container);
1413-      pk_seq_pos = size - 3;
1414-    }
1415-  else
1416-    {
1417-      fk_container = set_create_sequence (1);
1418-      if (fk_container == NULL)
1419- {
1420-   goto end;
1421- }
1422-      db_make_sequence (&amp;fk_container_val, fk_container);
1423-      fk_container_pos = 0;
1424-      pk_seq_pos = size - 2;
1425-    }
1426-
1427-  fk_seq = classobj_make_foreign_key_ref_seq (fk_info);
1428-  if (fk_seq == NULL)
1429-    {



1552-      err = (er_errid () != NO_ERROR) ? er_errid () : ER_FAILED;
1553-      return err;
1554-    }
1555-
1556-  pk_property = db_get_set (&amp;prop_val);
1557-  err = set_get_element (pk_property, 1, &amp;pk_val);
1558-  if (err != NO_ERROR)
1559-    {
1560-      goto end;
1561-    }
1562-
1563-  pk_seq = db_get_set (&amp;pk_val);
1564-  size = set_size (pk_seq);
1565-
1566-  err = set_get_element (pk_seq, size - 2, &amp;fk_container_val);
1567-  if (err != NO_ERROR)
1568-    {
1569-      goto end;
1570-    }
1571-
1572:  if (DB_VALUE_TYPE (&amp;fk_container_val) == DB_TYPE_SEQUENCE)
1573-    {
1574-      fk_container = db_get_set (&amp;fk_container_val);
1575-      fk_container_len = set_size (fk_container);
1576-      pk_seq_pos = size - 2;
1577-
1578-      /* find the position of the existing FK ref */
1579-      for (i = 0; i &lt; fk_container_len; i++)
1580- {
1581-   PRIM_SET_NULL (&amp;fk_val);
1582-   PRIM_SET_NULL (&amp;name_val);
1583-
1584-   err = set_get_element (fk_container, i, &amp;fk_val);
1585-   if (err != NO_ERROR)
1586-     {
1587-       goto end;
1588-     }
1589-
1590-   fk_seq = db_get_set (&amp;fk_val);
1591-
1592-   /* A shallow copy for btid_val is enough. So, no need pr_clear_val(&amp;btid_val). */



1720-      assert (er_errid () != NO_ERROR);
1721-      return er_errid ();
1722-    }
1723-
1724-  pk_property = db_get_set (&amp;prop_val);
1725-  err = set_get_element (pk_property, 1, &amp;pk_val);
1726-  if (err != NO_ERROR)
1727-    {
1728-      goto end;
1729-    }
1730-
1731-  pk_seq = db_get_set (&amp;pk_val);
1732-  fk_container_pos = set_size (pk_seq) - 3;
1733-
1734-  err = set_get_element (pk_seq, fk_container_pos, &amp;fk_container_val);
1735-  if (err != NO_ERROR)
1736-    {
1737-      goto end;
1738-    }
1739-
1740:  if (DB_VALUE_TYPE (&amp;fk_container_val) != DB_TYPE_SEQUENCE)
1741-    {
1742-      err = ER_SM_INVALID_PROPERTY;
1743-      er_set (ER_ERROR_SEVERITY, ARG_FILE_LINE, err, 0);
1744-      goto end;
1745-    }
1746-
1747-  fk_container = db_get_set (&amp;fk_container_val);
1748-  fk_count = set_size (fk_container);
1749-
1750-  for (i = 0; i &lt; fk_count; i++)
1751-    {
1752-      err = set_get_element (fk_container, i, &amp;fk_val);
1753-      if (err != NO_ERROR)
1754- {
1755-   goto end;
1756- }
1757-
1758-      fk_seq = db_get_set (&amp;fk_val);
1759-
1760-      err = set_get_element (fk_seq, 1, &amp;btid_val);



2453-  int error = NO_ERROR;
2454-  bool ok = true;
2455-
2456-  /* Make sure that the DB_VALUES are initialized */
2457-  db_make_null (&amp;ids_val);
2458-  db_make_null (&amp;name_val);
2459-
2460-  max = set_size (seq);
2461-  for (i = 0; i &lt; max &amp;&amp; error == NO_ERROR &amp;&amp; ok; i += 2)
2462-    {
2463-      /* Get the constraint name */
2464-      error = set_get_element (seq, i, &amp;name_val);
2465-      if (error != NO_ERROR)
2466- {
2467-   continue;
2468- }
2469-      /* get the constraint value sequence */
2470-      error = set_get_element (seq, i + 1, &amp;ids_val);
2471-      if (error == NO_ERROR)
2472- {
2473:   if (DB_VALUE_TYPE (&amp;ids_val) == DB_TYPE_SEQUENCE)
2474-     {
2475-       ids_seq = db_get_set (&amp;ids_val);
2476-       ok = classobj_cache_constraint_entry (db_get_string (&amp;name_val), ids_seq, class_, constraint_type);
2477-     }
2478-   pr_clear_value (&amp;ids_val);
2479- }
2480-      pr_clear_value (&amp;name_val);
2481-    }
2482-
2483-  if (error != NO_ERROR)
2484-    {
2485-      goto error;
2486-    }
2487-
2488-  return ok;
2489-
2490-  /* Error Processing */
2491-error:
2492-  pr_clear_value (&amp;ids_val);
2493-  pr_clear_value (&amp;name_val);



2519-    {
2520-      if (att-&gt;constraints)
2521- {
2522-   classobj_free_constraint (att-&gt;constraints);
2523-   att-&gt;constraints = NULL;
2524- }
2525-    }
2526-
2527-  /*
2528-   *  Extract the constraint property and process
2529-   */
2530-  if (class_-&gt;properties == NULL)
2531-    {
2532-      return ok;
2533-    }
2534-
2535-  for (i = 0; i &lt; num_constraint_types &amp;&amp; ok; i++)
2536-    {
2537-      if (classobj_get_prop (class_-&gt;properties, Constraint_properties[i], &amp;un_value) &gt; 0)
2538- {
2539:   if (DB_VALUE_TYPE (&amp;un_value) == DB_TYPE_SEQUENCE)
2540-     {
2541-       un_seq = db_get_set (&amp;un_value);
2542-       ok = classobj_cache_constraint_list (un_seq, class_, Constraint_types[i]);
2543-     }
2544-   pr_clear_value (&amp;un_value);
2545- }
2546-    }
2547-
2548-  return ok;
2549-}
2550-
2551-/* SM_CLASS_CONSTRAINT */
2552-/*
2553- * classobj_find_attribute_list() - Alternative to classobj_find_attribute when we're
2554- *    looking for an attribute on a particular list.
2555- *   return: attribute structure
2556- *   attlist(in): list of attributes
2557- *   name(in): name to look for
2558- *   id(in): attribute id
2559- */



3031-      goto error;
3032-    }
3033-
3034-  buffer = db_get_string (&amp;fvalue);
3035-  buffer_len = db_get_string_size (&amp;fvalue);
3036-  filter_predicate-&gt;pred_stream = (char *) db_ws_alloc (buffer_len * sizeof (char));
3037-  if (filter_predicate-&gt;pred_stream == NULL)
3038-    {
3039-      goto error;
3040-    }
3041-
3042-  memcpy (filter_predicate-&gt;pred_stream, buffer, buffer_len);
3043-  filter_predicate-&gt;pred_stream_size = buffer_len;
3044-
3045-  if (set_get_element (pred_seq, 2, &amp;avalue) != NO_ERROR)
3046-    {
3047-      er_set (ER_ERROR_SEVERITY, ARG_FILE_LINE, ER_SM_INVALID_PROPERTY, 0);
3048-      goto error;
3049-    }
3050-
3051:  if (DB_VALUE_TYPE (&amp;avalue) != DB_TYPE_SEQUENCE)
3052-    {
3053-      er_set (ER_ERROR_SEVERITY, ARG_FILE_LINE, ER_SM_INVALID_PROPERTY, 0);
3054-      goto error;
3055-    }
3056-
3057-  att_seq = db_get_set (&amp;avalue);
3058-  filter_predicate-&gt;num_attrs = att_seq_size = set_size (att_seq);
3059-  if (att_seq_size == 0)
3060-    {
3061-      filter_predicate-&gt;att_ids = NULL;
3062-    }
3063-  else
3064-    {
3065-      filter_predicate-&gt;att_ids = (int *) db_ws_alloc (sizeof (int) * att_seq_size);
3066-      if (filter_predicate-&gt;att_ids == NULL)
3067- {
3068-   goto error;
3069- }
3070-
3071-      for (i = 0; i &lt; att_seq_size; i++)



3138-
3139-  /* make sure these are initialized for the error cleanup code */
3140-  db_make_null (&amp;pvalue);
3141-  db_make_null (&amp;uvalue);
3142-  db_make_null (&amp;bvalue);
3143-  db_make_null (&amp;avalue);
3144-  db_make_null (&amp;fvalue);
3145-  db_make_null (&amp;cvalue);
3146-  db_make_null (&amp;statusval);
3147-
3148-  constraints = last = NULL;
3149-
3150-  /*
3151-   *  Process Index and Unique constraints
3152-   */
3153-  for (k = 0; k &lt; num_constraint_types; k++)
3154-    {
3155-      if (classobj_get_prop (class_props, Constraint_properties[k], &amp;pvalue) &gt; 0)
3156- {
3157-   /* get the sequence &amp; its size */
3158:   if (DB_VALUE_TYPE (&amp;pvalue) != DB_TYPE_SEQUENCE)
3159-     {
3160-       goto structure_error;
3161-     }
3162-   props = db_get_set (&amp;pvalue);
3163-   len = set_size (props);
3164-
3165-   /* this sequence is an alternating pair of constraint name &amp; info sequence, as by: { name, { BTID,
3166-    * [att_name, asc_dsc], {fk_info | pk_info | prefix_length}, filter_predicate, status, comment }, name, { BTID,
3167-    * [att_name, asc_dsc], {fk_info | pk_info | prefix_length}, filter_predicate, status, comment }, ... } */
3168-   for (i = 0; i &lt; len; i += 2)
3169-     {
3170-
3171-       /* get the name */
3172-       if (set_get_element (props, i, &amp;uvalue))
3173-  {
3174-    goto other_error;
3175-  }
3176-       if (DB_VALUE_TYPE (&amp;uvalue) != DB_TYPE_STRING)
3177-  {
3178-    goto structure_error;



3184-       if (new_ == NULL)
3185-  {
3186-    goto memory_error;
3187-  }
3188-       if (constraints == NULL)
3189-  {
3190-    constraints = new_;
3191-  }
3192-       else
3193-  {
3194-    last-&gt;next = new_;
3195-  }
3196-       last = new_;
3197-
3198-       /* Get the information sequence, this sequence contains a BTID followed by the names/ids of each
3199-        * attribute. */
3200-       if (set_get_element (props, i + 1, &amp;uvalue))
3201-  {
3202-    goto structure_error;
3203-  }
3204:       if (DB_VALUE_TYPE (&amp;uvalue) != DB_TYPE_SEQUENCE)
3205-  {
3206-    goto structure_error;
3207-  }
3208-
3209-       info = db_get_set (&amp;uvalue);
3210-       info_len = set_size (info);
3211-
3212-       att_cnt = (info_len - 3) / 2; /* excludes BTID and comment */
3213-       assert (att_cnt &gt; 0);
3214-
3215-       e = 0;
3216-
3217-       /* get the btid */
3218-       if (set_get_element (info, e++, &amp;bvalue))
3219-  {
3220-    goto structure_error;
3221-  }
3222-       if (classobj_btid_from_property_value (&amp;bvalue, &amp;new_-&gt;index_btid, (char **) &amp;new_-&gt;shared_cons_name))
3223-  {
3224-    goto structure_error;



3233-    goto memory_error;
3234-  }
3235-
3236-       new_-&gt;asc_desc = (int *) db_ws_alloc (sizeof (int) * att_cnt);
3237-       if (new_-&gt;asc_desc == NULL)
3238-  {
3239-    goto memory_error;
3240-  }
3241-       asc_desc = (int *) new_-&gt;asc_desc;
3242-
3243-       att = NULL;
3244-       /* Find each attribute referenced by the constraint. */
3245-       for (j = 0; j &lt; att_cnt; j++)
3246-  {
3247-    /* name( or id) */
3248-    if (set_get_element (info, e++, &amp;avalue))
3249-      {
3250-        goto structure_error;
3251-      }
3252-
3253:    if (DB_VALUE_TYPE (&amp;avalue) == DB_TYPE_SEQUENCE)
3254-      {
3255-        new_-&gt;attributes[j] = NULL;
3256-        pr_clear_value (&amp;avalue);
3257-        break;
3258-      }
3259-
3260-    if (DB_VALUE_TYPE (&amp;avalue) == DB_TYPE_STRING)
3261-      {
3262-        att = classobj_find_attribute_list (attributes, db_get_string (&amp;avalue), -1);
3263-      }
3264-    else if (DB_VALUE_TYPE (&amp;avalue) == DB_TYPE_INTEGER)
3265-      {
3266-        att = classobj_find_attribute_list (attributes, NULL, db_get_int (&amp;avalue));
3267-      }
3268-    else
3269-      {
3270-        goto structure_error;
3271-      }
3272-
3273-    new_-&gt;attributes[j] = att;



3324-      {
3325-        goto structure_error;
3326-      }
3327-    fk = db_get_set (&amp;bvalue);
3328-
3329-    new_-&gt;fk_info = classobj_make_foreign_key_info (fk, new_-&gt;name, attributes);
3330-    if (new_-&gt;fk_info == NULL)
3331-      {
3332-        goto structure_error;
3333-      }
3334-
3335-    pr_clear_value (&amp;bvalue);
3336-  }
3337-       else if (Constraint_types[k] == SM_CONSTRAINT_PRIMARY_KEY)
3338-  {
3339-    if (set_get_element (info, e++, &amp;bvalue))
3340-      {
3341-        goto structure_error;
3342-      }
3343-
3344:    if (DB_VALUE_TYPE (&amp;bvalue) == DB_TYPE_SEQUENCE)
3345-      {
3346-        new_-&gt;fk_info = classobj_make_foreign_key_ref_list (db_get_set (&amp;bvalue));
3347-        if (new_-&gt;fk_info == NULL)
3348-   {
3349-     goto structure_error;
3350-   }
3351-
3352-        pr_clear_value (&amp;bvalue);
3353-      }
3354-  }
3355-       else
3356-  {
3357-    if (set_get_element (info, e++, &amp;bvalue))
3358-      {
3359-        goto structure_error;
3360-      }
3361-
3362:    if (DB_VALUE_TYPE (&amp;bvalue) == DB_TYPE_SEQUENCE)
3363-      {
3364-        DB_SEQ *seq = db_get_set (&amp;bvalue);
3365-        if (set_get_element (seq, 0, &amp;fvalue))
3366-   {
3367-     pr_clear_value (&amp;bvalue);
3368-     goto structure_error;
3369-   }
3370-        if (DB_VALUE_TYPE (&amp;fvalue) == DB_TYPE_INTEGER)
3371-   {
3372-     new_-&gt;attrs_prefix_length = classobj_make_index_prefix_info (seq, att_cnt);
3373-     if (new_-&gt;attrs_prefix_length == NULL)
3374-       {
3375-         goto structure_error;
3376-       }
3377-   }
3378:        else if (DB_VALUE_TYPE (&amp;fvalue) == DB_TYPE_SEQUENCE)
3379-   {
3380-     DB_SET *seq = db_get_set (&amp;bvalue);
3381-     DB_SET *child_seq = db_get_set (&amp;fvalue);
3382-     int seq_size = set_size (seq);
3383-     int flag;
3384-
3385-     j = 0;
3386-     while (true)
3387-       {
3388-         flag = 0;
3389-         if (set_get_element (child_seq, 0, &amp;avalue) != NO_ERROR)
3390-    {
3391-      goto structure_error;
3392-    }
3393-
3394-         if (DB_IS_NULL (&amp;avalue) || DB_VALUE_TYPE (&amp;avalue) != DB_TYPE_STRING)
3395-    {
3396-      goto structure_error;
3397-    }
3398-
3399-         if (strcmp (db_get_string (&amp;avalue), SM_FILTER_INDEX_ID) == 0)
3400-    {
3401-      flag = 0x01;
3402-    }
3403-         else if (strcmp (db_get_string (&amp;avalue), SM_FUNCTION_INDEX_ID) == 0)
3404-    {
3405-      flag = 0x02;
3406-    }
3407-         else if (strcmp (db_get_string (&amp;avalue), SM_PREFIX_INDEX_ID) == 0)
3408-    {
3409-      flag = 0x03;
3410-    }
3411-
3412-         pr_clear_value (&amp;avalue);
3413-
3414-         if (set_get_element (child_seq, 1, &amp;avalue) != NO_ERROR)
3415-    {
3416-      goto structure_error;
3417-    }
3418-
3419:         if (DB_VALUE_TYPE (&amp;avalue) != DB_TYPE_SEQUENCE)
3420-    {
3421-      goto structure_error;
3422-    }
3423-
3424-         switch (flag)
3425-    {
3426-    case 0x01:
3427-      new_-&gt;filter_predicate = classobj_make_index_filter_pred_info (db_get_set (&amp;avalue));
3428-      break;
3429-
3430-    case 0x02:
3431-      new_-&gt;func_index_info = classobj_make_function_index_info (db_get_set (&amp;avalue));
3432-      break;
3433-
3434-    case 0x03:
3435-      new_-&gt;attrs_prefix_length =
3436-        classobj_make_index_prefix_info (db_get_set (&amp;avalue), att_cnt);
3437-      break;
3438-
3439-    default:
3440-      break;
3441-    }
3442-
3443-         pr_clear_value (&amp;avalue);
3444-
3445-         j++;
3446-         if (j &gt;= seq_size)
3447-    {
3448-      break;
3449-    }
3450-
3451-         pr_clear_value (&amp;fvalue);
3452-         if (set_get_element (seq, j, &amp;fvalue) != NO_ERROR)
3453-    {
3454-      goto structure_error;
3455-    }
3456-
3457:         if (DB_VALUE_TYPE (&amp;fvalue) != DB_TYPE_SEQUENCE)
3458-    {
3459-      goto structure_error;
3460-    }
3461-
3462-         child_seq = db_get_set (&amp;fvalue);
3463-       }
3464-
3465-     if (new_-&gt;func_index_info)
3466-       {
3467-         /* function index and prefix length not allowed, yet */
3468-         new_-&gt;attrs_prefix_length = (int *) db_ws_alloc (sizeof (int) * att_cnt);
3469-         if (new_-&gt;attrs_prefix_length == NULL)
3470-    {
3471-      goto structure_error;
3472-    }
3473-         for (j = 0; j &lt; att_cnt; j++)
3474-    {
3475-      new_-&gt;attrs_prefix_length[j] = -1;
3476-    }
3477-       }



8470-static int
8471-classobj_check_function_constraint_info (DB_SEQ * constraint_seq, bool * has_function_constraint)
8472-{
8473-  DB_VALUE bvalue, fvalue, avalue;
8474-  int constraint_seq_len = set_size (constraint_seq);
8475-  int j = 0;
8476-
8477-  assert (constraint_seq != NULL &amp;&amp; has_function_constraint != NULL);
8478-
8479-  /* initializations */
8480-  *has_function_constraint = false;
8481-  db_make_null (&amp;bvalue);
8482-  db_make_null (&amp;avalue);
8483-  db_make_null (&amp;fvalue);
8484-
8485-  if (set_get_element (constraint_seq, constraint_seq_len - 3, &amp;bvalue) != NO_ERROR)
8486-    {
8487-      goto structure_error;
8488-    }
8489-
8490:  if (DB_VALUE_TYPE (&amp;bvalue) == DB_TYPE_SEQUENCE)
8491-    {
8492-      DB_SEQ *seq = db_get_set (&amp;bvalue);
8493-      if (set_get_element (seq, 0, &amp;fvalue) != NO_ERROR)
8494- {
8495-   pr_clear_value (&amp;bvalue);
8496-   goto structure_error;
8497- }
8498-      if (DB_VALUE_TYPE (&amp;fvalue) == DB_TYPE_INTEGER)
8499- {
8500-   /* don't care about prefix length */
8501- }
8502:      else if (DB_VALUE_TYPE (&amp;fvalue) == DB_TYPE_SEQUENCE)
8503- {
8504-   DB_SET *child_seq = db_get_set (&amp;fvalue);
8505-   int seq_size = set_size (seq);
8506-
8507-   j = 0;
8508-   while (true)
8509-     {
8510-       if (set_get_element (child_seq, 0, &amp;avalue) != NO_ERROR)
8511-  {
8512-    goto structure_error;
8513-  }
8514-
8515-       if (DB_IS_NULL (&amp;avalue) || DB_VALUE_TYPE (&amp;avalue) != DB_TYPE_STRING)
8516-  {
8517-    goto structure_error;
8518-  }
8519-
8520-       if (strcmp (db_get_string (&amp;avalue), SM_FUNCTION_INDEX_ID) == 0)
8521-  {
8522-    *has_function_constraint = true;
8523-    pr_clear_value (&amp;avalue);
8524-    break;
8525-  }
8526-
8527-       pr_clear_value (&amp;avalue);
8528-
8529-       j++;
8530-       if (j &gt;= seq_size)
8531-  {
8532-    break;
8533-  }
8534-
8535-       pr_clear_value (&amp;fvalue);
8536-       if (set_get_element (seq, j, &amp;fvalue) != NO_ERROR)
8537-  {
8538-    goto structure_error;
8539-  }
8540-
8541:       if (DB_VALUE_TYPE (&amp;fvalue) != DB_TYPE_SEQUENCE)
8542-  {
8543-    goto structure_error;
8544-  }
8545-
8546-       child_seq = db_get_set (&amp;fvalue);
8547-     }
8548- }
8549-      else
8550- {
8551-   goto structure_error;
8552- }
8553-
8554-      pr_clear_value (&amp;fvalue);
8555-      pr_clear_value (&amp;bvalue);
8556-    }
8557-  else
8558-    {
8559-      goto structure_error;
8560-    }
8561-

</code></pre>
<pre><code class="language-cpp">object_domain.h
207-     * m. Only used in very special circumstances where we're trying to avoid copying
208-     * strings. */
209-
210-  TP_SET_MATCH
211-} TP_MATCH;
212-
213-/*
214- * TP_IS_SET_TYPE
215- *    Macros for detecting the set types, saves a function call.
216- */
217-/*
218- * !!! DB_TYPE_VOBJ probably should be added to this macro as this
219- * is now the behavior of pr_is_set_type() which we should try to
220- * phase out in favor of the faster inline macro.  Unfortunately, there
221- * are a number of usages of both TP_IS_SET_TYPE that may break if
222- * we change the semantics.  Will have to think carefully about this
223- */
224-
225-#define TP_IS_SET_TYPE(typenum) \
226-  ((((typenum) == DB_TYPE_SET) || ((typenum) == DB_TYPE_MULTISET) || \
227:    ((typenum) == DB_TYPE_SEQUENCE)) ? true : false)
228-
229-/*
230- * TP_IS_BIT_TYPE
231- *    Tests to see if the type id is one of the binary string types.
232- */
233-
234-#define TP_IS_BIT_TYPE(typeid) \
235-  (((typeid) == DB_TYPE_VARBIT) || ((typeid) == DB_TYPE_BIT))
236-
237-/*
238- * TP_IS_CHAR_TYPE
239- *    Tests to see if a type is any one of the character types.
240- */
241-
242-#define TP_IS_CHAR_TYPE(typeid) \
243-  (((typeid) == DB_TYPE_VARCHAR)  || ((typeid) == DB_TYPE_CHAR) || \
244-   ((typeid) == DB_TYPE_VARNCHAR) || ((typeid) == DB_TYPE_NCHAR))
245-
246-#define TP_IS_LOB_TYPE(typeid) \
247-  (((typeid) == DB_TYPE_BLOB)  || ((typeid) == DB_TYPE_CLOB))

</code></pre>
<pre><code class="language-cpp">object_primitive.c
1599-  mr_setval_multiset,
1600-  mr_data_lengthmem_set,
1601-  mr_data_lengthval_set,
1602-  mr_data_writemem_set,
1603-  mr_data_readmem_set,
1604-  mr_data_writeval_set,
1605-  mr_data_readval_set,
1606-  NULL,    /* index_lengthmem */
1607-  NULL,    /* index_lengthval */
1608-  NULL,    /* index_writeval */
1609-  NULL,    /* index_readval */
1610-  NULL,    /* index_cmpdisk */
1611-  mr_freemem_set,
1612-  mr_data_cmpdisk_set,
1613-  mr_cmpval_set
1614-};
1615-
1616-PR_TYPE *tp_Type_multiset = &amp;tp_Multiset;
1617-
1618-PR_TYPE tp_Sequence = {
1619:  "sequence", DB_TYPE_SEQUENCE, 1, sizeof (SETOBJ *), 0, 4,
1620-  mr_initmem_set,
1621-  mr_initval_sequence,
1622-  mr_setmem_set,
1623-  mr_getmem_sequence,
1624-  mr_setval_sequence,
1625-  mr_data_lengthmem_set,
1626-  mr_data_lengthval_set,
1627-  mr_data_writemem_set,
1628-  mr_data_readmem_set,
1629-  mr_data_writeval_set,
1630-  mr_data_readval_set,
1631-  NULL,    /* index_lengthmem */
1632-  NULL,    /* index_lengthval */
1633-  NULL,    /* index_writeval */
1634-  NULL,    /* index_readval */
1635-  NULL,    /* index_cmpdisk */
1636-  mr_freemem_set,
1637-  mr_data_cmpdisk_sequence,
1638-  mr_cmpval_sequence
1639-};



1963-     {
1964-       db_private_free (NULL, const_cast &lt; char *&gt;(value-&gt;data.json.schema_raw));
1965-       value-&gt;data.json.schema_raw = NULL;
1966-     }
1967- }
1968-      else
1969- {
1970-   value-&gt;data.json.document = NULL;
1971-   value-&gt;data.json.schema_raw = NULL;
1972- }
1973-      break;
1974-
1975-    case DB_TYPE_OBJECT:
1976-      /* we need to be sure to NULL the object pointer so that this db_value does not cause garbage collection problems
1977-       * by retaining an object pointer. */
1978-      value-&gt;data.op = NULL;
1979-      break;
1980-
1981-    case DB_TYPE_SET:
1982-    case DB_TYPE_MULTISET:
1983:    case DB_TYPE_SEQUENCE:
1984-    case DB_TYPE_VOBJ:
1985-      set_free (db_get_set (value));
1986-      value-&gt;data.set = NULL;
1987-      break;
1988-
1989-    case DB_TYPE_MIDXKEY:
1990-      midxkey_buf = value-&gt;data.midxkey.buf;
1991-      if (midxkey_buf != NULL)
1992- {
1993-   if (value-&gt;need_clear)
1994-     {
1995-       db_private_free_and_init (NULL, midxkey_buf);
1996-     }
1997-   /*
1998-    * Ack, phfffft!!! why should we have to know about the
1999-    * internals here?
2000-    */
2001-   value-&gt;data.midxkey.buf = NULL;
2002- }
2003-      break;



6937-  }
6938-     }
6939-   else
6940-     {
6941-       ref = set_copy (src_ref);
6942-       if (ref == NULL)
6943-  {
6944-    goto err_set;
6945-  }
6946-     }
6947- }
6948-
6949-      switch (set_type)
6950- {
6951- case DB_TYPE_SET:
6952-   db_make_set (dest, ref);
6953-   break;
6954- case DB_TYPE_MULTISET:
6955-   db_make_multiset (dest, ref);
6956-   break;
6957: case DB_TYPE_SEQUENCE:
6958-   db_make_sequence (dest, ref);
6959-   break;
6960- default:
6961-   break;
6962- }
6963-    }
6964-  else
6965-    {
6966-      db_value_domain_init (dest, set_type, DB_DEFAULT_PRECISION, DB_DEFAULT_SCALE);
6967-    }
6968-  return error;
6969-
6970-err_set:
6971-  /* couldn't allocate storage for set */
6972-  assert (er_errid () != NO_ERROR);
6973-  error = er_errid ();
6974-  switch (set_type)
6975-    {
6976-    case DB_TYPE_SET:
6977-      db_make_set (dest, NULL);
6978-      break;
6979-    case DB_TYPE_MULTISET:
6980-      db_make_multiset (dest, NULL);
6981-      break;
6982:    case DB_TYPE_SEQUENCE:
6983-      db_make_sequence (dest, NULL);
6984-      break;
6985-    default:
6986-      break;
6987-    }
6988-  db_make_null (dest);
6989-  return error;
6990-}
6991-
6992-static int
6993-mr_setval_set (DB_VALUE * dest, const DB_VALUE * src, bool copy)
6994-{
6995-  return mr_setval_set_internal (dest, src, copy, DB_TYPE_SET);
6996-}
6997-
6998-static int
6999-mr_data_lengthmem_set (void *memptr, TP_DOMAIN * domain, int disk)
7000-{
7001-  int size;
7002-



7240-       return ER_FAILED;
7241-     }
7242-   else
7243-     {
7244-       ref = setobj_get_reference (set);
7245-       if (ref == NULL)
7246-  {
7247-    or_abort (buf);
7248-    return ER_FAILED;
7249-  }
7250-       else
7251-  {
7252-    switch (set_get_type (ref))
7253-      {
7254-      case DB_TYPE_SET:
7255-        db_make_set (value, ref);
7256-        break;
7257-      case DB_TYPE_MULTISET:
7258-        db_make_multiset (value, ref);
7259-        break;
7260:      case DB_TYPE_SEQUENCE:
7261-        db_make_sequence (value, ref);
7262-        break;
7263-      default:
7264-        break;
7265-      }
7266-  }
7267-     }
7268- }
7269-      else
7270- {
7271-   /* copy == false, which means don't translate it into memory rep */
7272-   ref = set_make_reference ();
7273-   if (ref == NULL)
7274-     {
7275-       or_abort (buf);
7276-       return ER_FAILED;
7277-     }
7278-   else
7279-     {
7280-       int disk_size;



7301-    disk_size = or_disk_set_size (buf, domain, &amp;set_type);
7302-  }
7303-
7304-       /* Record the pointer to the disk bits */
7305-       ref-&gt;disk_set = buf-&gt;ptr;
7306-       ref-&gt;need_clear = false;
7307-       ref-&gt;disk_size = disk_size;
7308-       ref-&gt;disk_domain = domain;
7309-
7310-       /* advance the buffer as if we had read the set */
7311-       rc = or_advance (buf, disk_size);
7312-
7313-       switch (set_type)
7314-  {
7315-  case DB_TYPE_SET:
7316-    db_make_set (value, ref);
7317-    break;
7318-  case DB_TYPE_MULTISET:
7319-    db_make_multiset (value, ref);
7320-    break;
7321:  case DB_TYPE_SEQUENCE:
7322-    db_make_sequence (value, ref);
7323-    break;
7324-  default:
7325-    break;
7326-  }
7327-     }
7328- }
7329-    }
7330-  return rc;
7331-}
7332-
7333-static void
7334-mr_freemem_set (void *memptr)
7335-{
7336-  /* since we aren't explicitly setting the set to NULL, we must set up the reference structures so they will get the
7337-   * new set when it is brought back in, this is the only primitive type for which the free function is semantically
7338-   * different than using the setmem function with a NULL value */
7339-
7340-  SETOBJ **mem = (SETOBJ **) memptr;
7341-



7417- }
7418-    }
7419-  /* NOTE: assumes that ownership info will already have been set or will be set by the caller */
7420-
7421-  return error;
7422-}
7423-
7424-static int
7425-mr_setval_multiset (DB_VALUE * dest, const DB_VALUE * src, bool copy)
7426-{
7427-  return mr_setval_set_internal (dest, src, copy, DB_TYPE_MULTISET);
7428-}
7429-
7430-/*
7431- * TYPE SEQUENCE
7432- */
7433-
7434-static void
7435-mr_initval_sequence (DB_VALUE * value, int precision, int scale)
7436-{
7437:  db_value_domain_init (value, DB_TYPE_SEQUENCE, precision, scale);
7438-  db_make_sequence (value, NULL);
7439-}
7440-
7441-static int
7442-mr_getmem_sequence (void *memptr, TP_DOMAIN * domain, DB_VALUE * value, bool copy)
7443-{
7444-  SETOBJ **mem = (SETOBJ **) memptr;
7445-  int error = NO_ERROR;
7446-  SETOBJ *set;
7447-  SETREF *ref;
7448-
7449-  set = *mem;
7450-  if (set == NULL)
7451-    {
7452-      error = db_make_sequence (value, NULL);
7453-    }
7454-  else
7455-    {
7456-      ref = setobj_get_reference (set);
7457-      if (ref)



7459-   error = db_make_sequence (value, ref);
7460- }
7461-      else
7462- {
7463-   assert (er_errid () != NO_ERROR);
7464-   error = er_errid ();
7465-   (void) db_make_sequence (value, NULL);
7466- }
7467-    }
7468-  /*
7469-   * NOTE: assumes that ownership info will already have been set or will
7470-   * be set by the caller
7471-   */
7472-
7473-  return error;
7474-}
7475-
7476-static int
7477-mr_setval_sequence (DB_VALUE * dest, const DB_VALUE * src, bool copy)
7478-{
7479:  return mr_setval_set_internal (dest, src, copy, DB_TYPE_SEQUENCE);
7480-}
7481-
7482-static DB_VALUE_COMPARE_RESULT
7483-mr_data_cmpdisk_sequence (void *mem1, void *mem2, TP_DOMAIN * domain, int do_coercion, int total_order, int *start_colp)
7484-{
7485-  DB_VALUE_COMPARE_RESULT c;
7486-  SETOBJ *seq1 = NULL, *seq2 = NULL;
7487-
7488-  assert (domain != NULL);
7489-
7490-  /* is not index type */
7491-  assert (!domain-&gt;is_desc &amp;&amp; !tp_valid_indextype (TP_DOMAIN_TYPE (domain)));
7492-
7493-  mem1 = or_unpack_set ((char *) mem1, &amp;seq1, domain);
7494-  mem2 = or_unpack_set ((char *) mem2, &amp;seq2, domain);
7495-
7496-  if (seq1 == NULL || seq2 == NULL)
7497-    {
7498-      return DB_UNK;
7499-    }

</code></pre>
<pre><code class="language-cpp">transform.c
221-  {NULL, (DB_TYPE) 0, 0, NULL, 0, 0, NULL}
222-};
223-META_CLASS tf_Metaclass_class = { META_CLASS_NAME, {META_PAGE_CLASS, 0, META_VOLUME}, 0, 0, 0,
224-&amp;class_atts[0]
225-};
226-
227-/* QUERY_SPEC */
228-static META_ATTRIBUTE query_spec_atts[] = {
229-  {"specification", DB_TYPE_STRING, 1, NULL, 0, 0, NULL},
230-  {NULL, (DB_TYPE) 0, 0, NULL, 0, 0, NULL}
231-};
232-META_CLASS tf_Metaclass_query_spec = { META_QUERY_SPEC_NAME, {META_PAGE_QUERY_SPEC, 0, META_VOLUME}, 0, 0, 0,
233-&amp;query_spec_atts[0]
234-};
235-
236-/* PARTITION */
237-static META_ATTRIBUTE partition_atts[] = {
238-  {"ptype", DB_TYPE_INTEGER, 1, NULL, 0, 0, NULL},
239-  {"pname", DB_TYPE_STRING, 1, NULL, 0, 0, NULL},
240-  {"pexpr", DB_TYPE_STRING, 1, NULL, 0, 0, NULL},
241:  {"pvalues", DB_TYPE_SEQUENCE, 0, NULL, 0, 0, NULL},
242-  {"comment", DB_TYPE_STRING, 1, NULL, 0, 0, NULL},
243-  {NULL, (DB_TYPE) 0, 0, NULL, 0, 0, NULL}
244-};
245-
246-META_CLASS tf_Metaclass_partition = { META_PARTITION_NAME, {META_PAGE_PARTITION, 0, META_VOLUME}, 0, 0, 0,
247-&amp;partition_atts[0]
248-};
249-
250-/* ROOT */
251-static META_ATTRIBUTE root_atts[] = {
252-  {"heap_fileid", DB_TYPE_INTEGER, 0, NULL, 0, 0, NULL},
253-  {"heap_volid", DB_TYPE_INTEGER, 0, NULL, 0, 0, NULL},
254-  {"heap_pageid", DB_TYPE_INTEGER, 0, NULL, 0, 0, NULL},
255-  {"name", DB_TYPE_STRING, 0, NULL, 0, 0, NULL},
256-  {NULL, (DB_TYPE) 0, 0, NULL, 0, 0, NULL}
257-};
258-META_CLASS tf_Metaclass_root = { "rootclass", {META_PAGE_ROOT, 0, META_VOLUME}, 0, 0, 0, &amp;root_atts[0] };
259-
260-/*
261- * Meta_classes



278-  &amp;tf_Metaclass_partition,
279-  NULL
280-};
281-
282-#if !defined(CS_MODE)
283-
284-static CT_ATTR ct_class_atts[] = {
285-  {"class_of", NULL_ATTRID, DB_TYPE_OBJECT},
286-  {"inst_attr_count", NULL_ATTRID, DB_TYPE_INTEGER},
287-  {"shared_attr_count", NULL_ATTRID, DB_TYPE_INTEGER},
288-  {"inst_meth_count", NULL_ATTRID, DB_TYPE_INTEGER},
289-  {"class_meth_count", NULL_ATTRID, DB_TYPE_INTEGER},
290-  {"class_attr_count", NULL_ATTRID, DB_TYPE_INTEGER},
291-  {"is_system_class", NULL_ATTRID, DB_TYPE_INTEGER},
292-  {"class_type", NULL_ATTRID, DB_TYPE_INTEGER},
293-  {"owner", NULL_ATTRID, DB_TYPE_OBJECT},
294-  {"collation_id", NULL_ATTRID, DB_TYPE_INTEGER},
295-  {"tde_algorithm", NULL_ATTRID, DB_TYPE_INTEGER},
296-  {"unique_name", NULL_ATTRID, DB_TYPE_VARCHAR},
297-  {"class_name", NULL_ATTRID, DB_TYPE_VARCHAR},
298:  {"sub_classes", NULL_ATTRID, DB_TYPE_SEQUENCE},
299:  {"super_classes", NULL_ATTRID, DB_TYPE_SEQUENCE},
300:  {"inst_attrs", NULL_ATTRID, DB_TYPE_SEQUENCE},
301:  {"shared_attrs", NULL_ATTRID, DB_TYPE_SEQUENCE},
302:  {"class_attrs", NULL_ATTRID, DB_TYPE_SEQUENCE},
303:  {"inst_meths", NULL_ATTRID, DB_TYPE_SEQUENCE},
304:  {"class_meths", NULL_ATTRID, DB_TYPE_SEQUENCE},
305:  {"meth_files", NULL_ATTRID, DB_TYPE_SEQUENCE},
306:  {"query_specs", NULL_ATTRID, DB_TYPE_SEQUENCE},
307:  {"indexes", NULL_ATTRID, DB_TYPE_SEQUENCE},
308-  {"comment", NULL_ATTRID, DB_TYPE_VARCHAR},
309:  {"partition", NULL_ATTRID, DB_TYPE_SEQUENCE}
310-};
311-
312-static CT_ATTR ct_attribute_atts[] = {
313-  {"class_of", NULL_ATTRID, DB_TYPE_OBJECT},
314-  {"attr_name", NULL_ATTRID, DB_TYPE_VARCHAR},
315-  {"attr_type", NULL_ATTRID, DB_TYPE_INTEGER},
316-  {"from_attr_name", NULL_ATTRID, DB_TYPE_VARCHAR},
317-  {"data_type", NULL_ATTRID, DB_TYPE_INTEGER},
318-  {"def_order", NULL_ATTRID, DB_TYPE_INTEGER},
319-  {"from_class_of", NULL_ATTRID, DB_TYPE_OBJECT},
320-  {"is_nullable", NULL_ATTRID, DB_TYPE_INTEGER},
321-  {"default_value", NULL_ATTRID, DB_TYPE_VARCHAR},
322:  {"domains", NULL_ATTRID, DB_TYPE_SEQUENCE},
323-  {"comment", NULL_ATTRID, DB_TYPE_VARCHAR}
324-};
325-
326-static CT_ATTR ct_attrid_atts[] = {
327-  {"id", NULL_ATTRID, DB_TYPE_INTEGER},
328-  {"name", NULL_ATTRID, DB_TYPE_VARCHAR}
329-};
330-
331-static CT_ATTR ct_domain_atts[] = {
332-  {"object_of", NULL_ATTRID, DB_TYPE_OBJECT},
333-  {"data_type", NULL_ATTRID, DB_TYPE_INTEGER},
334-  {"prec", NULL_ATTRID, DB_TYPE_INTEGER},
335-  {"scale", NULL_ATTRID, DB_TYPE_INTEGER},
336-  {"code_set", NULL_ATTRID, DB_TYPE_INTEGER},
337-  {"collation_id", NULL_ATTRID, DB_TYPE_INTEGER},
338-  {"class_of", NULL_ATTRID, DB_TYPE_OBJECT},
339:  {"enumeration", NULL_ATTRID, DB_TYPE_SEQUENCE},
340:  {"set_domains", NULL_ATTRID, DB_TYPE_SEQUENCE},
341-  {"json_schema", NULL_ATTRID, DB_TYPE_STRING}
342-};
343-
344-static CT_ATTR ct_method_atts[] = {
345-  {"class_of", NULL_ATTRID, DB_TYPE_OBJECT},
346-  {"meth_name", NULL_ATTRID, DB_TYPE_VARCHAR},
347-  {"meth_type", NULL_ATTRID, DB_TYPE_INTEGER},
348-  {"from_meth_name", NULL_ATTRID, DB_TYPE_VARCHAR},
349-  {"from_class_of", NULL_ATTRID, DB_TYPE_OBJECT},
350:  {"signatures", NULL_ATTRID, DB_TYPE_SEQUENCE}
351-};
352-
353-static CT_ATTR ct_methsig_atts[] = {
354-  {"meth_of", NULL_ATTRID, DB_TYPE_OBJECT},
355-  {"arg_count", NULL_ATTRID, DB_TYPE_INTEGER},
356-  {"func_name", NULL_ATTRID, DB_TYPE_VARCHAR},
357:  {"return_value", NULL_ATTRID, DB_TYPE_SEQUENCE},
358:  {"arguments", NULL_ATTRID, DB_TYPE_SEQUENCE}
359-};
360-
361-static CT_ATTR ct_metharg_atts[] = {
362-  {"meth_sig_of", NULL_ATTRID, DB_TYPE_OBJECT},
363-  {"data_type", NULL_ATTRID, DB_TYPE_INTEGER},
364-  {"index_of", NULL_ATTRID, DB_TYPE_INTEGER},
365:  {"domains", NULL_ATTRID, DB_TYPE_SEQUENCE}
366-};
367-
368-static CT_ATTR ct_methfile_atts[] = {
369-  {"class_of", NULL_ATTRID, DB_TYPE_OBJECT},
370-  {"from_class_of", NULL_ATTRID, DB_TYPE_OBJECT},
371-  {"path_name", NULL_ATTRID, DB_TYPE_VARCHAR}
372-};
373-
374-static CT_ATTR ct_queryspec_atts[] = {
375-  {"class_of", NULL_ATTRID, DB_TYPE_OBJECT},
376-  {"spec", NULL_ATTRID, DB_TYPE_VARCHAR}
377-};
378-
379-static CT_ATTR ct_resolution_atts[] = {
380-  {"class_of", NULL_ATTRID, DB_TYPE_OBJECT},
381-  {"alias", NULL_ATTRID, DB_TYPE_VARCHAR},
382-  {"namespace", NULL_ATTRID, DB_TYPE_INTEGER},
383-  {"res_name", NULL_ATTRID, DB_TYPE_VARCHAR}
384-};
385-
386-static CT_ATTR ct_index_atts[] = {
387-  {"class_of", NULL_ATTRID, DB_TYPE_OBJECT},
388-  {"index_name", NULL_ATTRID, DB_TYPE_VARCHAR},
389-  {"is_unique", NULL_ATTRID, DB_TYPE_INTEGER},
390-  {"key_count", NULL_ATTRID, DB_TYPE_INTEGER},
391:  {"key_attrs", NULL_ATTRID, DB_TYPE_SEQUENCE},
392-  {"is_reverse", NULL_ATTRID, DB_TYPE_INTEGER},
393-  {"is_primary_key", NULL_ATTRID, DB_TYPE_INTEGER},
394-  {"is_foreign_key", NULL_ATTRID, DB_TYPE_INTEGER},
395-  {"filter_expression", NULL_ATTRID, DB_TYPE_VARCHAR},
396-  {"have_function", NULL_ATTRID, DB_TYPE_INTEGER},
397-  {"comment", NULL_ATTRID, DB_TYPE_VARCHAR},
398-  {"status", NULL_ATTRID, DB_TYPE_INTEGER}
399-};
400-
401-static CT_ATTR ct_indexkey_atts[] = {
402-  {"index_of", NULL_ATTRID, DB_TYPE_OBJECT},
403-  {"key_attr_name", NULL_ATTRID, DB_TYPE_VARCHAR},
404-  {"key_order", NULL_ATTRID, DB_TYPE_INTEGER},
405-  {"asc_desc", NULL_ATTRID, DB_TYPE_INTEGER},
406-  {"key_prefix_length", NULL_ATTRID, DB_TYPE_INTEGER},
407-  {"func", NULL_ATTRID, DB_TYPE_VARCHAR}
408-};
409-
410-static CT_ATTR ct_partition_atts[] = {
411-  {"index_of", NULL_ATTRID, DB_TYPE_OBJECT},
412-  {"ptype", NULL_ATTRID, DB_TYPE_INTEGER},
413-  {"pname", NULL_ATTRID, DB_TYPE_VARCHAR},
414-  {"pexpr", NULL_ATTRID, DB_TYPE_VARCHAR},
415:  {"pvalues", NULL_ATTRID, DB_TYPE_SEQUENCE},
416-  {"comment", NULL_ATTRID, DB_TYPE_VARCHAR}
417-};
418-
419-CT_CLASS ct_Class = {
420-  CT_CLASS_NAME,
421-  OID_INITIALIZER,
422-  (sizeof (ct_class_atts) / sizeof (ct_class_atts[0])),
423-  ct_class_atts
424-};
425-
426-CT_CLASS ct_Attribute = {
427-  CT_ATTRIBUTE_NAME,
428-  OID_INITIALIZER,
429-  (sizeof (ct_attribute_atts) / sizeof (ct_attribute_atts[0])),
430-  ct_attribute_atts
431-};
432-
433-CT_CLASS ct_Attrid = {
434-  NULL,
435-  OID_INITIALIZER,

</code></pre>
<pre><code class="language-cpp">object_accessor.c
544-   error = er_errid ();
545- }
546-    }
547-
548-  if (error == NO_ERROR)
549-    {
550-      /* assign the value */
551-      if (mem != NULL)
552- {
553-   switch (TP_DOMAIN_TYPE (att-&gt;domain))
554-     {
555-     case DB_TYPE_SET:
556-     default:
557-       db_make_set (&amp;val, new_set);
558-       break;
559-
560-     case DB_TYPE_MULTISET:
561-       db_make_multiset (&amp;val, new_set);
562-       break;
563-
564:     case DB_TYPE_SEQUENCE:
565-       db_make_sequence (&amp;val, new_set);
566-       break;
567-     }
568-
569-   error = att-&gt;domain-&gt;type-&gt;setmem (mem, att-&gt;domain, &amp;val);
570-   db_value_put_null (&amp;val);
571-
572-   if (error == NO_ERROR)
573-     {
574-       if (new_set != NULL &amp;&amp; new_set != setref)
575-  {
576-    set_free (new_set);
577-  }
578-     }
579- }
580-      else
581- {
582-   /*
583-    * remove ownership information in the current set,
584-    * need to be able to free this !!!



589-       error = set_disconnect (current_set);
590-     }
591-
592-   if (error == NO_ERROR)
593-     {
594-
595-       /* set the new value */
596-       if (new_set != NULL)
597-  {
598-    switch (TP_DOMAIN_TYPE (att-&gt;domain))
599-      {
600-      case DB_TYPE_SET:
601-      default:
602-        db_make_set (&amp;att-&gt;default_value.value, new_set);
603-        break;
604-
605-      case DB_TYPE_MULTISET:
606-        db_make_multiset (&amp;att-&gt;default_value.value, new_set);
607-        break;
608-
609:      case DB_TYPE_SEQUENCE:
610-        db_make_sequence (&amp;att-&gt;default_value.value, new_set);
611-        break;
612-      }
613-  }
614-       else
615-  {
616-    db_make_null (&amp;att-&gt;default_value.value);
617-  }
618-
619-       if (new_set != NULL)
620-  {
621-    new_set-&gt;ref_count++;
622-  }
623-     }
624- }
625-    }
626-
627-  return error;
628-}
629-



1262-    }
1263-
1264-  /* convert NULL sets to DB_TYPE_NULL */
1265-  if (set == NULL)
1266-    {
1267-      db_make_null (dest);
1268-    }
1269-  else
1270-    {
1271-      switch (TP_DOMAIN_TYPE (att-&gt;domain))
1272- {
1273- case DB_TYPE_SET:
1274- default:
1275-   db_make_set (dest, set);
1276-   break;
1277-
1278- case DB_TYPE_MULTISET:
1279-   db_make_multiset (dest, set);
1280-   break;
1281-
1282: case DB_TYPE_SEQUENCE:
1283-   db_make_sequence (dest, set);
1284-   break;
1285- }
1286-    }
1287-
1288-  return NO_ERROR;
1289-}
1290-
1291-/*
1292- * obj_get_value -
1293- *    return: int
1294- *    op(in): class or instance pointer
1295- *    att(in): attribute descriptor
1296- *    mem(in): instance memory pointer (only for instance attribute)
1297- *    source(out): alternate source value (optional)
1298- *    dest(out): destionation value container
1299- *
1300- * Note:
1301- *    This is the basic generic function for accessing an attribute
1302- *    value.  It will call one of the specialized accessor functions above



1641-
1642-   temp_type = DB_VALUE_TYPE (&amp;temp_value);
1643-   if (!TP_IS_SET_TYPE (temp_type))
1644-     {
1645-       ERROR0 (error, ER_OBJ_INVALID_SET_IN_PATH);
1646-     }
1647-   else
1648-     {
1649-       for (end = token; char_isdigit (*end) &amp;&amp; *end != '\0'; end++)
1650-  ;
1651-
1652-       nextdelim = *end;
1653-       *end = '\0';
1654-       if (end == token)
1655-  {
1656-    ERROR0 (error, ER_OBJ_INVALID_INDEX_IN_PATH);
1657-  }
1658-       else
1659-  {
1660-    index = atoi (token);
1661:    if (temp_type == DB_TYPE_SEQUENCE)
1662-      {
1663-        error = db_seq_get (db_get_set (&amp;temp_value), index, &amp;temp_value);
1664-      }
1665-    else
1666-      {
1667-        error = db_set_get (db_get_set (&amp;temp_value), index, &amp;temp_value);
1668-      }
1669-
1670-    if (error == NO_ERROR)
1671-      {
1672-        for (++end; nextdelim != ']' &amp;&amp; nextdelim != '\0'; nextdelim = *end++)
1673-   ;
1674-        if (nextdelim != '\0')
1675-   {
1676-     nextdelim = *end;
1677-   }
1678-      }
1679-  }
1680-     }
1681- }



3887-obj_find_object_by_cons_and_key (MOP classop, SM_CLASS_CONSTRAINT * cons, DB_VALUE * key, AU_FETCHMODE fetchmode)
3888-{
3889-  DB_TYPE value_type;
3890-  int error;
3891-  DB_VALUE key_element;
3892-  DB_COLLECTION *keyset;
3893-  SM_ATTRIBUTE **att;
3894-  MOP obj;
3895-  OID unique_oid;
3896-  int r, i;
3897-
3898-  value_type = DB_VALUE_TYPE (key);
3899-  att = cons-&gt;attributes;
3900-  if (att == NULL || att[0]-&gt;domain == NULL)
3901-    {
3902-      return NULL;
3903-    }
3904-
3905-  obj = NULL;
3906-  error = ER_OBJ_OBJECT_NOT_FOUND;
3907:  if (value_type != DB_TYPE_SEQUENCE)
3908-    {
3909-      /* 1 column */
3910-      if (tp_domain_select (att[0]-&gt;domain, key, 1, TP_ANY_MATCH) == NULL)
3911- {
3912-   error = ER_OBJ_INVALID_ARGUMENTS;
3913-   goto error_return;
3914- }
3915-
3916-      if (value_type == DB_TYPE_OBJECT)
3917- {
3918-   r = flush_temporary_OID (classop, key);
3919-   if (r == TEMPOID_FLUSH_NOT_SUPPORT)
3920-     {
3921-       error = ER_OBJ_INVALID_ARGUMENTS;
3922-       goto error_return;
3923-     }
3924-   else if (r == TEMPOID_FLUSH_FAIL)
3925-     {
3926-       return NULL;
3927-     }

</code></pre>
<pre><code class="language-cpp">virtual_object.c
353- new_set = db_get_set (destination_value);
354- set_size = db_set_cardinality (set);
355- for (set_index = 0; set_index &lt; set_size; ++set_index)
356-   {
357-     error = db_set_get (set, set_index, &amp;set_value);
358-     if (error != NO_ERROR)
359-       {
360-  continue;
361-       }
362-
363-     error = vid_convert_object_attr_value (attribute_p, &amp;set_value, &amp;new_set_value, has_object);
364-     if (error == NO_ERROR)
365-       {
366-  error = db_set_add (new_set, &amp;new_set_value);
367-  pr_clear_value (&amp;new_set_value);
368-       }
369-   }
370-      }
371-      break;
372-
373:    case DB_TYPE_SEQUENCE:
374-      {
375- set = db_get_set (source_value);
376- new_set = db_get_set (destination_value);
377- set_size = db_seq_size (set);
378- for (set_index = 0; set_index &lt; set_size; ++set_index)
379-   {
380-     error = db_seq_get (set, set_index, &amp;set_value);
381-     if (error != NO_ERROR)
382-       {
383-  continue;
384-       }
385-     error = vid_convert_object_attr_value (attribute_p, &amp;set_value, &amp;new_set_value, has_object);
386-     if (error == NO_ERROR)
387-       {
388-  error = db_seq_put (new_set, set_index, &amp;new_set_value);
389-  pr_clear_value (&amp;new_set_value);
390-       }
391-   }
392-      }
393-      break;



1143-      error = db_seq_get (col, attribute_p-&gt;order, &amp;val);
1144-
1145-      if (error &lt; 0)
1146- break;
1147-
1148-      mem = inst + attribute_p-&gt;offset;
1149-      switch (DB_VALUE_TYPE (&amp;val))
1150- {
1151- case DB_TYPE_VOBJ:
1152-   {
1153-     error = vid_vobj_to_object (&amp;val, &amp;vmop);
1154-     if (!(error &lt; 0))
1155-       {
1156-  db_value_domain_init (&amp;val, DB_TYPE_OBJECT, DB_DEFAULT_PRECISION, DB_DEFAULT_SCALE);
1157-  db_make_object (&amp;val, vmop);
1158-       }
1159-   }
1160-   break;
1161- case DB_TYPE_SET:
1162- case DB_TYPE_MULTISET:
1163: case DB_TYPE_SEQUENCE:
1164-   {
1165-     error = set_convert_oids_to_objects (db_get_set (&amp;val));
1166-   }
1167-   break;
1168- default:
1169-   break;
1170- }
1171-      if (error &lt; 0)
1172- break;
1173-      obj_assign_value (mop, attribute_p, mem, &amp;val);
1174-      pr_clear_value (&amp;val);
1175-    }
1176-
1177-  if (error &lt; 0)
1178-    {
1179-      db_ws_free (inst);
1180-      mop-&gt;object = NULL;
1181-      return error;
1182-    }
1183-  /*



1522-      if (!vclass)
1523- {
1524-   /*
1525-    * with no view, then the result is the object
1526-    * we just calculated.
1527-    */
1528-   *mop = obj;
1529- }
1530-      else
1531- {
1532-   DB_VALUE temp;
1533-   if (obj)
1534-     {
1535-       /* a view on an updatable class or proxy */
1536-       db_make_object (&amp;temp, obj);
1537-       flags = VID_UPDATABLE;
1538-       *mop = ws_vmop (vclass, flags, &amp;temp);
1539-     }
1540-   else
1541-     {
1542:       if (keys.domain.general_info.type == DB_TYPE_SEQUENCE)
1543-  {
1544-    /*
1545-     * The vclass refers to a non-updatable view result.
1546-     * look it up or install it in the workspace.
1547-     */
1548-    flags = 0;
1549-    *mop = ws_vmop (vclass, flags, &amp;keys);
1550-
1551-    if (*mop)
1552-      {
1553-        error = vid_build_non_upd_object (*mop, &amp;keys);
1554-      }
1555-  }
1556-     }
1557- }
1558-
1559-      if (!*mop)
1560- {
1561-   if (error == NO_ERROR)
1562-     {



1588-  *mop = NULL;
1589-  /* make sure we have a reasonable argument */
1590-  if (!value)
1591-    {
1592-      return ER_GENERIC_ERROR;
1593-    }
1594-
1595-  /* OIDs must be turned into objects */
1596-  switch (DB_VALUE_TYPE (value))
1597-    {
1598-    case DB_TYPE_OID:
1599-      oid = (OID *) db_get_oid (value);
1600-      if (oid != NULL &amp;&amp; !OID_ISNULL (oid))
1601- {
1602-   *mop = ws_mop (oid, NULL);
1603- }
1604-      break;
1605-
1606-    case DB_TYPE_SET:
1607-    case DB_TYPE_MULTISET:
1608:    case DB_TYPE_SEQUENCE:
1609-      return set_convert_oids_to_objects (db_get_set (value));
1610-
1611-    default:
1612-      break;
1613-    }
1614-  return NO_ERROR;
1615-}
1616-
1617-/*
1618- * vid_object_to_vobj() -
1619- *    return: NO_ERROR if all OK, a negative ER code otherwise
1620- *    obj(in): a virtual object instance in the workspace
1621- *    vobj(out): a DB_TYPE_VOBJ db_value
1622- *
1623- * Note:
1624- *   requires: obj is a virtual mop in the workspace
1625- *   modifies: vobj, set/seq memory pool
1626- *   effects : builds the DB_TYPE_VOBJ db_value form of the given virtual mop
1627- */
1628-int

</code></pre>
<pre><code class="language-cpp">object_representation.c
2990-     }
2991-   break;
2992-
2993- case DB_TYPE_OBJECT:
2994- case DB_TYPE_OID:
2995-   /*
2996-    * If the include_classoids argument was specified, set a flag in the
2997-    * disk representation indicating the presence of the class oids.
2998-    * This isn't necessary when the domain is used for value tagging
2999-    * since the class OID can always be be gotten from the instance oid.
3000-    */
3001-   if (include_classoids)
3002-     {
3003-       carrier |= OR_DOMAIN_CLASS_OID_FLAG;
3004-       has_oid = 1;
3005-     }
3006-   break;
3007-
3008- case DB_TYPE_SET:
3009- case DB_TYPE_MULTISET:
3010: case DB_TYPE_SEQUENCE:
3011- case DB_TYPE_TABLE:
3012- case DB_TYPE_MIDXKEY:
3013-   /*
3014-    * we need to recursively store the sub-domains following this one,
3015-    * since sets can have empty domains we need a flag to indicate this.
3016-    */
3017-   if (d-&gt;setdomain != NULL)
3018-     {
3019-       carrier |= OR_DOMAIN_SET_DOMAIN_FLAG;
3020-       has_subdomain = 1;
3021-     }
3022-
3023-   if (id == DB_TYPE_MIDXKEY)
3024-     {
3025-       assert (d-&gt;precision &gt; 0 &amp;&amp; d-&gt;precision == tp_domain_size (d-&gt;setdomain));
3026-       precision = d-&gt;precision;
3027-     }
3028-
3029-   break;
3030-



3286-      {
3287-        precision = DB_MAX_VARCHAR_PRECISION;
3288-      }
3289-    else if (type == DB_TYPE_VARNCHAR)
3290-      {
3291-        precision = DB_MAX_VARNCHAR_PRECISION;
3292-      }
3293-    else if (type == DB_TYPE_VARBIT)
3294-      {
3295-        precision = DB_MAX_VARBIT_PRECISION;
3296-      }
3297-  }
3298-       break;
3299-
3300-     case DB_TYPE_OBJECT:
3301-       has_classoid = carrier &amp; OR_DOMAIN_CLASS_OID_FLAG;
3302-       break;
3303-
3304-     case DB_TYPE_SET:
3305-     case DB_TYPE_MULTISET:
3306:     case DB_TYPE_SEQUENCE:
3307-     case DB_TYPE_TABLE:
3308-     case DB_TYPE_MIDXKEY:
3309-       has_setdomain = carrier &amp; OR_DOMAIN_SET_DOMAIN_FLAG;
3310-       if (type == DB_TYPE_MIDXKEY)
3311-  {
3312-    precision = (carrier &amp; OR_DOMAIN_PRECISION_MASK) &gt;&gt; OR_DOMAIN_PRECISION_SHIFT;
3313-  }
3314-       break;
3315-
3316-     case DB_TYPE_ENUMERATION:
3317-       has_enum = carrier &amp; OR_DOMAIN_ENUMERATION_FLAG;
3318-       has_collation = ((carrier &amp; OR_DOMAIN_ENUM_COLL_FLAG) == OR_DOMAIN_ENUM_COLL_FLAG);
3319-       break;
3320-
3321-     case DB_TYPE_JSON:
3322-       has_schema = (carrier &amp; OR_DOMAIN_SCHEMA_FLAG) != 0;
3323-       break;
3324-
3325-     default:
3326-       break;



3695-    rc = or_get_oid (buf, &amp;class_oid);
3696-    if (rc != NO_ERROR)
3697-      {
3698-        goto error;
3699-      }
3700-#if !defined (SERVER_MODE)
3701-    /* swizzle the pointer if we're on the client */
3702-    class_mop = ws_mop (&amp;class_oid, NULL);
3703-#endif /* !SERVER_MODE */
3704-  }
3705-       else
3706-  {
3707-    OID_SET_NULL (&amp;class_oid);
3708-    class_mop = NULL;
3709-  }
3710-       dom = tp_domain_find_object (type, &amp;class_oid, class_mop, is_desc);
3711-       break;
3712-
3713-     case DB_TYPE_SET:
3714-     case DB_TYPE_MULTISET:
3715:     case DB_TYPE_SEQUENCE:
3716-     case DB_TYPE_TABLE:
3717-     case DB_TYPE_MIDXKEY:
3718-       if (carrier &amp; OR_DOMAIN_SET_DOMAIN_FLAG)
3719-  {
3720-    /* has setdomain */
3721-    setdomain = unpack_domain_2 (buf, NULL);
3722-    if (setdomain == NULL)
3723-      {
3724-        goto error;
3725-      }
3726-  }
3727-       else
3728-  {
3729-    goto error;
3730-  }
3731-
3732-       if (type == DB_TYPE_MIDXKEY)
3733-  {
3734-    precision = (carrier &amp; OR_DOMAIN_PRECISION_MASK) &gt;&gt; OR_DOMAIN_PRECISION_SHIFT;
3735-  }



5951-  return size;
5952-}
5953-
5954-/*
5955- * or_put_enumeration () - pack an enumeration
5956- *    return: error code or NO_ERROR
5957- *    enumeration (in): enumeration
5958- */
5959-int
5960-or_put_enumeration (OR_BUF * buf, const DB_ENUMERATION * enumeration)
5961-{
5962-  int rc = NO_ERROR, idx;
5963-  DB_VALUE value;
5964-  DB_ENUM_ELEMENT *db_enum = NULL;
5965-
5966-  if (enumeration-&gt;count == 0)
5967-    {
5968-      return rc;
5969-    }
5970-  /* an enumeration is packed as a collection of strings */
5971:  rc = or_put_set_header (buf, DB_TYPE_SEQUENCE, enumeration-&gt;count, 0, 0, 0, 0, 0);
5972-  if (rc != NO_ERROR)
5973-    {
5974-      return rc;
5975-    }
5976-
5977-  for (idx = 0; idx &lt; enumeration-&gt;count; idx++)
5978-    {
5979-      db_enum = &amp;enumeration-&gt;elements[idx];
5980-      db_make_varchar (&amp;value, TP_FLOATING_PRECISION_VALUE, DB_GET_ENUM_ELEM_STRING (db_enum),
5981-         DB_GET_ENUM_ELEM_STRING_SIZE (db_enum), DB_GET_ENUM_ELEM_CODESET (db_enum),
5982-         enumeration-&gt;collation_id);
5983-      rc = tp_String.data_writeval (buf, &amp;value);
5984-      pr_clear_value (&amp;value);
5985-
5986-      if (rc != NO_ERROR)
5987- {
5988-   break;
5989- }
5990-    }
5991-

</code></pre>
<pre><code class="language-cpp">set_object.c
840-       * sets &amp; multisets, must set the size back down as the elements do not logically exist yet */
841-      err = col_expand (col, size - 1);
842-      if (err)
843- {
844-   setobj_free (col);
845-   return NULL;
846- }
847-      col-&gt;size = 0;
848-
849-      /* initialize the domain with one of the built in domain structures */
850-      if (col)
851- {
852-   switch (settype)
853-     {
854-     case DB_TYPE_SET:
855-       col-&gt;domain = &amp;tp_Set_domain;
856-       break;
857-     case DB_TYPE_MULTISET:
858-       col-&gt;domain = &amp;tp_Multiset_domain;
859-       break;
860:     case DB_TYPE_SEQUENCE:
861-       col-&gt;domain = &amp;tp_Sequence_domain;
862-       break;
863-     case DB_TYPE_VOBJ:
864-       col-&gt;domain = &amp;tp_Vobj_domain;
865-       break;
866-     default:
867-       er_set (ER_ERROR_SEVERITY, ARG_FILE_LINE, ER_SET_INVALID_DOMAIN, 1, pr_type_name ((DB_TYPE) settype));
868-       setobj_free (col);
869-       col = NULL;
870-       break;
871-     }
872- }
873-    }
874-  return col;
875-}
876-
877-/*
878- * non_null_index() - search for the greatest index between a lower and
879- *                    upper bound which has a non NULL db_value.
880- *      return: long



1147-   /* ANSI puts NULLs at end of set collections for comparison */
1148-   /*
1149-    * since NULL is not equal to NULL, the insertion index
1150-    * returned for sequences might as well be at the end where
1151-    * its checp to insert.
1152-    */
1153-   insertindex = col-&gt;size;
1154- }
1155-      else
1156- {
1157-   /*
1158-    * hack, if the collection contains temporary OIDs, we're forced to
1159-    * use a linear search as the numeric OID can change without warning.
1160-    * Unfortunate but not very easy to perform effeciently without segmenting
1161-    * the collection into sorted and unsorted regions.
1162-    * Once the set is assured to contain only permanent OID's, the sort
1163-    * can be performed reliably.
1164-    *
1165-    */
1166-#if !defined(SERVER_MODE)
1167:   if (col-&gt;sorted &amp;&amp; col-&gt;coltype != DB_TYPE_SEQUENCE &amp;&amp; DB_VALUE_TYPE (val) == DB_TYPE_OBJECT)
1168-     {
1169-
1170-       DB_OBJECT *obj = db_get_object (val);
1171-       if (obj != NULL &amp;&amp; OBJECT_HAS_TEMP_OID (obj))
1172-  {
1173-    /* we're inserting a temp OID, must force the collection to become unsorted */
1174-    col-&gt;sorted = 0;
1175-  }
1176-     }
1177-#endif
1178-
1179-   /*
1180-    * Unsorted sets were introduced to deal with temporary/permanent
1181-    * oids on the client, but are now also used as an optimization for
1182-    * multisets, which are now sorted only on demand. Sorting them
1183-    * on demand yields logarithmic instead of quadratic behavior.
1184-    *
1185-    */
1186-
1187:   if (col-&gt;coltype != DB_TYPE_SEQUENCE &amp;&amp; col-&gt;sorted)
1188-     {
1189-       /* Start point for ordered search */
1190-       insertindex = non_null_index (col, 0, col-&gt;lastinsert);
1191-       if (insertindex &lt; 0)
1192-  {
1193-    /*
1194-     * all set values were NULL. Will not find val.
1195-     * insert at beginning.
1196-     */
1197-    insertindex = 0;
1198-  }
1199-       else
1200-  {
1201-    /* determine which side of last insertion index to search from. */
1202-    compare = tp_value_compare (val, INDEX (col, insertindex), do_coerce, 1);
1203-    if (compare == DB_UNK)
1204-      {
1205-        insertindex = ER_GENERIC_ERROR;
1206-      }
1207-    else if (compare &gt; 0)



1292-
1293-  if (!col || colindex &lt; 0 || !val)
1294-    {
1295-      /* invalid args */
1296-      error = ER_GENERIC_ERROR;
1297-      return error;
1298-    }
1299-
1300-  error = col_expand (col, colindex);
1301-
1302-  if (!(error &lt; 0))
1303-    {
1304-      if (!DB_IS_NULL (val))
1305- {
1306-   col-&gt;lastinsert = colindex;
1307- }
1308-      blockindex = BLOCK (colindex);
1309-      offset = OFFSET (colindex);
1310-
1311-      /* check for temporary OIDs, isn't this where we should be clearing the sorted flag too ? */
1312:      if (col-&gt;coltype != DB_TYPE_SEQUENCE &amp;&amp; DB_VALUE_TYPE (val) == DB_TYPE_OBJECT)
1313- {
1314-#if defined (SERVER_MODE)
1315-   assert_release (false);
1316-   return ER_FAILED;
1317-#else /* !defined (SERVER_MODE) */
1318-   DB_OBJECT *obj = db_get_object (val);
1319-   if (obj != NULL &amp;&amp; OBJECT_HAS_TEMP_OID (obj))
1320-     {
1321-       col-&gt;may_have_temporary_oids = 1;
1322-     }
1323-#endif /* !defined (SERVER_MODE) */
1324- }
1325-
1326-      /* If this should be cloned, the caller should do it. This primitive just allows the assignment to the right
1327-       * location in the collection */
1328-      col-&gt;array[blockindex][offset] = *val;
1329-    }
1330-
1331-  return error;
1332-}



1432-     {
1433-       memmove (&amp;col-&gt;array[topblock][1], &amp;col-&gt;array[topblock][0], topblockcount * sizeof (DB_VALUE));
1434-       col-&gt;array[topblock][0] = col-&gt;array[topblock - 1][BLOCKING_LESS1];
1435-       topblock--;
1436-       topblockcount = BLOCKING_LESS1;
1437-     }
1438-   topoffset = BLOCKING_LESS1;
1439- }
1440-      else
1441- {
1442-   topoffset = OFFSET (col-&gt;size - 1);
1443- }
1444-      /* shift the values from this block up one. */
1445-      while (topoffset &gt; offset)
1446- {
1447-   col-&gt;array[blockindex][topoffset] = col-&gt;array[blockindex][topoffset - 1];
1448-   topoffset--;
1449- }
1450-
1451-      /* check for temporary OIDs, isn't this where we should be clearing the sorted flag too ? */
1452:      if (col-&gt;coltype != DB_TYPE_SEQUENCE &amp;&amp; DB_VALUE_TYPE (val) == DB_TYPE_OBJECT)
1453- {
1454-#if defined (SERVER_MODE)
1455-   assert_release (false);
1456-   return ER_FAILED;
1457-#else /* !defined (SERVER_MODE) */
1458-   DB_OBJECT *obj = db_get_object (val);
1459-   if (obj != NULL &amp;&amp; OBJECT_HAS_TEMP_OID (obj))
1460-     {
1461-       col-&gt;may_have_temporary_oids = 1;
1462-     }
1463-#endif /* !defined (SERVER_MODE)s */
1464- }
1465-
1466-      /* If this should be cloned, the caller should do it. This primitive just allows the assignment to the right
1467-       * location in the collection */
1468-      col-&gt;array[blockindex][offset] = *val;
1469-      PRIM_SET_NULL (val);
1470-      col-&gt;lastinsert = colindex;
1471-    }
1472-



1647- {
1648-   error = i;
1649-   return error;
1650- }
1651-      /* a MULTISET- insert it whether found or not */
1652-      if (found)
1653- {
1654-   i++;   /* insert at next index after last found */
1655- }
1656-
1657-      if (i &lt; col-&gt;size - COL_BLOCK_SIZE)
1658- {
1659-   /* heuristic to avoid quadratic multiset creation. if we are moving more than a block, its likely we are
1660-    * entering quadratic behavior. Simply insert at the end, and mark the multiset unsorted. It will be sorted
1661-    * later on demand if need be, and this sort will be logarithmic instead of quadratic. */
1662-   i = col-&gt;size;
1663-   col-&gt;sorted = 0;
1664- }
1665-      error = col_insert (col, i, val);
1666-      break;
1667:    case DB_TYPE_SEQUENCE:
1668-    case DB_TYPE_VOBJ:
1669-      error = col_put (col, col-&gt;size, val);
1670-      break;
1671-    default:
1672-      /* bad args */
1673-      error = ER_GENERIC_ERROR;
1674-      break;
1675-    }
1676-  return error;
1677-}
1678-
1679-/*
1680- * col_drop() - drop val to col
1681- *      return: int
1682- *  col(in) :
1683- *  val(in) :
1684- *
1685- *  Note :
1686- *      if its a set - use set difference.
1687- *      if its a multiset - use multiset difference.



1692-col_drop (COL * col, DB_VALUE * val)
1693-{
1694-  int error = NO_ERROR;
1695-  long i, found, do_coerce;
1696-
1697-  if (!col || !val)
1698-    {
1699-      error = ER_GENERIC_ERROR; /* bad args */
1700-      return error;
1701-    }
1702-
1703-  do_coerce = (col-&gt;coltype == DB_TYPE_SET);
1704-  i = col_find (col, &amp;found, val, do_coerce);
1705-  if (i &lt; 0)
1706-    {
1707-      error = i;
1708-      return error;
1709-    }
1710-  if (found)
1711-    {
1712:      if (col-&gt;coltype == DB_TYPE_SEQUENCE)
1713- {
1714-   PRIM_SET_NULL (INDEX (col, i));
1715- }
1716-      else
1717- {
1718-   error = col_delete (col, i);
1719- }
1720-    }
1721-  return error;
1722-}
1723-
1724-/*
1725- * col_drop_nulls() - drop all nulls calues in col
1726- *      return: int
1727- *  col(in) :
1728- *
1729- */
1730-
1731-int
1732-col_drop_nulls (COL * col)



1860- *  set2(in) :
1861- *  do_coercion(in) :
1862- *  total_order(in) :
1863- *
1864- *  Note :
1865- *      We don't compare the vclass, but the proxyclass and
1866- *      the keys are compared.
1867- *
1868- *      There must be a total order on VOBJS since they can be used in merge
1869- *      joins as the join column and he can't deal with DB_UNK.  To accomplish
1870- *      this total order, we do a lexigraphical sort on proxyclass and keys.
1871- *
1872- *      We will return DB_UNK if the VOBJ is malformed.
1873- */
1874-
1875-DB_VALUE_COMPARE_RESULT
1876-setvobj_compare (COL * set1, COL * set2, int do_coercion, int total_order)
1877-{
1878-  DB_VALUE_COMPARE_RESULT cmp = DB_UNK;
1879-
1880:  if ((set1-&gt;size == 3) &amp;&amp; (set2-&gt;size == 3) &amp;&amp; (set1-&gt;coltype == DB_TYPE_SEQUENCE || set1-&gt;coltype == DB_TYPE_VOBJ)
1881:      &amp;&amp; (set2-&gt;coltype == DB_TYPE_SEQUENCE || set2-&gt;coltype == DB_TYPE_VOBJ))
1882-    {
1883-      cmp = DB_EQ;
1884-      if (DB_VALUE_DOMAIN_TYPE (&amp;set1-&gt;array[0][2]) != DB_TYPE_OID)
1885- {
1886-   cmp = tp_value_compare (&amp;set1-&gt;array[0][1], &amp;set2-&gt;array[0][1], do_coercion, 1);
1887- }
1888-      if (cmp == DB_EQ)
1889- {
1890-   cmp = tp_value_compare (&amp;set1-&gt;array[0][2], &amp;set2-&gt;array[0][2], do_coercion, total_order);
1891- }
1892-      else
1893- {
1894-   if (cmp == DB_UNK)
1895-     {
1896-       /* one of set1-&gt;array[0][1] or set2-&gt;array[0][2] must be NULL. */
1897-       cmp = DB_IS_NULL (&amp;set1-&gt;array[0][1]) ? DB_LT : DB_GT;
1898-     }
1899- }
1900-    }
1901-  else if (debug_level &gt; 0)



2416- *      return: DB_COLLECTION *
2417- *
2418- */
2419-
2420-DB_COLLECTION *
2421-set_create_multi (void)
2422-{
2423-  return set_create (DB_TYPE_MULTISET, 1);
2424-}
2425-
2426-/*
2427- * set_create_sequence()
2428- *      return: DB_COLLECTION *
2429- *  size(in) :
2430- *
2431- */
2432-
2433-DB_COLLECTION *
2434-set_create_sequence (int size)
2435-{
2436:  return set_create (DB_TYPE_SEQUENCE, size);
2437-}
2438-
2439-DB_COLLECTION *
2440-set_create_with_domain (TP_DOMAIN * domain, int initial_size)
2441-{
2442-  DB_COLLECTION *col;
2443-  COL *setobj;
2444-
2445-  col = NULL;
2446-  setobj = setobj_create_with_domain (domain, initial_size);
2447-  if (setobj == NULL)
2448-    {
2449-      return (col);
2450-    }
2451-
2452-  col = set_make_reference ();
2453-
2454-  if (col == NULL)
2455-    {
2456-      setobj_free (setobj);



4603- *    or an access failure on the owning object.
4604- */
4605-
4606-TP_DOMAIN *
4607-setobj_get_domain (COL * set)
4608-{
4609-  if (set-&gt;domain != NULL)
4610-    {
4611-      return set-&gt;domain;
4612-    }
4613-  /* Set without an owner and without a domain, this isn't supposed to happen any more.  Slam in one of the built-in
4614-   * domains. */
4615-  switch (set-&gt;coltype)
4616-    {
4617-    case DB_TYPE_SET:
4618-      set-&gt;domain = &amp;tp_Set_domain;
4619-      break;
4620-    case DB_TYPE_MULTISET:
4621-      set-&gt;domain = &amp;tp_Multiset_domain;
4622-      break;
4623:    case DB_TYPE_SEQUENCE:
4624-      set-&gt;domain = &amp;tp_Sequence_domain;
4625-      break;
4626-    case DB_TYPE_VOBJ:
4627-      set-&gt;domain = &amp;tp_Vobj_domain;
4628-      break;
4629-    default:
4630-      /* what is it? must be a structure error */
4631-      er_set (ER_ERROR_SEVERITY, ARG_FILE_LINE, ER_SET_INVALID_DOMAIN, 1, "NULL set domain");
4632-      break;
4633-    }
4634-
4635-  return set-&gt;domain;
4636-}
4637-
4638-/*
4639- * swizzle_value() - This converts a value containing an OID into one
4640- *                   containing a DB_OBJECT*
4641- *      return: none
4642- *  val(in) : value to convert
4643- *  input(in) :



4886-  for (i = col-&gt;size - 1; i &gt;= 0; i--)
4887-    {
4888-      var = INDEX (col, i);
4889-      if (filter)
4890- {
4891-   swizzle_value (var, 0);
4892- }
4893-      if (filter &amp;&amp; DB_VALUE_TYPE (var) == DB_TYPE_OBJECT)
4894- {
4895-   error = check_set_object (var, &amp;removed);
4896-   if (error &lt; 0)
4897-     {
4898-       break;
4899-     }
4900-   if (!removed)
4901-     {
4902-       card++;
4903-     }
4904-   else
4905-     {
4906:       if (col-&gt;coltype != DB_TYPE_SEQUENCE)
4907-  {
4908-    col_delete (col, i);
4909-  }
4910-     }
4911- }
4912-      else if (!db_value_is_null (var))
4913- {
4914-   card++;
4915- }
4916-    }
4917-  if (cardptr == NULL)
4918-    {
4919-      return error;
4920-    }
4921-
4922-  if (error &lt; 0)
4923-    {
4924-      *cardptr = 0;
4925-    }
4926-  else



5380- *      than appending.
5381- */
5382-
5383-int
5384-setobj_union (COL * set1, COL * set2, COL * result)
5385-{
5386-  int rc;
5387-  int error = NO_ERROR;
5388-  int index1, index2;
5389-  DB_VALUE *val1, *val2;
5390-
5391-  if (!set1-&gt;sorted)
5392-    {
5393-      error = setobj_sort (set1);
5394-    }
5395-  if (!error &amp;&amp; !set2-&gt;sorted)
5396-    {
5397-      error = setobj_sort (set2);
5398-    }
5399-
5400:  if (result-&gt;coltype == DB_TYPE_SEQUENCE)
5401-    {
5402-      /* append sequences */
5403-      for (index1 = 0; index1 &lt; set1-&gt;size &amp;&amp; !(error &lt; NO_ERROR); index1++)
5404- {
5405-   val1 = INDEX (set1, index1);
5406-   error = setobj_add_element (result, val1);
5407- }
5408-      for (index2 = 0; index2 &lt; set2-&gt;size &amp;&amp; !(error &lt; NO_ERROR); index2++)
5409- {
5410-   val2 = INDEX (set2, index2);
5411-   error = setobj_add_element (result, val2);
5412- }
5413-    }
5414-  else
5415-    {
5416-      /* compare elements in ascending order */
5417-      index1 = 0;
5418-      index2 = 0;
5419-      while (index1 &lt; set1-&gt;size &amp;&amp; index2 &lt; set2-&gt;size &amp;&amp; !(error &lt; NO_ERROR))
5420- {



5665-  for (i = 0; i &lt; col-&gt;size &amp;&amp; !(error &lt; NO_ERROR); i++)
5666-    {
5667-      var = INDEX (col, i);
5668-      typ = DB_VALUE_DOMAIN_TYPE (var);
5669-      switch (typ)
5670- {
5671- case DB_TYPE_OID:
5672-   swizzle_value (var, 0);
5673-   break;
5674- case DB_TYPE_VOBJ:
5675-   error = vid_vobj_to_object (var, &amp;mop);
5676-   if (!(error &lt; 0))
5677-     {
5678-       pr_clear_value (var);
5679-       db_value_domain_init (var, DB_TYPE_OBJECT, DB_DEFAULT_PRECISION, DB_DEFAULT_SCALE);
5680-       db_make_object (var, mop);
5681-     }
5682-   break;
5683- case DB_TYPE_SET:
5684- case DB_TYPE_MULTISET:
5685: case DB_TYPE_SEQUENCE:
5686-   error = set_convert_oids_to_objects (db_get_set (var));
5687-   break;
5688- default:
5689-   break;
5690- }
5691-    }
5692-#endif
5693-
5694-  return (error);
5695-}
5696-
5697-/* SET ELEMENT ACCESS FUNCTIONS */
5698-
5699-/*
5700- * setobj_get_element_ptr() - This is used in controlled conditions to
5701- *                            get a direct pointer to a set element value.
5702- *      return: error code
5703- *  col(in) : collection object
5704- *  index(in) : element index
5705- *  result(in) : pointer to pointer to value (returned)

</code></pre>
<pre><code class="language-cpp">authenticate_grant.cpp
832-  DB_VALUE value;
833-  DB_SET *grants = NULL;
834-  MOP grantor, gowner, class_;
835-  int gsize, i, j, existing, cache;
836-  bool need_pop_er_stack = false;
837-
838-  assert (grant_ptr != NULL);
839-
840-  *grant_ptr = NULL;
841-
842-  er_stack_push ();
843-
844-  need_pop_er_stack = true;
845-
846-  error = obj_get (auth, "grants", &amp;value);
847-  if (error != NO_ERROR)
848-    {
849-      goto end;
850-    }
851-
852:  if (DB_VALUE_TYPE (&amp;value) != DB_TYPE_SEQUENCE || DB_IS_NULL (&amp;value) || db_get_set (&amp;value) == NULL)
853-    {
854-      error = ER_AU_CORRUPTED;
855-      er_set (ER_ERROR_SEVERITY, ARG_FILE_LINE, error, 0);
856-
857-      goto end;
858-    }
859-
860-  if (!filter)
861-    {
862-      goto end;
863-    }
864-
865-  grants = db_get_set (&amp;value);
866-  gsize = set_size (grants);
867-
868-  /* there might be errors */
869-  error = er_errid ();
870-  if (error != NO_ERROR)
871-    {
872-      goto end;

</code></pre>
<pre><code class="language-cpp">object_printer.cpp
282- case DB_TYPE_JSON:
283-   strcpy (temp_buffer, temp_domain-&gt;type-&gt;name);
284-   ustr_upper (temp_buffer);
285-   if (temp_domain-&gt;json_validator != NULL)
286-     {
287-       m_buf ("%s(\'%s\')", temp_buffer, db_json_get_schema_raw_from_validator (temp_domain-&gt;json_validator));
288-     }
289-   else
290-     {
291-       m_buf (temp_buffer);
292-     }
293-   break;
294-
295- case DB_TYPE_NUMERIC:
296-   strcpy (temp_buffer, temp_domain-&gt;type-&gt;name);
297-   m_buf ("%s(%d,%d)", ustr_upper (temp_buffer), temp_domain-&gt;precision, temp_domain-&gt;scale);
298-   break;
299-
300- case DB_TYPE_SET:
301- case DB_TYPE_MULTISET:
302: case DB_TYPE_SEQUENCE:
303-   strcpy (temp_buffer, temp_domain-&gt;type-&gt;name);
304-   ustr_upper (temp_buffer);
305-   m_buf ("%s OF ", temp_buffer);
306-   if (temp_domain-&gt;setdomain != NULL)
307-     {
308-       if (temp_domain-&gt;setdomain-&gt;next != NULL &amp;&amp; prt_type == class_description::SHOW_CREATE_TABLE)
309-  {
310-    m_buf ("(");
311-    describe_domain (*temp_domain-&gt;setdomain, prt_type, force_print_collation);
312-    m_buf (")");
313-  }
314-       else
315-  {
316-    describe_domain (*temp_domain-&gt;setdomain, prt_type, force_print_collation);
317-  }
318-     }
319-   break;
320-
321- case DB_TYPE_ENUMERATION:
322-   has_collation = 1;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="storage-directory"><a class="header" href="#storage-directory">Storage Directory</a></h1>
<pre><code class="language-cpp">statistics_sr.c
882- case DB_TYPE_STRING:
883-   fprintf (fpp, "DB_TYPE_STRING \n");
884-   break;
885-
886- case DB_TYPE_OBJECT:
887-   fprintf (fpp, "DB_TYPE_OBJECT \n");
888-   break;
889-
890- case DB_TYPE_SET:
891-   fprintf (fpp, "DB_TYPE_SET \n");
892-   break;
893-
894- case DB_TYPE_JSON:
895-   fprintf (fpp, "DB_TYPE_JSON \n");
896-   break;
897-
898- case DB_TYPE_MULTISET:
899-   fprintf (fpp, "DB_TYPE_MULTISET \n");
900-   break;
901-
902: case DB_TYPE_SEQUENCE:
903:   fprintf (fpp, "DB_TYPE_SEQUENCE \n");
904-   break;
905-
906- case DB_TYPE_TIME:
907-   fprintf (fpp, "DB_TYPE_TIME \n");
908-   break;
909-
910- case DB_TYPE_TIMESTAMP:
911-   fprintf (fpp, "DB_TYPE_TIMESTAMP \n");
912-   break;
913-
914- case DB_TYPE_TIMESTAMPLTZ:
915-   fprintf (fpp, "DB_TYPE_TIMESTAMPLTZ \n");
916-   break;
917-
918- case DB_TYPE_TIMESTAMPTZ:
919-   fprintf (fpp, "DB_TYPE_TIMESTAMPTZ \n");
920-   break;
921-
922- case DB_TYPE_DATETIME:
923-   fprintf (fpp, "DB_TYPE_DATETIME \n");

</code></pre>
<pre><code class="language-cpp">compactdb_sr.c
119-     return_value = 1;
120-     break;
121-   }
122-
123- if (is_class (ref_oid, &amp;ref_class_oid))
124-   {
125-     break;
126-   }
127-
128-#if defined(CUBRID_DEBUG)
129- printf (msgcat_message (MSGCAT_CATALOG_UTILS, MSGCAT_UTIL_SET_COMPACTDB, COMPACTDB_MSG_REFOID), ref_oid-&gt;volid,
130-  ref_oid-&gt;pageid, ref_oid-&gt;slotid, ref_class_oid.volid, ref_class_oid.pageid, ref_class_oid.slotid);
131-#endif
132-
133- break;
134-      }
135-
136-    case DB_TYPE_POINTER:
137-    case DB_TYPE_SET:
138-    case DB_TYPE_MULTISET:
139:    case DB_TYPE_SEQUENCE:
140-      {
141- return_value = process_set (thread_p, db_get_set (value));
142- break;
143-      }
144-
145-    default:
146-      break;
147-    }
148-
149-  return return_value;
150-}
151-
152-/*
153- * process_set - process one set
154- *    return: whether the object should be updated.
155- *    set(in): the set to process
156- */
157-static int
158-process_set (THREAD_ENTRY * thread_p, DB_SET * set)
159-{

</code></pre>
<pre><code class="language-cpp">system_catalog.c
4781-      fprintf (stdout, "DB_TYPE_BIGINT \n");
4782-      break;
4783-    case DB_TYPE_FLOAT:
4784-      fprintf (stdout, "DB_TYPE_FLOAT \n");
4785-      break;
4786-    case DB_TYPE_DOUBLE:
4787-      fprintf (stdout, "DB_TYPE_DOUBLE \n");
4788-      break;
4789-    case DB_TYPE_STRING:
4790-      fprintf (stdout, "DB_TYPE_STRING \n");
4791-      break;
4792-    case DB_TYPE_OBJECT:
4793-      fprintf (stdout, "DB_TYPE_OBJECT \n");
4794-      break;
4795-    case DB_TYPE_SET:
4796-      fprintf (stdout, "DB_TYPE_SET \n");
4797-      break;
4798-    case DB_TYPE_MULTISET:
4799-      fprintf (stdout, "DB_TYPE_MULTISET \n");
4800-      break;
4801:    case DB_TYPE_SEQUENCE:
4802:      fprintf (stdout, "DB_TYPE_SEQUENCE \n");
4803-      break;
4804-    case DB_TYPE_TIME:
4805-      fprintf (stdout, "DB_TYPE_TIME \n");
4806-      break;
4807-    case DB_TYPE_MONETARY:
4808-      fprintf (stdout, "DB_TYPE_MONETARY \n");
4809-      break;
4810-    case DB_TYPE_DATE:
4811-      fprintf (stdout, "DB_TYPE_DATE \n");
4812-      break;
4813-    case DB_TYPE_BLOB:
4814-      fprintf (stdout, "DB_TYPE_BLOB \n");
4815-      break;
4816-    case DB_TYPE_CLOB:
4817-      fprintf (stdout, "DB_TYPE_CLOB \n");
4818-      break;
4819-    case DB_TYPE_VARIABLE:
4820-      fprintf (stdout, "DB_TYPE_VARIABLE \n");
4821-      break;
4822-    case DB_TYPE_SUB:

</code></pre>
<pre><code class="language-cpp">catalog_class.c
1375-   || db_get_enum_short (attr_val_p) &gt; or_val-&gt;value.data.set-&gt;set-&gt;size)
1376- {
1377-   error = ER_FAILED;
1378-   goto error;
1379- }
1380-      error = set_get_element (db_get_set (&amp;or_val-&gt;value), db_get_enum_short (attr_val_p) - 1, &amp;val);
1381-      if (error != NO_ERROR)
1382- {
1383-   goto error;
1384- }
1385-
1386-      val.need_clear = false;
1387-      db_make_enumeration (attr_val_p, db_get_enum_short (attr_val_p), db_get_string (&amp;val), db_get_string_size (&amp;val),
1388-      db_get_enum_codeset (attr_val_p), db_get_enum_collation (attr_val_p));
1389-      attr_val_p-&gt;need_clear = true;
1390-    }
1391-  /* triggers - advance only */
1392-  or_advance (buf_p, vars[ORC_ATT_TRIGGER_INDEX].length);
1393-
1394-  /* properties */
1395:  or_get_value (buf_p, &amp;val, tp_domain_resolve_default (DB_TYPE_SEQUENCE), vars[ORC_ATT_PROPERTIES_INDEX].length, true);
1396-  att_props = db_get_set (&amp;val);
1397-  attr_val_p = &amp;attrs[8].value;
1398-  db_make_null (&amp;default_expr);
1399-  if (att_props != NULL)
1400-    {
1401-      size_t default_value_len = 0;
1402-      const char *default_str_val = NULL;
1403-
1404-      if (classobj_get_prop (att_props, "default_expr", &amp;default_expr) &gt; 0)
1405- {
1406-   size_t len;
1407-
1408:   if (DB_VALUE_TYPE (&amp;default_expr) == DB_TYPE_SEQUENCE)
1409-     {
1410-       assert (set_size (db_get_set (&amp;default_expr)) == 3);
1411-       def_expr_seq = db_get_set (&amp;default_expr);
1412-
1413-       error = set_get_element_nocopy (def_expr_seq, 0, &amp;db_value_default_expr_op);
1414-       if (error != NO_ERROR)
1415-  {
1416-    goto error;
1417-  }
1418-       assert (DB_VALUE_TYPE (&amp;db_value_default_expr_op) == DB_TYPE_INTEGER
1419-        &amp;&amp; db_get_int (&amp;db_value_default_expr_op) == (int) T_TO_CHAR);
1420-       with_to_char = true;
1421-
1422-       error = set_get_element_nocopy (def_expr_seq, 1, &amp;db_value_default_expr_type);
1423-       if (error != NO_ERROR)
1424-  {
1425-    goto error;
1426-  }
1427-       default_expr_type = (DB_DEFAULT_EXPR_TYPE) db_get_int (&amp;db_value_default_expr_type);
1428-



1739-       goto error;
1740-     }
1741- }
1742-
1743-      if (DB_IS_NULL (attr_val_p))
1744- {
1745-   /* if self reference for example, "class x (a x)" set an invalid data type, and fill its value later */
1746-   error = db_value_domain_init (attr_val_p, DB_TYPE_VARIABLE, DB_DEFAULT_PRECISION, DB_DEFAULT_SCALE);
1747-   if (error != NO_ERROR)
1748-     {
1749-       goto error;
1750-     }
1751- }
1752-    }
1753-
1754-  /* enumeration */
1755-  if (vars[ORC_DOMAIN_ENUMERATION_INDEX].length)
1756-    {
1757-      /* enumerations are stored as a collection of strings */
1758-      TP_DOMAIN *string_dom = tp_domain_resolve_default (DB_TYPE_STRING);
1759:      PR_TYPE *seq_type = pr_type_from_id (DB_TYPE_SEQUENCE);
1760-
1761:      TP_DOMAIN *domain = tp_domain_construct (DB_TYPE_SEQUENCE, NULL, 0, 0, string_dom);
1762-      if (domain == NULL)
1763- {
1764-   error = ER_FAILED;
1765-   goto error;
1766- }
1767-      domain = tp_domain_cache (domain);
1768-
1769-      seq_type-&gt;data_readval (buf_p, &amp;attrs[7].value, domain, -1, true, NULL, 0);
1770-    }
1771-
1772-  /* set_domain */
1773-  error =
1774-    catcls_get_subset (thread_p, buf_p, vars[ORC_DOMAIN_SETDOMAIN_INDEX].length, &amp;attrs[8],
1775-         catcls_get_or_value_from_domain);
1776-
1777-  if (vars[ORC_DOMAIN_SCHEMA_JSON_OFFSET].length &gt; 0)
1778-    {
1779-      char *schema_str;
1780-      error = or_get_json_schema (buf_p, schema_str);
1781-      if (error != NO_ERROR)



2286-      attrs = values[j].sub.value;
2287-
2288-      /* index_name */
2289-      attr_val_p = &amp;attrs[1].value;
2290-      error = set_get_element (seq_p, i, attr_val_p);
2291-      if (error != NO_ERROR)
2292- {
2293-   goto error;
2294- }
2295-      db_string_truncate (attr_val_p, DB_MAX_IDENTIFIER_LENGTH);
2296-
2297-      /* (is_unique) */
2298-      db_make_int (&amp;attrs[2].value, is_unique);
2299-
2300-      error = set_get_element (seq_p, i + 1, &amp;keys);
2301-      if (error != NO_ERROR)
2302- {
2303-   goto error;
2304- }
2305-
2306:      if (DB_VALUE_TYPE (&amp;keys) == DB_TYPE_SEQUENCE)
2307- {
2308-   key_seq_p = db_get_set (&amp;keys);
2309- }
2310-      else
2311- {
2312-   assert (0);
2313-   error = ER_SM_INVALID_PROPERTY;
2314-   er_set (ER_ERROR_SEVERITY, ARG_FILE_LINE, error, 0);
2315-   goto error;
2316- }
2317-
2318-      /* the sequence of keys also includes the B+tree ID and the filter predicate expression in the first two
2319-       * positions (0 and 1) */
2320-      key_size = set_size (key_seq_p);
2321-      att_cnt = (key_size - 3) / 2;
2322-
2323-      /* Get status. */
2324-      error = set_get_element (key_seq_p, key_size - 2, &amp;attrs[11].value);
2325-
2326-      /* comment */
2327-      error = set_get_element (key_seq_p, key_size - 1, &amp;attrs[10].value);
2328-      if (error != NO_ERROR)
2329- {
2330-   goto error;
2331- }
2332-      db_string_truncate (&amp;attrs[10].value, DB_MAX_COMMENT_LENGTH);
2333-
2334-      if (!is_primary_key &amp;&amp; !is_foreign_key)
2335- {
2336-   /* prefix_length or filter index */
2337-   error = set_get_element (key_seq_p, key_size - 3, &amp;svalue);
2338-   if (error != NO_ERROR)
2339-     {
2340-       goto error;
2341-     }
2342-
2343:   if (DB_VALUE_TYPE (&amp;svalue) != DB_TYPE_SEQUENCE)
2344-     {
2345-       error = ER_SM_INVALID_PROPERTY;
2346-       er_set (ER_ERROR_SEVERITY, ARG_FILE_LINE, error, 0);
2347-       goto error;
2348-     }
2349-
2350-   seq = db_get_set (&amp;svalue);
2351-   error = set_get_element (seq, 0, &amp;val);
2352-   if (error != NO_ERROR)
2353-     {
2354-       goto error;
2355-     }
2356-
2357-   if (DB_VALUE_TYPE (&amp;val) == DB_TYPE_INTEGER)
2358-     {
2359-       /* have prefix length */
2360-       prefix_seq = seq;
2361-     }
2362:   else if (DB_VALUE_TYPE (&amp;val) == DB_TYPE_SEQUENCE)
2363-     {
2364-       DB_SET *child_seq = db_get_set (&amp;val);
2365-       int seq_size = set_size (seq);
2366-       int flag, l = 0;
2367-       DB_VALUE temp;
2368-       int col_id, att_index_start;
2369-       char *buffer, *ptr;
2370-       TP_DOMAIN *fi_domain = NULL;
2371-
2372-       /* have filter or function index */
2373-       while (true)
2374-  {
2375-    flag = 0;
2376-    error = set_get_element (child_seq, 0, &amp;avalue);
2377-    if (error != NO_ERROR)
2378-      {
2379-        goto error;
2380-      }
2381-
2382-    if (DB_IS_NULL (&amp;avalue) || DB_VALUE_TYPE (&amp;avalue) != DB_TYPE_STRING)



2390-      {
2391-        flag = 0x01;
2392-      }
2393-    else if (!intl_identifier_casecmp (db_get_string (&amp;avalue), SM_FUNCTION_INDEX_ID))
2394-      {
2395-        flag = 0x02;
2396-      }
2397-    else if (!intl_identifier_casecmp (db_get_string (&amp;avalue), SM_PREFIX_INDEX_ID))
2398-      {
2399-        flag = 0x03;
2400-      }
2401-
2402-    pr_clear_value (&amp;avalue);
2403-
2404-    error = set_get_element (child_seq, 1, &amp;avalue);
2405-    if (error != NO_ERROR)
2406-      {
2407-        goto error;
2408-      }
2409-
2410:    if (DB_VALUE_TYPE (&amp;avalue) != DB_TYPE_SEQUENCE)
2411-      {
2412-        error = ER_SM_INVALID_PROPERTY;
2413-        er_set (ER_ERROR_SEVERITY, ARG_FILE_LINE, error, 0);
2414-        goto error;
2415-      }
2416-
2417-    switch (flag)
2418-      {
2419-      case 0x01:
2420-        pred_seq = db_get_set (&amp;avalue);
2421-        attr_val_p = &amp;attrs[8].value;
2422-        error = set_get_element (pred_seq, 0, attr_val_p);
2423-        if (error != NO_ERROR)
2424-   {
2425-     goto error;
2426-   }
2427-        break;
2428-
2429-      case 0x02:
2430-        has_function_index = 1;



2540-        break;
2541-
2542-      default:
2543-        break;
2544-      }
2545-
2546-    pr_clear_value (&amp;avalue);
2547-
2548-    l++;
2549-    if (l &gt;= seq_size)
2550-      {
2551-        break;
2552-      }
2553-
2554-    pr_clear_value (&amp;val);
2555-    if (set_get_element (seq, l, &amp;val) != NO_ERROR)
2556-      {
2557-        error = ER_FAILED;
2558-        goto error;
2559-      }
2560:    if (DB_VALUE_TYPE (&amp;val) != DB_TYPE_SEQUENCE)
2561-      {
2562-        error = ER_FAILED;
2563-        goto error;
2564-      }
2565-
2566-    child_seq = db_get_set (&amp;val);
2567-  }
2568-     }
2569-   else
2570-     {
2571-       error = ER_SM_INVALID_PROPERTY;
2572-       er_set (ER_ERROR_SEVERITY, ARG_FILE_LINE, error, 0);
2573-       goto error;
2574-     }
2575-   pr_clear_value (&amp;val);
2576- }
2577-
2578-      /* key_count */
2579-      if (has_function_index == 0)
2580- {



2814-  if (expected_size == 0)
2815-    {
2816-      value_p-&gt;sub.count = 0;
2817-      return NO_ERROR;
2818-    }
2819-
2820-  db_value_put_null (&amp;prop_val);
2821-  for (i = 0; i &lt; SM_PROPERTY_NUM_INDEX_FAMILY; i++)
2822-    {
2823-      db_value_put_null (&amp;vals[i]);
2824-    }
2825-
2826-  tp_Sequence.data_readval (buf_p, &amp;prop_val, NULL, expected_size, true, NULL, 0);
2827-  prop_seq_p = db_get_set (&amp;prop_val);
2828-
2829-  for (i = 0; i &lt; SM_PROPERTY_NUM_INDEX_FAMILY; i++)
2830-    {
2831-      if (prop_seq_p != NULL &amp;&amp; (classobj_get_prop (prop_seq_p, property_vars[i].name, &amp;vals[i]) &gt; 0))
2832- {
2833-
2834:   if (DB_VALUE_TYPE (&amp;vals[i]) == DB_TYPE_SEQUENCE)
2835-     {
2836-       property_vars[i].seq = db_get_set (&amp;vals[i]);
2837-     }
2838-
2839-   if (property_vars[i].seq != NULL)
2840-     {
2841-       property_vars[i].size = set_size (property_vars[i].seq) / 2;
2842-       n_size += property_vars[i].size;
2843-     }
2844- }
2845-    }
2846-
2847-  if (n_size &gt; 0)
2848-    {
2849-      subset_p = catcls_allocate_or_value (n_size);
2850-      if (subset_p == NULL)
2851- {
2852-   error = ER_OUT_OF_VIRTUAL_MEMORY;
2853-   goto error;
2854- }

</code></pre>
<pre><code class="language-cpp">heap_file.c
10201-      else
10202- {
10203-   /*
10204-    * A variable attribute
10205-    */
10206-   if (!OR_VAR_IS_NULL (recdes-&gt;data, value-&gt;read_attrepr-&gt;location))
10207-     {
10208-       /*
10209-        * The variable attribute is bound.
10210-        * Find its location through the variable offset attribute table.
10211-        */
10212-       disk_data = ((char *) recdes-&gt;data + OR_VAR_OFFSET (recdes-&gt;data, value-&gt;read_attrepr-&gt;location));
10213-
10214-       disk_bound = true;
10215-       switch (TP_DOMAIN_TYPE (attrepr-&gt;domain))
10216-  {
10217-  case DB_TYPE_BLOB:
10218-  case DB_TYPE_CLOB:
10219-  case DB_TYPE_SET: /* it may be just a little bit fast */
10220-  case DB_TYPE_MULTISET:
10221:  case DB_TYPE_SEQUENCE:
10222-    OR_VAR_LENGTH (disk_length, recdes-&gt;data, value-&gt;read_attrepr-&gt;location,
10223-     attr_info-&gt;read_classrepr-&gt;n_variable);
10224-    break;
10225-  default:
10226-    disk_length = -1; /* remains can read without disk_length */
10227-  }
10228-     }
10229- }
10230-    }
10231-
10232-  /*
10233-   * From now on, I should only use attrepr.. it will point to either
10234-   * a current value or a default one
10235-   */
10236-
10237-  /*
10238-   * Clear/decache any old value
10239-   */
10240-  if (value-&gt;state != HEAP_UNINIT_ATTRVALUE)
10241-    {
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="parser-directory-1"><a class="header" href="#parser-directory-1">Parser Directory</a></h1>
<pre><code class="language-cpp">parse_dbi.c
594-  db_value_clone ((DB_VALUE *) val, &amp;result-&gt;info.value.db_value);
595-  result-&gt;info.value.db_value_is_initialized = true;
596-  result-&gt;info.value.db_value_is_in_workspace = true;
597-
598-  db_type = DB_VALUE_TYPE (val);
599-  result-&gt;type_enum = pt_db_to_type_enum (db_type);
600-
601-  switch (db_type)
602-    {
603-    case DB_TYPE_NULL:
604-      result-&gt;type_enum = PT_TYPE_NULL;
605-      break;
606-    case DB_TYPE_SET:
607-      result-&gt;info.value.data_value.set = pt_set_elements_to_value (parser, val);
608-      pt_add_type_to_set (parser, result-&gt;info.value.data_value.set, &amp;result-&gt;data_type);
609-      break;
610-    case DB_TYPE_MULTISET:
611-      result-&gt;info.value.data_value.set = pt_set_elements_to_value (parser, val);
612-      pt_add_type_to_set (parser, result-&gt;info.value.data_value.set, &amp;result-&gt;data_type);
613-      break;
614:    case DB_TYPE_SEQUENCE:
615-      result-&gt;info.value.data_value.set = pt_set_elements_to_value (parser, val);
616-      pt_add_type_to_set (parser, result-&gt;info.value.data_value.set, &amp;result-&gt;data_type);
617-      break;
618-
619-    case DB_TYPE_INTEGER:
620-      result-&gt;info.value.data_value.i = db_get_int (val);
621-      break;
622-    case DB_TYPE_BIGINT:
623-      result-&gt;info.value.data_value.bigint = db_get_bigint (val);
624-      break;
625-    case DB_TYPE_FLOAT:
626-      result-&gt;info.value.data_value.f = db_get_float (val);
627-      break;
628-    case DB_TYPE_DOUBLE:
629-      result-&gt;info.value.data_value.d = db_get_double (val);
630-      break;
631-    case DB_TYPE_JSON:
632-      result-&gt;data_type = parser_new_node (parser, PT_DATA_TYPE);
633-      if (result-&gt;data_type == NULL)
634- {

</code></pre>
<pre><code class="language-cpp">1585-    case DB_TYPE_TIMESTAMPTZ:
1586-      retval = tp_domain_construct (domain_type, NULL, DB_TIMESTAMPTZ_PRECISION, 0, NULL);
1587-      break;
1588-    case DB_TYPE_DATETIMELTZ:
1589-    case DB_TYPE_DATETIME:
1590-      retval = tp_domain_construct (domain_type, NULL, DB_DATETIME_PRECISION, DB_DATETIME_DECIMAL_SCALE, NULL);
1591-      break;
1592-    case DB_TYPE_DATETIMETZ:
1593-      retval = tp_domain_construct (domain_type, NULL, DB_DATETIMETZ_PRECISION, DB_DATETIME_DECIMAL_SCALE, NULL);
1594-      break;
1595-    case DB_TYPE_BLOB:
1596-    case DB_TYPE_CLOB:
1597-    case DB_TYPE_SUB:
1598-    case DB_TYPE_POINTER:
1599-    case DB_TYPE_ERROR:
1600-    case DB_TYPE_VOBJ:
1601-    case DB_TYPE_OID:
1602-    case DB_TYPE_OBJECT:
1603-    case DB_TYPE_SET:
1604-    case DB_TYPE_MULTISET:
1605:    case DB_TYPE_SEQUENCE:
1606-    case DB_TYPE_MIDXKEY:
1607-    case DB_TYPE_ENUMERATION:
1608-    case DB_TYPE_JSON:
1609-      retval = tp_domain_construct (domain_type, (DB_OBJECT *) 0, 0, 0, (TP_DOMAIN *) 0);
1610-      break;
1611-
1612-    case DB_TYPE_NUMERIC:
1613-      retval = tp_domain_construct (domain_type, NULL, DB_DEFAULT_NUMERIC_PRECISION, DB_DEFAULT_NUMERIC_SCALE, NULL);
1614-      break;
1615-
1616-    case DB_TYPE_CHAR:
1617-    case DB_TYPE_NCHAR:
1618-    case DB_TYPE_BIT:
1619-    case DB_TYPE_VARCHAR:
1620-    case DB_TYPE_VARNCHAR:
1621-    case DB_TYPE_VARBIT:
1622-      /* Note that we assume that some other force is going to come in and repair the precision of the destination of
1623-       * this domain is for the schema manager.  Might be a problem . . . */
1624-      retval = tp_domain_construct (domain_type, NULL, TP_FLOATING_PRECISION_VALUE, 0, NULL);
1625-      break;
</code></pre>
<pre><code class="language-cpp">1904-      precision = dt-&gt;info.data_type.precision;
1905-      codeset = dt-&gt;info.data_type.units;
1906-      collation_id = dt-&gt;info.data_type.collation_id;
1907-      assert (collation_id &gt;= 0);
1908-      collation_flag = dt-&gt;info.data_type.collation_flag;
1909-      break;
1910-
1911-    case DB_TYPE_BIT:
1912-    case DB_TYPE_VARBIT:
1913-      precision = dt-&gt;info.data_type.precision;
1914-      codeset = dt-&gt;info.data_type.units;
1915-      break;
1916-
1917-    case DB_TYPE_NUMERIC:
1918-      precision = dt-&gt;info.data_type.precision;
1919-      scale = dt-&gt;info.data_type.dec_precision;
1920-      break;
1921-
1922-    case DB_TYPE_SET:
1923-    case DB_TYPE_MULTISET:
1924:    case DB_TYPE_SEQUENCE:
1925-    case DB_TYPE_MIDXKEY:
1926-      return pt_node_to_db_domain (parser, dt, class_name);
1927-
1928-    case DB_TYPE_ENUMERATION:
1929-      if (pt_get_enumeration_from_data_type (parser, dt, &amp;enumeration) != NO_ERROR)
1930- {
1931-   return NULL;
1932- }
1933-      codeset = dt-&gt;info.data_type.units;
1934-      collation_id = dt-&gt;info.data_type.collation_id;
1935-      assert (collation_id &gt;= 0);
1936-      collation_flag = dt-&gt;info.data_type.collation_flag;
1937-      break;
1938-
1939-    case DB_TYPE_NULL:
1940-    case DB_TYPE_DB_VALUE:
1941-    case DB_TYPE_VARIABLE:
1942-    case DB_TYPE_TABLE:
1943-    case DB_TYPE_RESULTSET:
1944-      break;



2125-
2126-    case DB_TYPE_VARCHAR:
2127-    case DB_TYPE_CHAR:
2128-    case DB_TYPE_NCHAR:
2129-    case DB_TYPE_VARNCHAR:
2130-    case DB_TYPE_BIT:
2131-    case DB_TYPE_VARBIT:
2132-      precision = dt-&gt;info.data_type.precision;
2133-      codeset = dt-&gt;info.data_type.units;
2134-      collation_id = dt-&gt;info.data_type.collation_id;
2135-      collation_flag = dt-&gt;info.data_type.collation_flag;
2136-      break;
2137-
2138-    case DB_TYPE_NUMERIC:
2139-      precision = dt-&gt;info.data_type.precision;
2140-      scale = dt-&gt;info.data_type.dec_precision;
2141-      break;
2142-
2143-    case DB_TYPE_SET:
2144-    case DB_TYPE_MULTISET:
2145:    case DB_TYPE_SEQUENCE:
2146-      while (dt &amp;&amp; (error == NO_ERROR))
2147- {
2148-   domain = pt_data_type_to_db_domain (parser, dt, NULL);
2149-   if (domain)
2150-     {
2151-       error = tp_domain_add (&amp;setdomain, domain);
2152-     }
2153-   dt = dt-&gt;next;
2154- }
2155-      if (error == NO_ERROR)
2156- {
2157-   retval = tp_domain_construct (domain_type, (DB_OBJECT *) 0, 0, 0, setdomain);
2158- }
2159-      return retval;
2160-
2161-    case DB_TYPE_ENUMERATION:
2162-      if (pt_get_enumeration_from_data_type (parser, dt, &amp;enumeration) != NO_ERROR)
2163- {
2164-   return NULL;
2165- }

</code></pre>
<pre><code class="language-cpp">2242- */
2243-DB_DOMAIN *
2244-pt_node_to_db_domain (PARSER_CONTEXT * parser, PT_NODE * node, const char *class_name)
2245-{
2246-  int error = NO_ERROR, natts = 0;
2247-  DB_DOMAIN *retval = (DB_DOMAIN *) 0;
2248-  DB_DOMAIN *domain = (DB_DOMAIN *) 0;
2249-  DB_DOMAIN *setdomain = (DB_DOMAIN *) 0;
2250-  DB_TYPE domain_type;
2251-  PT_NODE *dt;
2252-
2253-  CAST_POINTER_TO_NODE (node);
2254-
2255-  if (node-&gt;data_type)
2256-    {
2257-      domain_type = pt_type_enum_to_db (node-&gt;type_enum);
2258-      switch (domain_type)
2259- {
2260- case DB_TYPE_SET:
2261- case DB_TYPE_MULTISET:
2262: case DB_TYPE_SEQUENCE:
2263- case DB_TYPE_MIDXKEY:
2264-   /* Recursively build the setdomain */
2265-   dt = node-&gt;data_type;
2266-   while (dt &amp;&amp; (error == NO_ERROR))
2267-     {
2268-       domain = pt_data_type_to_db_domain (parser, dt, class_name);
2269-       if (domain)
2270-  {
2271-    if (domain_type == DB_TYPE_MIDXKEY)
2272-      {
2273-        error = tp_domain_attach (&amp;setdomain, domain);
2274-        natts++;
2275-      }
2276-    else
2277-      {
2278-        error = tp_domain_add (&amp;setdomain, domain);
2279-      }
2280-  }
2281-       else
2282-  {



2376-      db_type = DB_TYPE_VARCHAR;
2377-      break;
2378-
2379-    case PT_TYPE_JSON:
2380-      db_type = DB_TYPE_JSON;
2381-      break;
2382-
2383-    case PT_TYPE_OBJECT:
2384-      db_type = DB_TYPE_OBJECT;
2385-      break;
2386-
2387-    case PT_TYPE_SET:
2388-      db_type = DB_TYPE_SET;
2389-      break;
2390-
2391-    case PT_TYPE_MULTISET:
2392-      db_type = DB_TYPE_MULTISET;
2393-      break;
2394-
2395-    case PT_TYPE_SEQUENCE:
2396:      db_type = DB_TYPE_SEQUENCE;
2397-      break;
2398-
2399-    case PT_TYPE_MIDXKEY:
2400-      db_type = DB_TYPE_MIDXKEY;
2401-      break;
2402-
2403-    case PT_TYPE_NUMERIC:
2404-      db_type = DB_TYPE_NUMERIC;
2405-      break;
2406-    case PT_TYPE_NCHAR:
2407-      db_type = DB_TYPE_NCHAR;
2408-      break;
2409-    case PT_TYPE_VARNCHAR:
2410-      db_type = DB_TYPE_VARNCHAR;
2411-      break;
2412-    case PT_TYPE_BIT:
2413-      db_type = DB_TYPE_BIT;
2414-      break;
2415-    case PT_TYPE_VARBIT:
2416-      db_type = DB_TYPE_VARBIT;



2648-      pt_type = PT_TYPE_DATETIMETZ;
2649-      break;
2650-    case DB_TYPE_DATETIMELTZ:
2651-      pt_type = PT_TYPE_DATETIMELTZ;
2652-      break;
2653-
2654-    case DB_TYPE_MONETARY:
2655-      pt_type = PT_TYPE_MONETARY;
2656-      break;
2657-
2658-    case DB_TYPE_OBJECT:
2659-      pt_type = PT_TYPE_OBJECT;
2660-      break;
2661-
2662-    case DB_TYPE_SET:
2663-      pt_type = PT_TYPE_SET;
2664-      break;
2665-    case DB_TYPE_MULTISET:
2666-      pt_type = PT_TYPE_MULTISET;
2667-      break;
2668:    case DB_TYPE_SEQUENCE:
2669-      pt_type = PT_TYPE_SEQUENCE;
2670-      break;
2671-
2672-    case DB_TYPE_CHAR:
2673-      pt_type = PT_TYPE_CHAR;
2674-      break;
2675-    case DB_TYPE_STRING:
2676-      pt_type = PT_TYPE_VARCHAR;
2677-      break;
2678-    case DB_TYPE_NCHAR:
2679-      pt_type = PT_TYPE_NCHAR;
2680-      break;
2681-    case DB_TYPE_VARNCHAR:
2682-      pt_type = PT_TYPE_VARNCHAR;
2683-      break;
2684-    case DB_TYPE_BIT:
2685-      pt_type = PT_TYPE_BIT;
2686-      break;
2687-    case DB_TYPE_VARBIT:
2688-      pt_type = PT_TYPE_VARBIT;



2859-    case DB_TYPE_RESULTSET:
2860-      /*
2861-       * Nothing more to do for these guys; their type is completely
2862-       * described by the type_enum.  Why don't we care about precision
2863-       * and dec_precision for these, if we care about DB_TYPE_INT?
2864-       */
2865-      break;
2866-
2867-    case DB_TYPE_VARIABLE:
2868-    case DB_TYPE_SUB:
2869-    case DB_TYPE_POINTER:
2870-    case DB_TYPE_ERROR:
2871-    case DB_TYPE_OID:
2872-    case DB_TYPE_DB_VALUE:
2873-      PT_INTERNAL_ERROR (parser, "type assignment");
2874-      node = NULL;
2875-      break;
2876-
2877-    case DB_TYPE_SET:
2878-    case DB_TYPE_MULTISET:
2879:    case DB_TYPE_SEQUENCE:
2880-      dt = pt_bind_set_type (parser, node, val, data_type_added);
2881-      break;
2882-
2883-      /*
2884-       * All of the remaining cases need to tack a new DATA_TYPE node
2885-       * onto the incoming node.  Most of the cases allocate it
2886-       * themselves, but not all.
2887-       */
2888-
2889-    case DB_TYPE_MONETARY:
2890-      dt = parser_new_node (parser, PT_DATA_TYPE);
2891-      if (dt)
2892- {
2893-   dt-&gt;type_enum = node-&gt;type_enum;
2894-   dt-&gt;info.data_type.precision = 0;
2895-   dt-&gt;info.data_type.dec_precision = 0;
2896-   dt-&gt;info.data_type.units = db_value_get_monetary_currency (val);
2897- }
2898-      break;
2899-
</code></pre>
<pre><code class="language-cpp">type_checking.c
13915-    PT_ERRORmf2 (parser, o2, MSGCAT_SET_PARSER_SEMANTIC, MSGCAT_SEMANTIC_CANT_COERCE_TO,
13916-          parser_print_tree (parser, o2), pt_show_type_enum (rTyp));
13917-
13918-    return 0;
13919-  }
13920-       else
13921-  {
13922-    pr_clear_value (arg2);
13923-    *arg2 = tmp_val;
13924-  }
13925-     }
13926- }
13927-
13928-      switch (op)
13929- {
13930- case PT_PLUS:
13931-   switch (typ)
13932-     {
13933-     case DB_TYPE_SET:
13934-     case DB_TYPE_MULTISET:
13935:     case DB_TYPE_SEQUENCE:
13936-       if (!pt_union_sets (parser, domain, arg1, arg2, result, o2))
13937-  {
13938-    return 0; /* set union failed */
13939-  }
13940-       break;
13941-
13942-     case DB_TYPE_CHAR:
13943-     case DB_TYPE_NCHAR:
13944-     case DB_TYPE_VARCHAR:
13945-     case DB_TYPE_VARNCHAR:
13946-     case DB_TYPE_BIT:
13947-     case DB_TYPE_VARBIT:
13948-       if (db_string_concatenate (arg1, arg2, result, &amp;truncation) &lt; 0 || truncation != DATA_STATUS_OK)
13949-  {
13950-    PT_ERRORc (parser, o1, er_msg ());
13951-    return 0;
13952-  }
13953-       break;
13954-
13955-     case DB_TYPE_INTEGER:



14978-        {
14979-   PT_ERRORm (parser, o2, MSGCAT_SET_PARSER_SEMANTIC, MSGCAT_SEMANTIC_DATE_UNDERFLOW);
14980-   return 0;
14981-        }
14982-    }
14983-  db_date_decode (&amp;result_date, &amp;month, &amp;day, &amp;year);
14984-  db_make_date (result, month, day, year);
14985-       }
14986-       break;
14987-
14988-     default:
14989-       return 0;
14990-     }
14991-   break;
14992-
14993- case PT_TIMES:
14994-   switch (typ)
14995-     {
14996-     case DB_TYPE_SET:
14997-     case DB_TYPE_MULTISET:
14998:     case DB_TYPE_SEQUENCE:
14999-       if (!pt_product_sets (parser, domain, arg1, arg2, result, o2))
15000-  {
15001-    return 0; /* set union failed */
15002-  }
15003-       break;
15004-
15005-     case DB_TYPE_INTEGER:
15006-       {
15007-  /* NOTE that we need volatile to prevent optimizer from generating division expression as
15008-   * multiplication.
15009-   */
15010-  volatile int i1, i2, itmp;
15011-
15012-  i1 = db_get_int (arg1);
15013-  i2 = db_get_int (arg2);
15014-  itmp = i1 * i2;
15015-  if (OR_CHECK_MULT_OVERFLOW (i1, i2, itmp))
15016-    {
15017-      goto overflow;
15018-    }

</code></pre>
<pre><code class="language-cpp">xasl_generation.c
6906- {
6907-   args = pt_to_regu_variable_list (parser, function-&gt;info.function.arg_list, UNBOX_AS_TABLE, NULL, NULL);
6908- }
6909-      else
6910- {
6911-   args = pt_to_regu_variable_list (parser, function-&gt;info.function.arg_list, UNBOX_AS_VALUE, NULL, NULL);
6912- }
6913-
6914-      switch (function-&gt;info.function.function_type)
6915- {
6916- case F_SET:
6917- case F_TABLE_SET:
6918-   result_type = DB_TYPE_SET;
6919-   break;
6920- case F_MULTISET:
6921- case F_TABLE_MULTISET:
6922-   result_type = DB_TYPE_MULTISET;
6923-   break;
6924- case F_SEQUENCE:
6925- case F_TABLE_SEQUENCE:
6926:   result_type = DB_TYPE_SEQUENCE;
6927-   break;
6928- case F_MIDXKEY:
6929-   result_type = DB_TYPE_MIDXKEY;
6930-   break;
6931- case F_VID:
6932-   result_type = DB_TYPE_VOBJ;
6933-   break;
6934- case F_GENERIC:
6935-   result_type = pt_node_to_db_type (function);
6936-   break;
6937- case F_CLASS_OF:
6938-   result_type = DB_TYPE_OID;
6939-   break;
6940- case F_INSERT_SUBSTRING:
6941- case F_ELT:
6942- case F_REGEXP_COUNT:
6943- case F_REGEXP_INSTR:
6944- case F_REGEXP_LIKE:
6945- case F_REGEXP_REPLACE:
6946- case F_REGEXP_SUBSTR:

</code></pre>
<pre><code class="language-cpp">10747-
10748-    case PT_NAME:
10749-      if (rhs-&gt;info.name.meta_class != PT_PARAMETER)
10750- {
10751-   goto error;
10752- }
10753-      /* FALLTHRU */
10754-
10755-    case PT_VALUE:
10756-      p = (rhs-&gt;node_type == PT_NAME) ? pt_find_value_of_label (rhs-&gt;info.name.original) : &amp;rhs-&gt;info.value.db_value;
10757-
10758-      if (p == NULL)
10759- {
10760-   goto error;
10761- }
10762-
10763-      switch (DB_VALUE_TYPE (p))
10764- {
10765- case DB_TYPE_SET:
10766- case DB_TYPE_MULTISET:
10767: case DB_TYPE_SEQUENCE:
10768-   break;
10769- default:
10770-   goto error;
10771- }
10772-
10773-      db_collectionp = db_get_collection (p);
10774-      n_elem = db_col_size (db_collectionp);
10775-      break;
10776-
10777-    case PT_HOST_VAR:
10778-      p = pt_value_to_db (parser, rhs);
10779-      if (p == NULL)
10780- {
10781-   goto error;
10782- }
10783-
10784-      switch (DB_VALUE_TYPE (p))
10785- {
10786- case DB_TYPE_SET:
10787- case DB_TYPE_MULTISET:
10788: case DB_TYPE_SEQUENCE:
10789-   break;
10790- default:
10791-   goto error;
10792- }
10793-
10794-      db_collectionp = db_get_collection (p);
10795-      n_elem = db_col_size (db_collectionp);
10796-      break;
10797-
10798-    default:
10799-      goto error;
10800-    }
10801-
10802-  if (n_elem &lt;= 0)
10803-    {
10804-      goto error;
10805-    }
10806-
10807-  /* allocate regu variable list and sequence value list */
10808-  regu_array_alloc (&amp;regu_var_list, n_elem);

</code></pre>
<pre><code class="language-cpp">parse_tree_cl.c
2593-  int error = NO_ERROR;
2594-  unsigned int save_custom = parser-&gt;custom_print;
2595-
2596-  parser_block_allocator alloc (parser);
2597-  string_buffer sb (alloc);
2598-
2599-  db_value_printer printer (sb);
2600-  if (val == NULL)
2601-    {
2602-      return NULL;
2603-    }
2604-
2605-  /* set custom_print here so describe_data() will know to pad bit strings to full bytes */
2606-  parser-&gt;custom_print = parser-&gt;custom_print | PT_PAD_BYTE;
2607-  switch (DB_VALUE_TYPE (val))
2608-    {
2609-    case DB_TYPE_SET:
2610-    case DB_TYPE_MULTISET:
2611-      sb ("%s", pt_show_type_enum (pt_db_to_type_enum (DB_VALUE_TYPE (val))));
2612-      /* fall thru */
2613:    case DB_TYPE_SEQUENCE:
2614-      sb ("{");
2615-
2616-      size = db_set_size (db_get_set ((DB_VALUE *) val));
2617-      if (size &gt; 0)
2618- {
2619-   error = db_set_get (db_get_set ((DB_VALUE *) val), 0, &amp;element);
2620-   printer.describe_value (&amp;element);
2621-   for (i = 1; i &lt; size; i++)
2622-     {
2623-       error = db_set_get (db_get_set ((DB_VALUE *) val), i, &amp;element);
2624-       sb (", ");
2625-       printer.describe_value (&amp;element);
2626-     }
2627- }
2628-      sb ("}");
2629-      break;
2630-
2631-    case DB_TYPE_OBJECT:
2632-      /* no printable representation!, should not get here */
2633-      sb ("NULL");

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="base"><a class="header" href="#base">base</a></h1>
<pre><code class="language-cpp">memory_hash.c
641-   {
642-     DB_DATETIMETZ *dt_tz;
643-     dt_tz = db_get_datetimetz (val);
644-     hash = (unsigned int) (dt_tz-&gt;datetime.date ^ dt_tz-&gt;datetime.time);
645-   }
646-   break;
647- case DB_TYPE_DATE:
648-   {
649-     DB_DATE *date = db_get_date (val);
650-     hash = (unsigned int) (*date);
651-     break;
652-   }
653- case DB_TYPE_MONETARY:
654-   {
655-     DB_MONETARY *mon = db_get_monetary (val);
656-     hash = (unsigned int) mon-&gt;amount;
657-     break;
658-   }
659- case DB_TYPE_SET:
660- case DB_TYPE_MULTISET:
661: case DB_TYPE_SEQUENCE:
662-   db_make_null (&amp;t_val);
663-   {
664-     DB_SET *set;
665-     set = db_get_set (val);
666-     if (set_get_element (set, 0, &amp;t_val) == NO_ERROR)
667-       {
668-  hash = mht_valhash (&amp;t_val, ht_size);
669-  (void) pr_clear_value (&amp;t_val);
670-  t_n = set_size (set);
671-  if ((t_n &gt; 0) &amp;&amp; set_get_element (set, t_n - 1, &amp;t_val) == NO_ERROR)
672-    {
673-      hash += mht_valhash (&amp;t_val, ht_size);
674-      (void) pr_clear_value (&amp;t_val);
675-    }
676-       }
677-   }
678-   break;
679- case DB_TYPE_OBJECT:
680-   hash = GET_PTR_FOR_HASH (db_get_object (val));
681-   break;
</code></pre>
<pre><code class="language-cpp">
2416-    /* only the trailing ASCII space is ignored; the hashing for other characters depend on collation */
2417-    if (ptr[i] != 0x20)
2418-      {
2419-        break;
2420-      }
2421-  }
2422-       i++;
2423-     }
2424-   if (!ptr || ptr[0] == 0 || i &lt;= 0)
2425-     {
2426-       hashcode = 0;
2427-     }
2428-   else
2429-     {
2430-       hashcode = MHT2STR_COLL (db_get_string_collation (val), (unsigned char *) ptr, i);
2431-       hashcode %= ht_size;
2432-     }
2433-   break;
2434- case DB_TYPE_SET:
2435- case DB_TYPE_MULTISET:
2436: case DB_TYPE_SEQUENCE:
2437- case DB_TYPE_VOBJ:
2438-   {
2439-     int size = val-&gt;data.set-&gt;disk_size / 4;
2440-     unsigned int x = 0;
2441-     int i;
2442-
2443-     for (i = 0; i &lt; size; i++)
2444-       {
2445-  x ^= (unsigned int) (val-&gt;data.set-&gt;disk_set[i * 4]);
2446-       }
2447-
2448-     hashcode = mht_get_shiftmult32 (x, ht_size);
2449-   }
2450-   break;
2451- case DB_TYPE_ENUMERATION:
2452-   hashcode = mht_get_shiftmult32 (val-&gt;data.enumeration.short_val, ht_size);
2453-   break;
2454- case DB_TYPE_JSON:
2455-   {
2456-     char *json_body = NULL;

</code></pre>
<pre><code class="language-cpp">object_representation_sr.c
1914-  index-&gt;type = type;
1915-  index-&gt;fk = NULL;
1916-  index-&gt;attrs_prefix_length = NULL;
1917-  index-&gt;filter_predicate = NULL;
1918-  index-&gt;func_index_info = NULL;
1919-  index-&gt;index_status = OR_NO_INDEX;
1920-
1921-  /*
1922-   * For each attribute ID in the set,
1923-   *   Extract the attribute ID,
1924-   *   Find the matching attribute and insert the pointer into the array.
1925-   */
1926-
1927-  /* Remember that the attribute IDs start in the second position. */
1928-  e = 1;
1929-
1930-  for (i = 0; i &lt; att_cnt; i++)
1931-    {
1932-      if (set_get_element_nocopy (constraint_seq, e++, &amp;att_val) == NO_ERROR)
1933- {
1934:   if (DB_VALUE_TYPE (&amp;att_val) == DB_TYPE_SEQUENCE)
1935-     {
1936-       break;
1937-     }
1938-
1939-   att_id = db_get_int (&amp;att_val);
1940-   if (IS_DEDUPLICATE_KEY_ATTR_ID (att_id))
1941-     {
1942-       index-&gt;atts[index-&gt;n_atts] = (OR_ATTRIBUTE *) dk_find_or_deduplicate_key_attribute (att_id);
1943-       (index-&gt;n_atts)++;
1944-     }
1945-   else
1946-     {
1947-       for (j = 0, att = rep-&gt;attributes; j &lt; rep-&gt;n_attributes; j++, att++)
1948-  {
1949-    if (att-&gt;id == att_id)
1950-      {
1951-        index-&gt;atts[index-&gt;n_atts] = att;
1952-        (index-&gt;n_atts)++;
1953-        break;
1954-      }
</code></pre>
<pre><code class="language-cpp">
1962-   index-&gt;asc_desc[i] = db_get_int (&amp;att_val);
1963- }
1964-    }
1965-  index-&gt;btname = strdup (cons_name);
1966-
1967-  /* Get the index status. */
1968-  set_get_element_nocopy (constraint_seq, seq_size - 2, &amp;stat_val);
1969-  index-&gt;index_status = (OR_INDEX_STATUS) (db_get_int (&amp;stat_val));
1970-
1971-  if (type == BTREE_FOREIGN_KEY)
1972-    {
1973-      if (set_get_element_nocopy (constraint_seq, seq_size - 3, &amp;att_val) == NO_ERROR)
1974- {
1975-   or_install_btids_foreign_key (cons_name, db_get_set (&amp;att_val), index);
1976- }
1977-    }
1978-  else if (type == BTREE_PRIMARY_KEY)
1979-    {
1980-      if (set_get_element_nocopy (constraint_seq, seq_size - 3, &amp;att_val) == NO_ERROR)
1981- {
1982:   if (DB_VALUE_TYPE (&amp;att_val) == DB_TYPE_SEQUENCE)
1983-     {
1984-       or_install_btids_foreign_key_ref (db_get_set (&amp;att_val), index);
1985-     }
1986- }
1987-    }
1988-  else
1989-    {
1990-      if (set_get_element_nocopy (constraint_seq, seq_size - 3, &amp;att_val) == NO_ERROR)
1991- {
1992:   if (DB_VALUE_TYPE (&amp;att_val) == DB_TYPE_SEQUENCE)
1993-     {
1994-       DB_SEQ *seq = db_get_set (&amp;att_val);
1995-       DB_VALUE val;
1996-
1997-       if (set_get_element_nocopy (seq, 0, &amp;val) == NO_ERROR)
1998-  {
1999-    if (DB_VALUE_TYPE (&amp;val) == DB_TYPE_INTEGER)
2000-      {
2001-        or_install_btids_prefix_length (db_get_set (&amp;att_val), index, att_cnt);
2002-      }
2003:    else if (DB_VALUE_TYPE (&amp;val) == DB_TYPE_SEQUENCE)
2004-      {
2005-        DB_VALUE avalue;
2006-        DB_SET *child_seq = db_get_set (&amp;val);
2007-        int seq_size = set_size (seq);
2008-        int flag;
2009-
2010-        j = 0;
2011-        while (true)
2012-   {
2013-     flag = 0;
2014-     if (set_get_element_nocopy (child_seq, 0, &amp;avalue) != NO_ERROR)
2015-       {
2016-         goto next_child;
2017-       }
2018-
2019-     if (DB_IS_NULL (&amp;avalue) || DB_VALUE_TYPE (&amp;avalue) != DB_TYPE_STRING)
2020-       {
2021-         goto next_child;
2022-       }
2023-
2024-     if (strcmp (db_get_string (&amp;avalue), SM_FILTER_INDEX_ID) == 0)
2025-       {
2026-         flag = 0x01;
2027-       }
2028-     else if (strcmp (db_get_string (&amp;avalue), SM_FUNCTION_INDEX_ID) == 0)
2029-       {
2030-         flag = 0x02;
2031-       }
2032-     else if (strcmp (db_get_string (&amp;avalue), SM_PREFIX_INDEX_ID) == 0)
2033-       {
2034-         flag = 0x03;
2035-       }
2036-
2037-     if (set_get_element_nocopy (child_seq, 1, &amp;avalue) != NO_ERROR)
2038-       {
2039-         goto next_child;
2040-       }
2041-
2042:     if (DB_VALUE_TYPE (&amp;avalue) != DB_TYPE_SEQUENCE)
2043-       {
2044-         goto next_child;
2045-       }
2046-
2047-     switch (flag)
2048-       {
2049-       case 0x01:
2050-         or_install_btids_filter_pred (db_get_set (&amp;avalue), index);
2051-         break;
2052-
2053-       case 0x02:
2054-         or_install_btids_function_info (db_get_set (&amp;avalue), index);
2055-         break;
2056-
2057-       case 0x03:
2058-         or_install_btids_prefix_length (db_get_set (&amp;avalue), index, att_cnt);
2059-         break;
2060-
2061-       default:
2062-         break;
2063-       }
2064-
2065-   next_child:
2066-     j++;
2067-     if (j &gt;= seq_size)
2068-       {
2069-         break;
2070-       }
2071-
2072-     if (set_get_element_nocopy (seq, j, &amp;val) != NO_ERROR)
2073-       {
2074-         continue;
2075-       }
2076-
2077:     if (DB_VALUE_TYPE (&amp;val) != DB_TYPE_SEQUENCE)
2078-       {
2079-         continue;
2080-       }
2081-
2082-     child_seq = db_get_set (&amp;val);
2083-   }
2084-
2085-        if (index-&gt;func_index_info)
2086-   {
2087-     /* function index and prefix length not allowed, yet */
2088-     index-&gt;attrs_prefix_length = (int *) malloc (sizeof (int) * att_cnt);
2089-     if (index-&gt;attrs_prefix_length == NULL)
2090-       {
2091-         er_set (ER_ERROR_SEVERITY, ARG_FILE_LINE, ER_OUT_OF_VIRTUAL_MEMORY, 1,
2092-          sizeof (int) * att_cnt);
2093-         return;
2094-       }
2095-     for (i = 0; i &lt; att_cnt; i++)
2096-       {
2097-         index-&gt;attrs_prefix_length[i] = -1;
</code></pre>
<pre><code class="language-cpp">
2297-    {SM_PROPERTY_UNIQUE, NULL, BTREE_UNIQUE, 0},
2298-    {SM_PROPERTY_REVERSE_UNIQUE, NULL, BTREE_REVERSE_UNIQUE, 0},
2299-    {SM_PROPERTY_INDEX, NULL, BTREE_INDEX, 0},
2300-    {SM_PROPERTY_REVERSE_INDEX, NULL, BTREE_REVERSE_INDEX, 0}
2301-  };
2302-
2303-  DB_VALUE vals[SM_PROPERTY_NUM_INDEX_FAMILY];
2304-  int i;
2305-  int n_btids;
2306-
2307-  /*
2308-   *  The first thing to do is to determine how many unique and index
2309-   *  BTIDs we have.  We need this up front so that we can allocate
2310-   *  the OR_INDEX structure in the class (rep).
2311-   */
2312-  n_btids = 0;
2313-  for (i = 0; i &lt; SM_PROPERTY_NUM_INDEX_FAMILY; i++)
2314-    {
2315-      if (props != NULL &amp;&amp; or_cl_get_prop_nocopy (props, property_vars[i].name, &amp;vals[i]))
2316- {
2317:   if (DB_VALUE_TYPE (&amp;vals[i]) == DB_TYPE_SEQUENCE)
2318-     {
2319-       property_vars[i].seq = db_get_set (&amp;vals[i]);
2320-     }
2321-
2322-   if (property_vars[i].seq)
2323-     {
2324-       property_vars[i].length = set_size (property_vars[i].seq);
2325-       n_btids += property_vars[i].length;
2326-     }
2327- }
2328-    }
2329-
2330-  n_btids /= 2;
2331-
2332-  if (n_btids &gt; 0)
2333-    {
2334-      rep-&gt;indexes = (OR_INDEX *) malloc (sizeof (OR_INDEX) * n_btids);
2335-      if (rep-&gt;indexes == NULL)
2336- {
2337-   er_set (ER_ERROR_SEVERITY, ARG_FILE_LINE, ER_OUT_OF_VIRTUAL_MEMORY, 1, sizeof (OR_INDEX) * n_btids);
</code></pre>
<pre><code class="language-cpp">
2346-    {
2347-      if (property_vars[i].seq)
2348- {
2349-   int j;
2350-   DB_VALUE ids_val, cons_name_val;
2351-   DB_SEQ *ids_seq;
2352-   const char *cons_name = NULL;
2353-   int error = NO_ERROR;
2354-
2355-   for (j = 0; j &lt; property_vars[i].length &amp;&amp; error == NO_ERROR; j += 2)
2356-     {
2357-       error = set_get_element_nocopy (property_vars[i].seq, j, &amp;cons_name_val);
2358-       if (error == NO_ERROR)
2359-  {
2360-    cons_name = db_get_string (&amp;cons_name_val);
2361-  }
2362-
2363-       error = set_get_element_nocopy (property_vars[i].seq, j + 1, &amp;ids_val);
2364-       if (error == NO_ERROR &amp;&amp; cons_name != NULL)
2365-  {
2366:    if (DB_VALUE_TYPE (&amp;ids_val) == DB_TYPE_SEQUENCE)
2367-      {
2368-        ids_seq = db_get_set (&amp;ids_val);
2369-        or_install_btids_constraint (rep, ids_seq, property_vars[i].type, cons_name);
2370-      }
2371-  }
2372-     }
2373- }
2374-    }
2375-}
2376-
2377-/*
2378- * or_get_current_representation () - build an OR_CLASSREP structure for the
2379- *                                    most recent representation
2380- *   return: disk representation structure
2381- *   record(in): disk record
2382- *   do_indexes(in):
2383- *
2384- * Note: This is similar to the old function orc_diskrep_from_record, but is
2385- *       a little simpler now that we don't need to maintain a separate
2386- *       list for the fixed and variable length attributes.
</code></pre>
<pre><code class="language-cpp">
2574-
2575-      /* get the default value - constant, this could be using a new DB_VALUE ? */
2576-      if (original_val_len &gt; 0)
2577- {
2578-   if (or_get_default_value (att, original_val_ptr, original_val_len) == 0)
2579-     {
2580-       goto error_cleanup;
2581-     }
2582- }
2583-
2584-      /* get the default expression. */
2585-      classobj_initialize_default_expr (&amp;att-&gt;current_default_value.default_expr);
2586-      att-&gt;on_update_expr = DB_DEFAULT_NONE;
2587-      if (properties_val_len &gt; 0)
2588- {
2589-   db_make_null (&amp;properties_val);
2590-   db_make_null (&amp;def_expr);
2591-   db_make_null (&amp;def_expr_op);
2592-   db_make_null (&amp;def_expr_format);
2593-
2594:   or_get_value (&amp;buf, &amp;properties_val, tp_domain_resolve_default (DB_TYPE_SEQUENCE), properties_val_len, true);
2595-   att_props = db_get_set (&amp;properties_val);
2596-
2597-   if (att_props != NULL &amp;&amp; classobj_get_prop (att_props, "default_expr", &amp;def_expr) &gt; 0)
2598-     {
2599-       /* We have two cases: simple and complex expression. */
2600:       if (DB_VALUE_TYPE (&amp;def_expr) == DB_TYPE_SEQUENCE)
2601-  {
2602-    /*
2603-     * We can't have an attribute with default expression and default value simultaneously. However,
2604-     * in some situations attr-&gt;default_value.value contains the value of default expression. This happens
2605-     * when the client executes the query on broker side and use attr-&gt;default_value.value to cache
2606-     * the default expression value. Then the broker can modify the schema and send to server the default
2607-     * expression and its cached value. Another option may be to clear default value on broker side,
2608-     * but may lead to inconsistency.
2609-     */
2610-
2611-    /* Currently, we allow only (T_TO_CHAR(int), default_expr(int), default_expr_format(string)) */
2612-    assert (set_size (db_get_set (&amp;def_expr)) == 3);
2613-
2614-    def_expr_set = db_get_set (&amp;def_expr);
2615-
2616-    /* get and cache default expression operator - op of expr */
2617-    if (set_get_element_nocopy (def_expr_set, 0, &amp;def_expr_op) != NO_ERROR)
2618-      {
2619-        assert (false);
2620-        pr_clear_value (&amp;def_expr);
</code></pre>
<pre><code class="language-cpp">
3539-      error = set_get_element_nocopy (setref, i, &amp;value);
3540-      if (error != NO_ERROR || DB_VALUE_TYPE (&amp;value) != DB_TYPE_STRING)
3541- {
3542-   goto error_exit;
3543- }
3544-
3545-      prop_name = db_get_string (&amp;value);
3546-      if (prop_name == NULL)
3547- {
3548-   goto error_exit;
3549- }
3550-
3551-      if (strcmp (prop_name, SM_PROPERTY_PRIMARY_KEY) != 0 &amp;&amp; strcmp (prop_name, SM_PROPERTY_UNIQUE) != 0
3552-   &amp;&amp; strcmp (prop_name, SM_PROPERTY_REVERSE_UNIQUE) != 0 &amp;&amp; strcmp (prop_name, SM_PROPERTY_INDEX) != 0
3553-   &amp;&amp; strcmp (prop_name, SM_PROPERTY_REVERSE_INDEX) != 0 &amp;&amp; strcmp (prop_name, SM_PROPERTY_FOREIGN_KEY) != 0)
3554- {
3555-   continue;
3556- }
3557-
3558-      error = set_get_element_nocopy (setref, i + 1, &amp;value);
3559:      if (error != NO_ERROR || DB_VALUE_TYPE (&amp;value) != DB_TYPE_SEQUENCE)
3560- {
3561-   goto error_exit;
3562- }
3563-
3564-      /* this sequence is an alternating pair of constraint name &amp; info sequence, as by: { name, { BTID, [att_name,
3565-       * asc_dsc], {fk_info | pk_info | prefix_length}, filter_predicate, comment}, name, { BTID, [att_name, asc_dsc],
3566-       * {fk_info | pk_info | prefix_length}, filter_predicate, comment}, ... } */
3567-      props = db_get_set (&amp;value);
3568-      len = set_size (props);
3569-      for (j = 0; j &lt; len; j += 2)
3570- {
3571-   /* get the name */
3572-   if (set_get_element_nocopy (props, j, &amp;uvalue) || DB_VALUE_TYPE (&amp;uvalue) != DB_TYPE_STRING)
3573-     {
3574-       goto error_exit;
3575-     }
3576-
3577-   if (strcmp (constraint_name, db_get_string (&amp;uvalue)) != 0)
3578-     {
3579-       continue;
3580-     }
3581-
3582-   found = true;
3583-
3584-   if (set_get_element_nocopy (props, j + 1, &amp;uvalue))
3585-     {
3586-       goto error_exit;
3587-     }
3588:   if (DB_VALUE_TYPE (&amp;uvalue) != DB_TYPE_SEQUENCE)
3589-     {
3590-       goto error_exit;
3591-     }
3592-
3593-   info = db_get_set (&amp;uvalue);
3594-   info_len = set_size (info);
3595-
3596-   if (set_get_element_nocopy (info, info_len - 1, &amp;cvalue) || DB_IS_NULL (&amp;cvalue))
3597-     {
3598-       /* if not exists, set comment to null */
3599-       comment = NULL;
3600-     }
3601-   else if (DB_VALUE_TYPE (&amp;cvalue) == DB_TYPE_STRING)
3602-     {
3603-       /* strdup, caller shall free it */
3604-       const char *cvalue_string = db_get_string (&amp;cvalue);
3605-       comment = strdup (cvalue_string);
3606-     }
3607-   else
3608-     {


</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
