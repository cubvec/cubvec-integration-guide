<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>base - Cubvec Integration Guide</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "light" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item "><a href="../index.html"><strong aria-hidden="true">1.</strong> Intro</a></li><li class="chapter-item "><a href="../pt_type_sequence/index.html"><strong aria-hidden="true">2.</strong> PT_TYPE_SEQUENCE</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../pt_type_sequence/parser.html"><strong aria-hidden="true">2.1.</strong> parser</a></li><li class="chapter-item "><a href="../pt_type_sequence/query.html"><strong aria-hidden="true">2.2.</strong> query</a></li><li class="chapter-item "><a href="../pt_type_sequence/optimizer.html"><strong aria-hidden="true">2.3.</strong> optimizer</a></li></ol></li><li class="chapter-item expanded "><a href="../db_type_sequence/index.html"><strong aria-hidden="true">3.</strong> DB_TYPE_SEQUENCE</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../db_type_sequence/query.html"><strong aria-hidden="true">3.1.</strong> query</a></li><li class="chapter-item "><a href="../db_type_sequence/object.html"><strong aria-hidden="true">3.2.</strong> object</a></li><li class="chapter-item "><a href="../db_type_sequence/storage.html"><strong aria-hidden="true">3.3.</strong> storage</a></li><li class="chapter-item "><a href="../db_type_sequence/parser.html"><strong aria-hidden="true">3.4.</strong> parser</a></li><li class="chapter-item expanded "><a href="../db_type_sequence/base.html" class="active"><strong aria-hidden="true">3.5.</strong> base</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Cubvec Integration Guide</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="base"><a class="header" href="#base">base</a></h1>
<pre><code class="language-cpp">memory_hash.c
641-   {
642-     DB_DATETIMETZ *dt_tz;
643-     dt_tz = db_get_datetimetz (val);
644-     hash = (unsigned int) (dt_tz-&gt;datetime.date ^ dt_tz-&gt;datetime.time);
645-   }
646-   break;
647- case DB_TYPE_DATE:
648-   {
649-     DB_DATE *date = db_get_date (val);
650-     hash = (unsigned int) (*date);
651-     break;
652-   }
653- case DB_TYPE_MONETARY:
654-   {
655-     DB_MONETARY *mon = db_get_monetary (val);
656-     hash = (unsigned int) mon-&gt;amount;
657-     break;
658-   }
659- case DB_TYPE_SET:
660- case DB_TYPE_MULTISET:
661: case DB_TYPE_SEQUENCE:
662-   db_make_null (&amp;t_val);
663-   {
664-     DB_SET *set;
665-     set = db_get_set (val);
666-     if (set_get_element (set, 0, &amp;t_val) == NO_ERROR)
667-       {
668-  hash = mht_valhash (&amp;t_val, ht_size);
669-  (void) pr_clear_value (&amp;t_val);
670-  t_n = set_size (set);
671-  if ((t_n &gt; 0) &amp;&amp; set_get_element (set, t_n - 1, &amp;t_val) == NO_ERROR)
672-    {
673-      hash += mht_valhash (&amp;t_val, ht_size);
674-      (void) pr_clear_value (&amp;t_val);
675-    }
676-       }
677-   }
678-   break;
679- case DB_TYPE_OBJECT:
680-   hash = GET_PTR_FOR_HASH (db_get_object (val));
681-   break;
</code></pre>
<pre><code class="language-cpp">
2416-    /* only the trailing ASCII space is ignored; the hashing for other characters depend on collation */
2417-    if (ptr[i] != 0x20)
2418-      {
2419-        break;
2420-      }
2421-  }
2422-       i++;
2423-     }
2424-   if (!ptr || ptr[0] == 0 || i &lt;= 0)
2425-     {
2426-       hashcode = 0;
2427-     }
2428-   else
2429-     {
2430-       hashcode = MHT2STR_COLL (db_get_string_collation (val), (unsigned char *) ptr, i);
2431-       hashcode %= ht_size;
2432-     }
2433-   break;
2434- case DB_TYPE_SET:
2435- case DB_TYPE_MULTISET:
2436: case DB_TYPE_SEQUENCE:
2437- case DB_TYPE_VOBJ:
2438-   {
2439-     int size = val-&gt;data.set-&gt;disk_size / 4;
2440-     unsigned int x = 0;
2441-     int i;
2442-
2443-     for (i = 0; i &lt; size; i++)
2444-       {
2445-  x ^= (unsigned int) (val-&gt;data.set-&gt;disk_set[i * 4]);
2446-       }
2447-
2448-     hashcode = mht_get_shiftmult32 (x, ht_size);
2449-   }
2450-   break;
2451- case DB_TYPE_ENUMERATION:
2452-   hashcode = mht_get_shiftmult32 (val-&gt;data.enumeration.short_val, ht_size);
2453-   break;
2454- case DB_TYPE_JSON:
2455-   {
2456-     char *json_body = NULL;

</code></pre>
<pre><code class="language-cpp">object_representation_sr.c
1914-  index-&gt;type = type;
1915-  index-&gt;fk = NULL;
1916-  index-&gt;attrs_prefix_length = NULL;
1917-  index-&gt;filter_predicate = NULL;
1918-  index-&gt;func_index_info = NULL;
1919-  index-&gt;index_status = OR_NO_INDEX;
1920-
1921-  /*
1922-   * For each attribute ID in the set,
1923-   *   Extract the attribute ID,
1924-   *   Find the matching attribute and insert the pointer into the array.
1925-   */
1926-
1927-  /* Remember that the attribute IDs start in the second position. */
1928-  e = 1;
1929-
1930-  for (i = 0; i &lt; att_cnt; i++)
1931-    {
1932-      if (set_get_element_nocopy (constraint_seq, e++, &amp;att_val) == NO_ERROR)
1933- {
1934:   if (DB_VALUE_TYPE (&amp;att_val) == DB_TYPE_SEQUENCE)
1935-     {
1936-       break;
1937-     }
1938-
1939-   att_id = db_get_int (&amp;att_val);
1940-   if (IS_DEDUPLICATE_KEY_ATTR_ID (att_id))
1941-     {
1942-       index-&gt;atts[index-&gt;n_atts] = (OR_ATTRIBUTE *) dk_find_or_deduplicate_key_attribute (att_id);
1943-       (index-&gt;n_atts)++;
1944-     }
1945-   else
1946-     {
1947-       for (j = 0, att = rep-&gt;attributes; j &lt; rep-&gt;n_attributes; j++, att++)
1948-  {
1949-    if (att-&gt;id == att_id)
1950-      {
1951-        index-&gt;atts[index-&gt;n_atts] = att;
1952-        (index-&gt;n_atts)++;
1953-        break;
1954-      }
</code></pre>
<pre><code class="language-cpp">
1962-   index-&gt;asc_desc[i] = db_get_int (&amp;att_val);
1963- }
1964-    }
1965-  index-&gt;btname = strdup (cons_name);
1966-
1967-  /* Get the index status. */
1968-  set_get_element_nocopy (constraint_seq, seq_size - 2, &amp;stat_val);
1969-  index-&gt;index_status = (OR_INDEX_STATUS) (db_get_int (&amp;stat_val));
1970-
1971-  if (type == BTREE_FOREIGN_KEY)
1972-    {
1973-      if (set_get_element_nocopy (constraint_seq, seq_size - 3, &amp;att_val) == NO_ERROR)
1974- {
1975-   or_install_btids_foreign_key (cons_name, db_get_set (&amp;att_val), index);
1976- }
1977-    }
1978-  else if (type == BTREE_PRIMARY_KEY)
1979-    {
1980-      if (set_get_element_nocopy (constraint_seq, seq_size - 3, &amp;att_val) == NO_ERROR)
1981- {
1982:   if (DB_VALUE_TYPE (&amp;att_val) == DB_TYPE_SEQUENCE)
1983-     {
1984-       or_install_btids_foreign_key_ref (db_get_set (&amp;att_val), index);
1985-     }
1986- }
1987-    }
1988-  else
1989-    {
1990-      if (set_get_element_nocopy (constraint_seq, seq_size - 3, &amp;att_val) == NO_ERROR)
1991- {
1992:   if (DB_VALUE_TYPE (&amp;att_val) == DB_TYPE_SEQUENCE)
1993-     {
1994-       DB_SEQ *seq = db_get_set (&amp;att_val);
1995-       DB_VALUE val;
1996-
1997-       if (set_get_element_nocopy (seq, 0, &amp;val) == NO_ERROR)
1998-  {
1999-    if (DB_VALUE_TYPE (&amp;val) == DB_TYPE_INTEGER)
2000-      {
2001-        or_install_btids_prefix_length (db_get_set (&amp;att_val), index, att_cnt);
2002-      }
2003:    else if (DB_VALUE_TYPE (&amp;val) == DB_TYPE_SEQUENCE)
2004-      {
2005-        DB_VALUE avalue;
2006-        DB_SET *child_seq = db_get_set (&amp;val);
2007-        int seq_size = set_size (seq);
2008-        int flag;
2009-
2010-        j = 0;
2011-        while (true)
2012-   {
2013-     flag = 0;
2014-     if (set_get_element_nocopy (child_seq, 0, &amp;avalue) != NO_ERROR)
2015-       {
2016-         goto next_child;
2017-       }
2018-
2019-     if (DB_IS_NULL (&amp;avalue) || DB_VALUE_TYPE (&amp;avalue) != DB_TYPE_STRING)
2020-       {
2021-         goto next_child;
2022-       }
2023-
2024-     if (strcmp (db_get_string (&amp;avalue), SM_FILTER_INDEX_ID) == 0)
2025-       {
2026-         flag = 0x01;
2027-       }
2028-     else if (strcmp (db_get_string (&amp;avalue), SM_FUNCTION_INDEX_ID) == 0)
2029-       {
2030-         flag = 0x02;
2031-       }
2032-     else if (strcmp (db_get_string (&amp;avalue), SM_PREFIX_INDEX_ID) == 0)
2033-       {
2034-         flag = 0x03;
2035-       }
2036-
2037-     if (set_get_element_nocopy (child_seq, 1, &amp;avalue) != NO_ERROR)
2038-       {
2039-         goto next_child;
2040-       }
2041-
2042:     if (DB_VALUE_TYPE (&amp;avalue) != DB_TYPE_SEQUENCE)
2043-       {
2044-         goto next_child;
2045-       }
2046-
2047-     switch (flag)
2048-       {
2049-       case 0x01:
2050-         or_install_btids_filter_pred (db_get_set (&amp;avalue), index);
2051-         break;
2052-
2053-       case 0x02:
2054-         or_install_btids_function_info (db_get_set (&amp;avalue), index);
2055-         break;
2056-
2057-       case 0x03:
2058-         or_install_btids_prefix_length (db_get_set (&amp;avalue), index, att_cnt);
2059-         break;
2060-
2061-       default:
2062-         break;
2063-       }
2064-
2065-   next_child:
2066-     j++;
2067-     if (j &gt;= seq_size)
2068-       {
2069-         break;
2070-       }
2071-
2072-     if (set_get_element_nocopy (seq, j, &amp;val) != NO_ERROR)
2073-       {
2074-         continue;
2075-       }
2076-
2077:     if (DB_VALUE_TYPE (&amp;val) != DB_TYPE_SEQUENCE)
2078-       {
2079-         continue;
2080-       }
2081-
2082-     child_seq = db_get_set (&amp;val);
2083-   }
2084-
2085-        if (index-&gt;func_index_info)
2086-   {
2087-     /* function index and prefix length not allowed, yet */
2088-     index-&gt;attrs_prefix_length = (int *) malloc (sizeof (int) * att_cnt);
2089-     if (index-&gt;attrs_prefix_length == NULL)
2090-       {
2091-         er_set (ER_ERROR_SEVERITY, ARG_FILE_LINE, ER_OUT_OF_VIRTUAL_MEMORY, 1,
2092-          sizeof (int) * att_cnt);
2093-         return;
2094-       }
2095-     for (i = 0; i &lt; att_cnt; i++)
2096-       {
2097-         index-&gt;attrs_prefix_length[i] = -1;
</code></pre>
<pre><code class="language-cpp">
2297-    {SM_PROPERTY_UNIQUE, NULL, BTREE_UNIQUE, 0},
2298-    {SM_PROPERTY_REVERSE_UNIQUE, NULL, BTREE_REVERSE_UNIQUE, 0},
2299-    {SM_PROPERTY_INDEX, NULL, BTREE_INDEX, 0},
2300-    {SM_PROPERTY_REVERSE_INDEX, NULL, BTREE_REVERSE_INDEX, 0}
2301-  };
2302-
2303-  DB_VALUE vals[SM_PROPERTY_NUM_INDEX_FAMILY];
2304-  int i;
2305-  int n_btids;
2306-
2307-  /*
2308-   *  The first thing to do is to determine how many unique and index
2309-   *  BTIDs we have.  We need this up front so that we can allocate
2310-   *  the OR_INDEX structure in the class (rep).
2311-   */
2312-  n_btids = 0;
2313-  for (i = 0; i &lt; SM_PROPERTY_NUM_INDEX_FAMILY; i++)
2314-    {
2315-      if (props != NULL &amp;&amp; or_cl_get_prop_nocopy (props, property_vars[i].name, &amp;vals[i]))
2316- {
2317:   if (DB_VALUE_TYPE (&amp;vals[i]) == DB_TYPE_SEQUENCE)
2318-     {
2319-       property_vars[i].seq = db_get_set (&amp;vals[i]);
2320-     }
2321-
2322-   if (property_vars[i].seq)
2323-     {
2324-       property_vars[i].length = set_size (property_vars[i].seq);
2325-       n_btids += property_vars[i].length;
2326-     }
2327- }
2328-    }
2329-
2330-  n_btids /= 2;
2331-
2332-  if (n_btids &gt; 0)
2333-    {
2334-      rep-&gt;indexes = (OR_INDEX *) malloc (sizeof (OR_INDEX) * n_btids);
2335-      if (rep-&gt;indexes == NULL)
2336- {
2337-   er_set (ER_ERROR_SEVERITY, ARG_FILE_LINE, ER_OUT_OF_VIRTUAL_MEMORY, 1, sizeof (OR_INDEX) * n_btids);
</code></pre>
<pre><code class="language-cpp">
2346-    {
2347-      if (property_vars[i].seq)
2348- {
2349-   int j;
2350-   DB_VALUE ids_val, cons_name_val;
2351-   DB_SEQ *ids_seq;
2352-   const char *cons_name = NULL;
2353-   int error = NO_ERROR;
2354-
2355-   for (j = 0; j &lt; property_vars[i].length &amp;&amp; error == NO_ERROR; j += 2)
2356-     {
2357-       error = set_get_element_nocopy (property_vars[i].seq, j, &amp;cons_name_val);
2358-       if (error == NO_ERROR)
2359-  {
2360-    cons_name = db_get_string (&amp;cons_name_val);
2361-  }
2362-
2363-       error = set_get_element_nocopy (property_vars[i].seq, j + 1, &amp;ids_val);
2364-       if (error == NO_ERROR &amp;&amp; cons_name != NULL)
2365-  {
2366:    if (DB_VALUE_TYPE (&amp;ids_val) == DB_TYPE_SEQUENCE)
2367-      {
2368-        ids_seq = db_get_set (&amp;ids_val);
2369-        or_install_btids_constraint (rep, ids_seq, property_vars[i].type, cons_name);
2370-      }
2371-  }
2372-     }
2373- }
2374-    }
2375-}
2376-
2377-/*
2378- * or_get_current_representation () - build an OR_CLASSREP structure for the
2379- *                                    most recent representation
2380- *   return: disk representation structure
2381- *   record(in): disk record
2382- *   do_indexes(in):
2383- *
2384- * Note: This is similar to the old function orc_diskrep_from_record, but is
2385- *       a little simpler now that we don't need to maintain a separate
2386- *       list for the fixed and variable length attributes.
</code></pre>
<pre><code class="language-cpp">
2574-
2575-      /* get the default value - constant, this could be using a new DB_VALUE ? */
2576-      if (original_val_len &gt; 0)
2577- {
2578-   if (or_get_default_value (att, original_val_ptr, original_val_len) == 0)
2579-     {
2580-       goto error_cleanup;
2581-     }
2582- }
2583-
2584-      /* get the default expression. */
2585-      classobj_initialize_default_expr (&amp;att-&gt;current_default_value.default_expr);
2586-      att-&gt;on_update_expr = DB_DEFAULT_NONE;
2587-      if (properties_val_len &gt; 0)
2588- {
2589-   db_make_null (&amp;properties_val);
2590-   db_make_null (&amp;def_expr);
2591-   db_make_null (&amp;def_expr_op);
2592-   db_make_null (&amp;def_expr_format);
2593-
2594:   or_get_value (&amp;buf, &amp;properties_val, tp_domain_resolve_default (DB_TYPE_SEQUENCE), properties_val_len, true);
2595-   att_props = db_get_set (&amp;properties_val);
2596-
2597-   if (att_props != NULL &amp;&amp; classobj_get_prop (att_props, "default_expr", &amp;def_expr) &gt; 0)
2598-     {
2599-       /* We have two cases: simple and complex expression. */
2600:       if (DB_VALUE_TYPE (&amp;def_expr) == DB_TYPE_SEQUENCE)
2601-  {
2602-    /*
2603-     * We can't have an attribute with default expression and default value simultaneously. However,
2604-     * in some situations attr-&gt;default_value.value contains the value of default expression. This happens
2605-     * when the client executes the query on broker side and use attr-&gt;default_value.value to cache
2606-     * the default expression value. Then the broker can modify the schema and send to server the default
2607-     * expression and its cached value. Another option may be to clear default value on broker side,
2608-     * but may lead to inconsistency.
2609-     */
2610-
2611-    /* Currently, we allow only (T_TO_CHAR(int), default_expr(int), default_expr_format(string)) */
2612-    assert (set_size (db_get_set (&amp;def_expr)) == 3);
2613-
2614-    def_expr_set = db_get_set (&amp;def_expr);
2615-
2616-    /* get and cache default expression operator - op of expr */
2617-    if (set_get_element_nocopy (def_expr_set, 0, &amp;def_expr_op) != NO_ERROR)
2618-      {
2619-        assert (false);
2620-        pr_clear_value (&amp;def_expr);
</code></pre>
<pre><code class="language-cpp">
3539-      error = set_get_element_nocopy (setref, i, &amp;value);
3540-      if (error != NO_ERROR || DB_VALUE_TYPE (&amp;value) != DB_TYPE_STRING)
3541- {
3542-   goto error_exit;
3543- }
3544-
3545-      prop_name = db_get_string (&amp;value);
3546-      if (prop_name == NULL)
3547- {
3548-   goto error_exit;
3549- }
3550-
3551-      if (strcmp (prop_name, SM_PROPERTY_PRIMARY_KEY) != 0 &amp;&amp; strcmp (prop_name, SM_PROPERTY_UNIQUE) != 0
3552-   &amp;&amp; strcmp (prop_name, SM_PROPERTY_REVERSE_UNIQUE) != 0 &amp;&amp; strcmp (prop_name, SM_PROPERTY_INDEX) != 0
3553-   &amp;&amp; strcmp (prop_name, SM_PROPERTY_REVERSE_INDEX) != 0 &amp;&amp; strcmp (prop_name, SM_PROPERTY_FOREIGN_KEY) != 0)
3554- {
3555-   continue;
3556- }
3557-
3558-      error = set_get_element_nocopy (setref, i + 1, &amp;value);
3559:      if (error != NO_ERROR || DB_VALUE_TYPE (&amp;value) != DB_TYPE_SEQUENCE)
3560- {
3561-   goto error_exit;
3562- }
3563-
3564-      /* this sequence is an alternating pair of constraint name &amp; info sequence, as by: { name, { BTID, [att_name,
3565-       * asc_dsc], {fk_info | pk_info | prefix_length}, filter_predicate, comment}, name, { BTID, [att_name, asc_dsc],
3566-       * {fk_info | pk_info | prefix_length}, filter_predicate, comment}, ... } */
3567-      props = db_get_set (&amp;value);
3568-      len = set_size (props);
3569-      for (j = 0; j &lt; len; j += 2)
3570- {
3571-   /* get the name */
3572-   if (set_get_element_nocopy (props, j, &amp;uvalue) || DB_VALUE_TYPE (&amp;uvalue) != DB_TYPE_STRING)
3573-     {
3574-       goto error_exit;
3575-     }
3576-
3577-   if (strcmp (constraint_name, db_get_string (&amp;uvalue)) != 0)
3578-     {
3579-       continue;
3580-     }
3581-
3582-   found = true;
3583-
3584-   if (set_get_element_nocopy (props, j + 1, &amp;uvalue))
3585-     {
3586-       goto error_exit;
3587-     }
3588:   if (DB_VALUE_TYPE (&amp;uvalue) != DB_TYPE_SEQUENCE)
3589-     {
3590-       goto error_exit;
3591-     }
3592-
3593-   info = db_get_set (&amp;uvalue);
3594-   info_len = set_size (info);
3595-
3596-   if (set_get_element_nocopy (info, info_len - 1, &amp;cvalue) || DB_IS_NULL (&amp;cvalue))
3597-     {
3598-       /* if not exists, set comment to null */
3599-       comment = NULL;
3600-     }
3601-   else if (DB_VALUE_TYPE (&amp;cvalue) == DB_TYPE_STRING)
3602-     {
3603-       /* strdup, caller shall free it */
3604-       const char *cvalue_string = db_get_string (&amp;cvalue);
3605-       comment = strdup (cvalue_string);
3606-     }
3607-   else
3608-     {


</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../db_type_sequence/parser.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../db_type_sequence/parser.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
